user_input,retrieved_contexts,response,reference,context_precision,faithfulness,answer_relevancy
怎么保证前端传给我的 JSON 数据里，'price' 字段一定是数字而不是字符串？如果不合法自动报错吗？,"['# 路径参数\n\nFastAPI 支持使用 Python 字符串格式化语法声明路径参数（变量）：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_item(item_id):\n    return {""item_id"": item_id}\n\n```\n\n\n这段代码把路径参数 `item_id` 的值传递给路径函数的参数 `item_id`。\n\n运行示例并访问 http://127.0.0.1:8000/items/foo，可获得如下响应：\n\n```JSON\n{""item_id"":""foo""}\n```\n\n## 声明路径参数的类型\n\n使用 Python 标准类型注解，声明路径操作函数中路径参数的类型。\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_item(item_id: int):\n    return {""item_id"": item_id}\n\n```\n\n\n本例把 `item_id` 的类型声明为 `int`。\n\n/// check | 检查\n\n类型声明将为函数提供错误检查、代码补全等编辑器支持。\n\n///\n\n## 数据<abbr title=""也称为：序列化、解析"">转换</abbr>\n\n运行示例并访问 http://127.0.0.1:8000/items/3，返回的响应如下：\n\n```JSON\n{""item_id"":3}\n```\n\n/// check | 检查\n\n注意，函数接收并返回的值是 `3`（ `int`），不是 `""3""`（`str`）。\n\nFastAPI 通过类型声明自动<abbr title=""将来自 HTTP 请求中的字符串转换为 Python 数据类型"">解析请求中的数据</abbr>。\n\n///\n\n## 数据校验\n\n通过浏览器访问 http://127.0.0.1:8000/items/foo，接收如下 HTTP 错误信息：\n\n```JSON\n{\n    ""detail"": [\n        {\n            ""loc"": [\n                ""path"",\n                ""item_id""\n            ],\n            ""msg"": ""value is not a valid integer"",\n            ""type"": ""type_error.integer""\n        }\n    ]\n}\n```\n\n这是因为路径参数 `item_id` 的值 （`""foo""`）的类型不是 `int`。\n\n值的类型不是 `int ` 而是浮点数（`float`）时也会显示同样的错误，比如： http://127.0.0.1:8000/items/4.2。\n\n/// check | 检查\n\nFastAPI 使用 Python 类型声明实现了数据校验。\n\n注意，上面的错误清晰地指出了未通过校验的具体原因。\n\n这在开发调试与 API 交互的代码时非常有用。\n\n///\n\n## 查看文档\n\n访问 http://127.0.0.1:8000/docs，查看自动生成的 API 文档：\n\n/// check | 检查\n\n还是使用 Python 类型声明，FastAPI 提供了（集成 Swagger UI 的）API 文档。\n\n注意，路径参数的类型是整数。\n\n///\n\n## 基于标准的好处，备选文档\n\nFastAPI 使用 OpenAPI 生成概图，所以能兼容很多工具。\n\n因此，FastAPI 还内置了 ReDoc 生成的备选 API 文档，可在此查看 http://127.0.0.1:8000/redoc：\n\n同样，还有很多兼容工具，包括多种语言的代码生成工具。\n\n## Pydantic\n\nFastAPI 充分地利用了 Pydantic 的优势，用它在后台校验数据。众所周知，Pydantic 擅长的就是数据校验。\n\n同样，`str`、`float`、`bool` 以及很多复合数据类型都可以使用类型声明。\n\n下一章介绍详细内容。\n\n## 顺序很重要\n\n有时，*路径操作*中的路径是写死的。\n\n比如要使用 `/users/me` 获取当前用户的数据。\n\n然后还要使用 `/users/{user_id}`，通过用户 ID 获取指定用户的数据。\n\n由于*路径操作*是按顺序依次运行的，因此，一定要在 `/users/{user_id}` 之前声明 `/users/me` ：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(""/users/me"")\nasync def read_user_me():\n    return {""user_id"": ""the current user""}\n\n\n@app.get(""/users/{user_id}"")\nasync def read_user(user_id: str):\n    return {""user_id"": user_id}\n\n```\n\n\n否则，`/users/{user_id}` 将匹配 `/users/me`，FastAPI 会认为正在接收值为 `""me""` 的 `user_id` 参数。\n\n## 预设值\n\n路径操作使用 Python 的 <abbr title=""Enumeration"">`Enum`</abbr> 类型接收预设的*路径参数*。\n\n### 创建 `Enum` 类\n\n导入 `Enum` 并创建继承自 `str` 和 `Enum` 的子类。\n\n通过从 `str` 继承，API 文档就能把值的类型定义为字符串，并且能正确渲染。\n\n然后，创建包含固定值的类属性，这些固定值是可用的有效值：\n\n\n```py\nfrom enum import Enum\n\nfrom fastapi import FastAPI\n\n\nclass ModelName(str, Enum):\n    alexnet = ""alexnet""\n    resnet = ""resnet""\n    lenet = ""lenet""\n\n\napp = FastAPI()\n\n\n@app.get(""/models/{model_name}"")\nasync def get_model(model_name: ModelName):\n    if model_name is ModelName.alexnet:\n        return {""model_name"": model_name, ""message"": ""Deep Learning FTW!""}\n\n    if model_name.value == ""lenet"":\n        return {""model_name"": model_name, ""message"": ""LeCNN all the images""}\n\n    return {""model_name"": model_name, ""message"": ""Have some residuals""}\n\n```\n\n\n/// info | 说明\n\nPython 3.4 及之后版本支持枚举（即 enums）。\n\n///\n\n/// tip | 提示\n\nAlexNet、ResNet、LeNet 是机器学习<abbr title=""技术上来说是深度学习模型架构"">模型</abbr>。\n\n///\n\n### 声明*路径参数*\n\n使用 Enum 类（`ModelName`）创建使用类型注解的*路径参数*：\n\n\n> *[Ref: Code file `tutorial005_py39.py` is already included above]*\n\n\n### 查看文档\n\n API 文档会显示预定义*路径参数*的可用值：\n\n### 使用 Python _枚举类型_\n\n*路径参数*的值是枚举的元素。\n\n#### 比较*枚举元素*\n\n枚举类 `ModelName` 中的*枚举元素*支持比较操作：\n\n\n> *[Ref: Code file `tutorial005_py39.py` is already included above]*\n\n\n#### 获取*枚举值*\n\n使用 `model_name.value` 或 `your_enum_member.value` 获取实际的值（本例中为字符串）：\n\n\n> *[Ref: Code file `tutorial005_py39.py` is already included above]*\n\n\n/// tip | 提示\n\n使用 `ModelName.lenet.value` 也能获取值 `""lenet""`。\n\n///\n\n#### 返回*枚举元素*\n\n即使嵌套在 JSON 请求体里（例如， `dict`），也可以从*路径操作*返回*枚举元素*。\n\n返回给客户端之前，要把枚举元素转换为对应的值（本例中为字符串）：\n\n\n> *[Ref: Code file `tutorial005_py39.py` is already included above]*\n\n\n客户端中的 JSON 响应如下：\n\n```JSON\n{\n  ""model_name"": ""alexnet"",\n  ""message"": ""Deep Learning FTW!""\n}\n```\n\n## 包含路径的路径参数\n\n假设*路径操作*的路径为 `/files/{file_path}`。\n\n但需要 `file_path` 中也包含*路径*，比如，`home/johndoe/myfile.txt`。\n\n此时，该文件的 URL 是这样的：`/files/home/johndoe/myfile.txt`。\n\n### OpenAPI 支持\n\nOpenAPI 不支持声明包含路径的*路径参数*，因为这会导致测试和定义更加困难。\n\n不过，仍可使用 Starlette 内置工具在 FastAPI 中实现这一功能。\n\n而且不影响文档正常运行，但是不会添加该参数包含路径的说明。\n\n### 路径转换器\n\n直接使用 Starlette 的选项声明包含*路径*的*路径参数*：\n\n```\n/files/{file_path:path}\n```\n\n本例中，参数名为 `file_path`，结尾部分的 `:path` 说明该参数应匹配*路径*。\n\n用法如下：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(""/files/{file_path:path}"")\nasync def read_file(file_path: str):\n    return {""file_path"": file_path}\n\n```\n\n\n/// tip | 提示\n\n注意，包含 `/home/johndoe/myfile.txt` 的路径参数要以斜杠（`/`）开头。\n\n本例中的 URL 是 `/files//home/johndoe/myfile.txt`。注意，`files` 和 `home` 之间要使用双斜杠（`//`）。\n\n///\n\n## 小结\n\n通过简短、直观的 Python 标准类型声明，FastAPI 可以获得：\n\n- 编辑器支持：错误检查，代码自动补全等\n- 数据<abbr title=""把来自 HTTP 请求中的字符串转换为 Python 数据类型"">解析</abbr>\n- 数据校验\n- API 注解和 API 文档\n\n只需要声明一次即可。\n\n这可能是除了性能以外，FastAPI 与其它框架相比的主要优势。', '# 生成客户端\n\n因为 FastAPI 是基于OpenAPI规范的，自然您可以使用许多相匹配的工具，包括自动生成API文档 (由 Swagger UI 提供)。\n\n一个不太明显而又特别的优势是，你可以为你的API针对不同的编程语言来生成客户端(有时候被叫做 <abbr title=""Software Development Kits"">SDKs</abbr> )。\n\n## OpenAPI 客户端生成\n\n有许多工具可以从OpenAPI生成客户端。\n\n一个常见的工具是 OpenAPI Generator。\n\n如果您正在开发前端，一个非常有趣的替代方案是 openapi-ts。\n\n## 生成一个 TypeScript 前端客户端\n\n让我们从一个简单的 FastAPI 应用开始：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n\nclass ResponseMessage(BaseModel):\n    message: str\n\n\n@app.post(""/items/"", response_model=ResponseMessage)\nasync def create_item(item: Item):\n    return {""message"": ""item received""}\n\n\n@app.get(""/items/"", response_model=list[Item])\nasync def get_items():\n    return [\n        {""name"": ""Plumbus"", ""price"": 3},\n        {""name"": ""Portal Gun"", ""price"": 9001},\n    ]\n\n```\n\n\n请注意，*路径操作* 定义了他们所用于请求数据和回应数据的模型，所使用的模型是`Item` 和 `ResponseMessage`。\n\n### API 文档\n\n如果您访问API文档，您将看到它具有在请求中发送和在响应中接收数据的模式(schemas)：\n\n您可以看到这些模式，因为它们是用程序中的模型声明的。\n\n那些信息可以在应用的 OpenAPI模式 被找到，然后显示在API文档中（通过Swagger UI）。\n\nOpenAPI中所包含的模型里有相同的信息可以用于 生成客户端代码。\n\n### 生成一个TypeScript 客户端\n\n现在我们有了带有模型的应用，我们可以为前端生成客户端代码。\n\n#### 安装 `openapi-ts`\n\n您可以使用以下工具在前端代码中安装 `openapi-ts`:\n\n```console\n$ npm install @hey-api/openapi-ts --save-dev\n\n&gt; 100%\n```\n\n#### 生成客户端代码\n\n要生成客户端代码，您可以使用现在将要安装的命令行应用程序 `openapi-ts`。\n\n因为它安装在本地项目中，所以您可能无法直接使用此命令，但您可以将其放在 `package.json` 文件中。\n\n它可能看起来是这样的:\n\n```JSON  hl_lines=""7""\n{\n  ""name"": ""frontend-app"",\n  ""version"": ""1.0.0"",\n  ""description"": """",\n  ""main"": ""index.js"",\n  ""scripts"": {\n    ""generate-client"": ""openapi-ts --input http://localhost:8000/openapi.json --output ./src/client --client axios""\n  },\n  ""author"": """",\n  ""license"": """",\n  ""devDependencies"": {\n    ""@hey-api/openapi-ts"": ""^0.27.38"",\n    ""typescript"": ""^4.6.2""\n  }\n}\n```\n\n在这里添加 NPM `generate-client` 脚本后，您可以使用以下命令运行它:\n\n```console\n$ npm run generate-client\n\nfrontend-app@1.0.0 generate-client /home/user/code/frontend-app\n&gt; openapi-ts --input http://localhost:8000/openapi.json --output ./src/client --client axios\n```\n\n此命令将在 `./src/client` 中生成代码，并将在其内部使用 `axios`（前端HTTP库）。\n\n### 尝试客户端代码\n\n现在您可以导入并使用客户端代码，它可能看起来像这样，请注意，您可以为这些方法使用自动补全：\n\n您还将自动补全要发送的数据：\n\n/// tip\n\n请注意， `name` 和 `price` 的自动补全，是通过其在`Item`模型(FastAPI)中的定义实现的。\n\n///\n\n如果发送的数据字段不符，你也会看到编辑器的错误提示:\n\n响应(response)对象也拥有自动补全:\n\n## 带有标签的 FastAPI 应用\n\n在许多情况下，你的FastAPI应用程序会更复杂，你可能会使用标签来分隔不同组的*路径操作(path operations)*。\n\n例如，您可以有一个用 `items` 的部分和另一个用于 `users` 的部分，它们可以用标签来分隔：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n\nclass ResponseMessage(BaseModel):\n    message: str\n\n\nclass User(BaseModel):\n    username: str\n    email: str\n\n\n@app.post(""/items/"", response_model=ResponseMessage, tags=[""items""])\nasync def create_item(item: Item):\n    return {""message"": ""Item received""}\n\n\n@app.get(""/items/"", response_model=list[Item], tags=[""items""])\nasync def get_items():\n    return [\n        {""name"": ""Plumbus"", ""price"": 3},\n        {""name"": ""Portal Gun"", ""price"": 9001},\n    ]\n\n\n@app.post(""/users/"", response_model=ResponseMessage, tags=[""users""])\nasync def create_user(user: User):\n    return {""message"": ""User received""}\n\n```\n\n\n### 生成带有标签的 TypeScript 客户端\n\n如果您使用标签为FastAPI应用生成客户端，它通常也会根据标签分割客户端代码。\n\n通过这种方式，您将能够为客户端代码进行正确地排序和分组：\n\n在这个案例中，您有：\n\n* `ItemsService`\n* `UsersService`\n\n### 客户端方法名称\n\n现在生成的方法名像 `createItemItemsPost` 看起来不太简洁:\n\n```TypeScript\nItemsService.createItemItemsPost({name: ""Plumbus"", price: 5})\n```\n\n...这是因为客户端生成器为每个 *路径操作* 使用OpenAPI的内部 操作 ID(operation ID)。\n\nOpenAPI要求每个操作 ID 在所有 *路径操作* 中都是唯一的，因此 FastAPI 使用函数名、路径和HTTP方法/操作来生成此操作ID，因为这样可以确保这些操作 ID 是唯一的。\n\n但接下来我会告诉你如何改进。 🤓\n\n## 自定义操作ID和更好的方法名\n\n您可以修改这些操作ID的生成方式，以使其更简洁，并在客户端中具有更简洁的方法名称。\n\n在这种情况下，您必须确保每个操作ID在其他方面是唯一的。\n\n例如，您可以确保每个*路径操作*都有一个标签，然后根据标签和*路径操作*名称（函数名）来生成操作ID。\n\n### 自定义生成唯一ID函数\n\nFastAPI为每个*路径操作*使用一个唯一ID，它用于操作ID，也用于任何所需自定义模型的名称，用于请求或响应。\n\n你可以自定义该函数。它接受一个 `APIRoute` 对象作为输入，并输出一个字符串。\n\n例如，以下是一个示例，它使用第一个标签（你可能只有一个标签）和*路径操作*名称（函数名）。\n\n然后，你可以将这个自定义函数作为 `generate_unique_id_function` 参数传递给 FastAPI:\n\n\n```py\nfrom fastapi import FastAPI\nfrom fastapi.routing import APIRoute\nfrom pydantic import BaseModel\n\n\ndef custom_generate_unique_id(route: APIRoute):\n    return f""{route.tags[0]}-{route.name}""\n\n\napp = FastAPI(generate_unique_id_function=custom_generate_unique_id)\n\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n\nclass ResponseMessage(BaseModel):\n    message: str\n\n\nclass User(BaseModel):\n    username: str\n    email: str\n\n\n@app.post(""/items/"", response_model=ResponseMessage, tags=[""items""])\nasync def create_item(item: Item):\n    return {""message"": ""Item received""}\n\n\n@app.get(""/items/"", response_model=list[Item], tags=[""items""])\nasync def get_items():\n    return [\n        {""name"": ""Plumbus"", ""price"": 3},\n        {""name"": ""Portal Gun"", ""price"": 9001},\n    ]\n\n\n@app.post(""/users/"", response_model=ResponseMessage, tags=[""users""])\nasync def create_user(user: User):\n    return {""message"": ""User received""}\n\n```\n\n\n### 使用自定义操作ID生成TypeScript客户端\n\n现在，如果你再次生成客户端，你会发现它具有改善的方法名称：\n\n正如你所见，现在方法名称中只包含标签和函数名，不再包含URL路径和HTTP操作的信息。\n\n### 预处理用于客户端生成器的OpenAPI规范\n\n生成的代码仍然存在一些重复的信息。\n\n我们已经知道该方法与 items 相关，因为它在 `ItemsService` 中（从标签中获取），但方法名中仍然有标签名作为前缀。😕\n\n一般情况下对于OpenAPI，我们可能仍然希望保留它，因为这将确保操作ID是唯一的。\n\n但对于生成的客户端，我们可以在生成客户端之前修改 OpenAPI 操作ID，以使方法名称更加美观和简洁。\n\n我们可以将 OpenAPI JSON 下载到一个名为`openapi.json`的文件中，然后使用以下脚本删除此前缀的标签：\n\n\n```py\nimport json\nfrom pathlib import Path\n\nfile_path = Path(""./openapi.json"")\nopenapi_content = json.loads(file_path.read_text())\n\nfor path_data in openapi_content[""paths""].values():\n    for operation in path_data.values():\n        tag = operation[""tags""][0]\n        operation_id = operation[""operationId""]\n        to_remove = f""{tag}-""\n        new_operation_id = operation_id[len(to_remove) :]\n        operation[""operationId""] = new_operation_id\n\nfile_path.write_text(json.dumps(openapi_content))\n\n```\n\n\n通过这样做，操作ID将从类似于 `items-get_items` 的名称重命名为 `get_items` ，这样客户端生成器就可以生成更简洁的方法名称。\n\n### 使用预处理的OpenAPI生成TypeScript客户端\n\n现在，由于最终结果保存在文件openapi.json中，你可以修改 package.json 文件以使用此本地文件，例如：\n\n```JSON  hl_lines=""7""\n{\n  ""name"": ""frontend-app"",\n  ""version"": ""1.0.0"",\n  ""description"": """",\n  ""main"": ""index.js"",\n  ""scripts"": {\n    ""generate-client"": ""openapi-ts --input ./openapi.json --output ./src/client --client axios""\n  },\n  ""author"": """",\n  ""license"": """",\n  ""devDependencies"": {\n    ""@hey-api/openapi-ts"": ""^0.27.38"",\n    ""typescript"": ""^4.6.2""\n  }\n}\n```\n\n生成新的客户端之后，你现在将拥有清晰的方法名称，具备自动补全、错误提示等功能：\n\n## 优点\n\n当使用自动生成的客户端时，你将获得以下的自动补全功能：\n\n* 方法。\n* 请求体中的数据、查询参数等。\n* 响应数据。\n\n你还将获得针对所有内容的错误提示。\n\n每当你更新后端代码并重新生成前端代码时，新的*路径操作*将作为方法可用，旧的方法将被删除，并且其他任何更改将反映在生成的代码中。 🤓\n\n这也意味着如果有任何更改，它将自动反映在客户端代码中。如果你构建客户端，在使用的数据上存在不匹配时，它将报错。\n\n因此，你将在开发周期的早期检测到许多错误，而不必等待错误在生产环境中向最终用户展示，然后尝试调试问题所在。 ✨', '# 路径参数和数值校验\n\n与使用 `Query` 为查询参数声明更多的校验和元数据的方式相同，你也可以使用 `Path` 为路径参数声明相同类型的校验和元数据。\n\n## 导入 Path\n\n首先，从 `fastapi` 导入 `Path`：\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Path, Query\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_items(\n    item_id: Annotated[int, Path(title=""The ID of the item to get"")],\n    q: Annotated[str | None, Query(alias=""item-query"")] = None,\n):\n    results = {""item_id"": item_id}\n    if q:\n        results.update({""q"": q})\n    return results\n\n```\n\n\n## 声明元数据\n\n你可以声明与 `Query` 相同的所有参数。\n\n例如，要声明路径参数 `item_id`的 `title` 元数据值，你可以输入：\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n/// note\n\n路径参数总是必需的，因为它必须是路径的一部分。\n\n所以，你应该在声明时使用 `...` 将其标记为必需参数。\n\n然而，即使你使用 `None` 声明路径参数或设置一个其他默认值也不会有任何影响，它依然会是必需参数。\n\n///\n\n## 按需对参数排序\n\n假设你想要声明一个必需的 `str` 类型查询参数 `q`。\n\n而且你不需要为该参数声明任何其他内容，所以实际上你并不需要使用 `Query`。\n\n但是你仍然需要使用 `Path` 来声明路径参数 `item_id`。\n\n如果你将带有「默认值」的参数放在没有「默认值」的参数之前，Python 将会报错。\n\n但是你可以对其重新排序，并将不带默认值的值（查询参数 `q`）放到最前面。\n\n对 FastAPI 来说这无关紧要。它将通过参数的名称、类型和默认值声明（`Query`、`Path` 等）来检测参数，而不在乎参数的顺序。\n\n因此，你可以将函数声明为：\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Path\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_items(\n    q: str, item_id: Annotated[int, Path(title=""The ID of the item to get"")]\n):\n    results = {""item_id"": item_id}\n    if q:\n        results.update({""q"": q})\n    return results\n\n```\n\n\n## 按需对参数排序的技巧\n\n如果你想不使用 `Query` 声明没有默认值的查询参数 `q`，同时使用 `Path` 声明路径参数 `item_id`，并使它们的顺序与上面不同，Python 对此有一些特殊的语法。\n\n传递 `*` 作为函数的第一个参数。\n\nPython 不会对该 `*` 做任何事情，但是它将知道之后的所有参数都应作为关键字参数（键值对），也被称为 <abbr title=""来自：K-ey W-ord Arg-uments""><code>kwargs</code></abbr>，来调用。即使它们没有默认值。\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Path\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_items(\n    item_id: Annotated[int, Path(title=""The ID of the item to get"")], q: str\n):\n    results = {""item_id"": item_id}\n    if q:\n        results.update({""q"": q})\n    return results\n\n```\n\n\n## 数值校验：大于等于\n\n使用 `Query` 和 `Path`（以及你将在后面看到的其他类）可以声明字符串约束，但也可以声明数值约束。\n\n像下面这样，添加 `ge=1` 后，`item_id` 将必须是一个大于（`g`reater than）或等于（`e`qual）`1` 的整数。\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Path\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_items(\n    item_id: Annotated[int, Path(title=""The ID of the item to get"", ge=1)], q: str\n):\n    results = {""item_id"": item_id}\n    if q:\n        results.update({""q"": q})\n    return results\n\n```\n\n\n## 数值校验：大于和小于等于\n\n同样的规则适用于：\n\n* `gt`：大于（`g`reater `t`han）\n* `le`：小于等于（`l`ess than or `e`qual）\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Path\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_items(\n    item_id: Annotated[int, Path(title=""The ID of the item to get"", gt=0, le=1000)],\n    q: str,\n):\n    results = {""item_id"": item_id}\n    if q:\n        results.update({""q"": q})\n    return results\n\n```\n\n\n## 数值校验：浮点数、大于和小于\n\n数值校验同样适用于 `float` 值。\n\n能够声明 <abbr title=""大于""><code>gt</code></abbr> 而不仅仅是 <abbr title=""大于等于""><code>ge</code></abbr> 在这个前提下变得重要起来。例如，你可以要求一个值必须大于 `0`，即使它小于 `1`。\n\n因此，`0.5` 将是有效值。但是 `0.0`或 `0` 不是。\n\n对于 <abbr title=""less than""><code>lt</code></abbr> 也是一样的。\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Path, Query\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_items(\n    *,\n    item_id: Annotated[int, Path(title=""The ID of the item to get"", ge=0, le=1000)],\n    q: str,\n    size: Annotated[float, Query(gt=0, lt=10.5)],\n):\n    results = {""item_id"": item_id}\n    if q:\n        results.update({""q"": q})\n    if size:\n        results.update({""size"": size})\n    return results\n\n```\n\n\n## 总结\n\n你能够以与 [查询参数和字符串校验](query-params-str-validations.md){.internal-link target=_blank} 相同的方式使用 `Query`、`Path`（以及其他你还没见过的类）声明元数据和字符串校验。\n\n而且你还可以声明数值校验：\n\n* `gt`：大于（`g`reater `t`han）\n* `ge`：大于等于（`g`reater than or `e`qual）\n* `lt`：小于（`l`ess `t`han）\n* `le`：小于等于（`l`ess than or `e`qual）\n\n/// info\n\n`Query`、`Path` 以及你后面会看到的其他类继承自一个共同的 `Param` 类（不需要直接使用它）。\n\n而且它们都共享相同的所有你已看到并用于添加额外校验和元数据的参数。\n\n///\n\n/// note | 技术细节\n\n当你从 `fastapi` 导入 `Query`、`Path` 和其他同类对象时，它们实际上是函数。\n\n当被调用时，它们返回同名类的实例。\n\n如此，你导入 `Query` 这个函数。当你调用它时，它将返回一个同样命名为 `Query` 的类的实例。\n\n因为使用了这些函数（而不是直接使用类），所以你的编辑器不会标记有关其类型的错误。\n\n这样，你可以使用常规的编辑器和编码工具，而不必添加自定义配置来忽略这些错误。\n\n///']","根据上下文中的FastAPI特性：  
1. 在路径操作函数中使用类型注解声明参数类型（如 `price: float`），FastAPI会自动进行数据校验和转换。  
2. 若前端传入的 `price` 字段类型不合法（如字符串），FastAPI会返回结构化错误（如 `""type_error.float""`），并明确提示校验失败原因。  
3. 此机制依赖Pydantic模型的数据校验能力，确保字段类型与声明一致。  

示例模型：  
```python
class Item(BaseModel):
    price: float  # 声明为数字类型
```",你应该使用 Pydantic 模型来定义数据结构。通过创建一个继承自 `pydantic.BaseModel` 的类，并将 'price' 字段声明为 `float` 或 `int` 类型（例如 `price: float`），FastAPI 会自动进行数据校验。如果前端传来的数据类型不匹配（且无法转换），FastAPI 会自动拦截请求并返回 422 Unprocessable Entity 错误，其中包含详细的错误信息，无需手动编写报错逻辑。,0.99999999995,1.0,0.6059163370785341
我想在好几个接口里复用同一段代码，比如检查用户 Token，但我不想写装饰器，也不想在每个函数里写一遍调用。,"['# 获取当前用户\n\n上一章中，（基于依赖注入系统的）安全系统向*路径操作函数*传递了 `str` 类型的 `token`：\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2PasswordBearer\n\napp = FastAPI()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=""token"")\n\n\n@app.get(""/items/"")\nasync def read_items(token: Annotated[str, Depends(oauth2_scheme)]):\n    return {""token"": token}\n\n```\n\n\n但这并不实用。\n\n接下来，我们学习如何返回当前用户。\n\n## 创建用户模型\n\n首先，创建 Pydantic 用户模型。\n\n与使用 Pydantic 声明请求体相同，并且可在任何位置使用：\n\n\n```py\nfrom typing import Annotated, Union\n\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2PasswordBearer\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=""token"")\n\n\nclass User(BaseModel):\n    username: str\n    email: Union[str, None] = None\n    full_name: Union[str, None] = None\n    disabled: Union[bool, None] = None\n\n\ndef fake_decode_token(token):\n    return User(\n        username=token + ""fakedecoded"", email=""john@example.com"", full_name=""John Doe""\n    )\n\n\nasync def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):\n    user = fake_decode_token(token)\n    return user\n\n\n@app.get(""/users/me"")\nasync def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):\n    return current_user\n\n```\n\n\n## 创建 `get_current_user` 依赖项\n\n创建 `get_current_user` 依赖项。\n\n还记得依赖项支持子依赖项吗？\n\n`get_current_user` 使用 `oauth2_scheme` 作为依赖项。\n\n与之前直接在路径操作中的做法相同，新的 `get_current_user` 依赖项从子依赖项 `oauth2_scheme` 中接收 `str` 类型的 `token`：\n\n\n> *[Ref: Code file `tutorial002_an_py39.py` is already included above]*\n\n\n## 获取用户\n\n`get_current_user` 使用创建的（伪）工具函数，该函数接收 `str` 类型的令牌，并返回 Pydantic 的 `User` 模型：\n\n\n> *[Ref: Code file `tutorial002_an_py39.py` is already included above]*\n\n\n## 注入当前用户\n\n在*路径操作* 的 `Depends` 中使用 `get_current_user`：\n\n\n> *[Ref: Code file `tutorial002_an_py39.py` is already included above]*\n\n\n注意，此处把 `current_user` 的类型声明为 Pydantic 的 `User` 模型。\n\n这有助于在函数内部使用代码补全和类型检查。\n\n/// tip | 提示\n\n还记得请求体也是使用 Pydantic 模型声明的吧。\n\n放心，因为使用了 `Depends`，FastAPI 不会搞混。\n\n///\n\n/// check | 检查\n\n依赖系统的这种设计方式可以支持不同的依赖项返回同一个 `User` 模型。\n\n而不是局限于只能有一个返回该类型数据的依赖项。\n\n///\n\n## 其它模型\n\n接下来，直接在*路径操作函数*中获取当前用户，并用 `Depends` 在依赖注入系统中处理安全机制。\n\n开发者可以使用任何模型或数据满足安全需求（本例中是 Pydantic 的 `User` 模型）。\n\n而且，不局限于只能使用特定的数据模型、类或类型。\n\n不想在模型中使用 `username`，而是使用 `id` 和 `email`？当然可以。这些工具也支持。\n\n只想使用字符串？或字典？甚至是数据库类模型的实例？工作方式都一样。\n\n实际上，就算登录应用的不是用户，而是只拥有访问令牌的机器人、程序或其它系统？工作方式也一样。\n\n尽管使用应用所需的任何模型、类、数据库。FastAPI 通过依赖注入系统都能帮您搞定。\n\n## 代码大小\n\n这个示例看起来有些冗长。毕竟这个文件同时包含了安全、数据模型的工具函数，以及路径操作等代码。\n\n但，关键是：\n\n安全和依赖注入的代码只需要写一次。\n\n就算写得再复杂，也只是在一个位置写一次就够了。所以，要多复杂就可以写多复杂。\n\n但是，就算有数千个端点（*路径操作*），它们都可以使用同一个安全系统。\n\n而且，所有端点（或它们的任何部件）都可以利用这些依赖项或任何其它依赖项。\n\n所有*路径操作*只需 3 行代码就可以了：\n\n\n> *[Ref: Code file `tutorial002_an_py39.py` is already included above]*\n\n\n## 小结\n\n现在，我们可以直接在*路径操作函数*中获取当前用户。\n\n至此，安全的内容已经讲了一半。\n\n只要再为用户或客户端的*路径操作*添加真正发送 `username` 和 `password` 的功能就可以了。\n\n下一章见。', '# 依赖项\n\nFastAPI 提供了简单易用，但功能强大的<abbr title=""也称为组件、资源、提供者、服务、可注入项"">依赖注入</abbr>系统。\n\n这个依赖系统设计的简单易用，可以让开发人员轻松地把组件集成至 FastAPI。\n\n## 什么是「依赖注入」\n\n编程中的「依赖注入」是声明代码（本文中为*路径操作函数* ）运行所需的，或要使用的「依赖」的一种方式。\n\n然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n\n依赖注入常用于以下场景：\n\n* 共享业务逻辑（复用相同的代码逻辑）\n* 共享数据库连接\n* 实现安全、验证、角色权限\n* 等……\n\n上述场景均可以使用依赖注入，将代码重复最小化。\n\n## 第一步\n\n接下来，我们学习一个非常简单的例子，尽管它过于简单，不是很实用。\n\n但通过这个例子，您可以初步了解「依赖注入」的工作机制。\n\n### 创建依赖项\n\n首先，要关注的是依赖项。\n\n依赖项就是一个函数，且可以使用与*路径操作函数*相同的参数：\n\n\n```py\nfrom typing import Annotated, Union\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(\n    q: Union[str, None] = None, skip: int = 0, limit: int = 100\n):\n    return {""q"": q, ""skip"": skip, ""limit"": limit}\n\n\n@app.get(""/items/"")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n\n@app.get(""/users/"")\nasync def read_users(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n```\n\n\n大功告成。\n\n只用了2 行代码。\n\n依赖项函数的形式和结构与*路径操作函数*一样。\n\n因此，可以把依赖项当作没有「装饰器」（即，没有 `@app.get(""/some-path"")` ）的路径操作函数。\n\n依赖项可以返回各种内容。\n\n本例中的依赖项预期接收如下参数：\n\n* 类型为 `str` 的可选查询参数 `q`\n* 类型为 `int` 的可选查询参数 `skip`，默认值是 `0`\n* 类型为 `int` 的可选查询参数 `limit`，默认值是 `100`\n\n然后，依赖项函数返回包含这些值的 `dict`。\n\n### 导入 `Depends`\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n### 声明依赖项\n\n与在*路径操作函数*参数中使用 `Body`、`Query` 的方式相同，声明依赖项需要使用 `Depends` 和一个新的参数：\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n虽然，在路径操作函数的参数中使用 `Depends` 的方式与 `Body`、`Query` 相同，但 `Depends` 的工作方式略有不同。\n\n这里只能传给 Depends 一个参数。\n\n且该参数必须是可调用对象，比如函数。\n\n该函数接收的参数和*路径操作函数*的参数一样。\n\n/// tip | 提示\n\n下一章介绍，除了函数还有哪些「对象」可以用作依赖项。\n\n///\n\n接收到新的请求时，FastAPI 执行如下操作：\n\n* 用正确的参数调用依赖项函数（「可依赖项」）\n* 获取函数返回的结果\n* 把函数返回的结果赋值给*路径操作函数*的参数\n\n```mermaid\ngraph TB\n\ncommon_parameters([""common_parameters""])\nread_items[""/items/""]\nread_users[""/users/""]\n\ncommon_parameters --&gt; read_items\ncommon_parameters --&gt; read_users\n```\n\n这样，只编写一次代码，FastAPI 就可以为多个*路径操作*共享这段代码 。\n\n/// check | 检查\n\n注意，无需创建专门的类，并将之传递给 FastAPI 以进行「注册」或执行类似的操作。\n\n只要把它传递给 `Depends`，FastAPI 就知道该如何执行后续操作。\n\n///\n\n## 要不要使用 `async`？\n\nFastAPI 调用依赖项的方式与*路径操作函数*一样，因此，定义依赖项函数，也要应用与路径操作函数相同的规则。\n\n即，既可以使用异步的 `async def`，也可以使用普通的 `def` 定义依赖项。\n\n在普通的 `def` *路径操作函数*中，可以声明异步的 `async def` 依赖项；也可以在异步的 `async def` *路径操作函数*中声明普通的 `def` 依赖项。\n\n上述这些操作都是可行的，FastAPI 知道该怎么处理。\n\n/// note | 笔记\n\n如里不了解异步，请参阅[异步：*“着急了？”*](../../async.md){.internal-link target=_blank} 一章中 `async` 和 `await` 的内容。\n\n///\n\n## 与 OpenAPI 集成\n\n依赖项及子依赖项的所有请求声明、验证和需求都可以集成至同一个 OpenAPI 概图。\n\n所以，交互文档里也会显示依赖项的所有信息：\n\n## 简单用法\n\n观察一下就会发现，只要*路径* 和*操作*匹配，就可以使用声明的路径操作函数。然后，FastAPI 会用正确的参数调用函数，并提取请求中的数据。\n\n实际上，所有（或大多数）网络框架的工作方式都是这样的。\n\n开发人员永远都不需要直接调用这些函数，这些函数是由框架（在此为 FastAPI ）调用的。\n\n通过依赖注入系统，只要告诉 FastAPI *路径操作函数* 还要「依赖」其他在*路径操作函数*之前执行的内容，FastAPI 就会执行函数代码，并「注入」函数返回的结果。\n\n其他与「依赖注入」概念相同的术语为：\n\n* 资源（Resource）\n* 提供方（Provider）\n* 服务（Service）\n* 可注入（Injectable）\n* 组件（Component）\n\n## FastAPI 插件\n\n依赖注入系统支持构建集成和「插件」。但实际上，FastAPI 根本不需要创建「插件」，因为使用依赖项可以声明不限数量的、可用于*路径操作函数*的集成与交互。\n\n创建依赖项非常简单、直观，并且还支持导入 Python 包。毫不夸张地说，只要几行代码就可以把需要的 Python 包与 API 函数集成在一起。\n\n下一章将详细介绍在关系型数据库、NoSQL 数据库、安全等方面使用依赖项的例子。\n\n## FastAPI 兼容性\n\n依赖注入系统如此简洁的特性，让 FastAPI 可以与下列系统兼容：\n\n* 关系型数据库\n* NoSQL 数据库\n* 外部支持库\n* 外部 API\n* 认证和鉴权系统\n* API 使用监控系统\n* 响应数据注入系统\n* 等等……\n\n## 简单而强大\n\n虽然，层级式依赖注入系统的定义与使用十分简单，但它却非常强大。\n\n比如，可以定义依赖其他依赖项的依赖项。\n\n最后，依赖项层级树构建后，依赖注入系统会处理所有依赖项及其子依赖项，并为每一步操作提供（注入）结果。\n\n比如，下面有 4 个 API 路径操作（*端点*）：\n\n* `/items/public/`\n* `/items/private/`\n* `/users/{user_id}/activate`\n* `/items/pro/`\n\n开发人员可以使用依赖项及其子依赖项为这些路径操作添加不同的权限：\n\n```mermaid\ngraph TB\n\ncurrent_user([""current_user""])\nactive_user([""active_user""])\nadmin_user([""admin_user""])\npaying_user([""paying_user""])\n\npublic[""/items/public/""]\nprivate[""/items/private/""]\nactivate_user[""/users/{user_id}/activate""]\npro_items[""/items/pro/""]\n\ncurrent_user --&gt; active_user\nactive_user --&gt; admin_user\nactive_user --&gt; paying_user\n\ncurrent_user --&gt; public\nactive_user --&gt; private\nadmin_user --&gt; activate_user\npaying_user --&gt; pro_items\n```\n\n## 与 OpenAPI 集成\n\n在声明需求时，所有这些依赖项还会把参数、验证等功能添加至路径操作。\n\nFastAPI 负责把上述内容全部添加到 OpenAPI 概图，并显示在交互文档中。', '# 更多模型\n\n书接上文，多个关联模型这种情况很常见。\n\n特别是用户模型，因为：\n\n* 输入模型应该含密码\n* 输出模型不应含密码\n* 数据库模型需要加密的密码\n\n/// danger | 危险\n\n千万不要存储用户的明文密码。始终存储可以进行验证的安全哈希值。\n\n如果不了解这方面的知识，请参阅[安全性中的章节](security/simple-oauth2.md#password-hashing){.internal-link target=_blank}，了解什么是密码哈希。\n\n///\n\n## 多个模型\n\n下面的代码展示了不同模型处理密码字段的方式，及使用位置的大致思路：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: EmailStr\n    full_name: str | None = None\n\n\nclass UserOut(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: str | None = None\n\n\nclass UserInDB(BaseModel):\n    username: str\n    hashed_password: str\n    email: EmailStr\n    full_name: str | None = None\n\n\ndef fake_password_hasher(raw_password: str):\n    return ""supersecret"" + raw_password\n\n\ndef fake_save_user(user_in: UserIn):\n    hashed_password = fake_password_hasher(user_in.password)\n    user_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password)\n    print(""User saved! ..not really"")\n    return user_in_db\n\n\n@app.post(""/user/"", response_model=UserOut)\nasync def create_user(user_in: UserIn):\n    user_saved = fake_save_user(user_in)\n    return user_saved\n\n```\n\n\n### `user_in.dict()` 简介\n\n#### Pydantic 的 `.dict()`\n\n`user_in` 是类 `UserIn` 的 Pydantic 模型。\n\nPydantic 模型支持 `.dict()` 方法，能返回包含模型数据的字典。\n\n因此，如果使用如下方式创建 Pydantic 对象 `user_in`：\n\n```Python\nuser_in = UserIn(username=""john"", password=""secret"", email=""john.doe@example.com"")\n```\n\n就能以如下方式调用：\n\n```Python\nuser_dict = user_in.dict()\n```\n\n现在，变量 `user_dict`中的就是包含数据的字典（变量 `user_dict` 是字典，不是 Pydantic 模型对象）。\n\n以如下方式调用：\n\n```Python\nprint(user_dict)\n```\n\n输出的就是 Python 字典：\n\n```Python\n{\n    \'username\': \'john\',\n    \'password\': \'secret\',\n    \'email\': \'john.doe@example.com\',\n    \'full_name\': None,\n}\n```\n\n#### 解包 `dict`\n\n把字典 `user_dict` 以 `user_dict` 形式传递给函数（或类），Python 会执行解包操作。它会把 `user_dict` 的键和值作为关键字参数直接传递。\n\n因此，接着上面的 `user_dict` 继续编写如下代码：\n\n```Python\nUserInDB(user_dict)\n```\n\n就会生成如下结果：\n\n```Python\nUserInDB(\n    username=""john"",\n    password=""secret"",\n    email=""john.doe@example.com"",\n    full_name=None,\n)\n```\n\n或更精准，直接把可能会用到的内容与 `user_dict` 一起使用：\n\n```Python\nUserInDB(\n    username = user_dict[""username""],\n    password = user_dict[""password""],\n    email = user_dict[""email""],\n    full_name = user_dict[""full_name""],\n)\n```\n\n#### 用其它模型中的内容生成 Pydantic 模型\n\n上例中 ，从 `user_in.dict()` 中得到了 `user_dict`，下面的代码：\n\n```Python\nuser_dict = user_in.dict()\nUserInDB(user_dict)\n```\n\n等效于：\n\n```Python\nUserInDB(user_in.dict())\n```\n\n……因为 `user_in.dict()` 是字典，在传递给 `UserInDB` 时，把 `` 加在  `user_in.dict()` 前，可以让 Python 进行解包。\n\n这样，就可以用其它 Pydantic 模型中的数据生成 Pydantic 模型。\n\n#### 解包 `dict` 和更多关键字\n\n接下来，继续添加关键字参数 `hashed_password=hashed_password`，例如：\n\n```Python\nUserInDB(user_in.dict(), hashed_password=hashed_password)\n```\n\n……输出结果如下：\n\n```Python\nUserInDB(\n    username = user_dict[""username""],\n    password = user_dict[""password""],\n    email = user_dict[""email""],\n    full_name = user_dict[""full_name""],\n    hashed_password = hashed_password,\n)\n```\n\n/// warning | 警告\n\n辅助的附加函数只是为了演示可能的数据流，但它们显然不能提供任何真正的安全机制。\n\n///\n\n## 减少重复\n\nFastAPI** 的核心思想就是减少代码重复。\n\n代码重复会导致 bug、安全问题、代码失步等问题（更新了某个位置的代码，但没有同步更新其它位置的代码）。\n\n上面的这些模型共享了大量数据，拥有重复的属性名和类型。\n\nFastAPI 可以做得更好。\n\n声明 `UserBase` 模型作为其它模型的基类。然后，用该类衍生出继承其属性（类型声明、验证等）的子类。\n\n所有数据转换、校验、文档等功能仍将正常运行。\n\n这样，就可以仅声明模型之间的差异部分（具有明文的 `password`、具有 `hashed_password` 以及不包括密码）。\n\n通过这种方式，可以只声明模型之间的区别（分别包含明文密码、哈希密码，以及无密码的模型）。\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserBase(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: str | None = None\n\n\nclass UserIn(UserBase):\n    password: str\n\n\nclass UserOut(UserBase):\n    pass\n\n\nclass UserInDB(UserBase):\n    hashed_password: str\n\n\ndef fake_password_hasher(raw_password: str):\n    return ""supersecret"" + raw_password\n\n\ndef fake_save_user(user_in: UserIn):\n    hashed_password = fake_password_hasher(user_in.password)\n    user_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password)\n    print(""User saved! ..not really"")\n    return user_in_db\n\n\n@app.post(""/user/"", response_model=UserOut)\nasync def create_user(user_in: UserIn):\n    user_saved = fake_save_user(user_in)\n    return user_saved\n\n```\n\n\n## `Union` 或者 `anyOf`\n\n响应可以声明为两种类型的 `Union` 类型，即该响应可以是两种类型中的任意类型。\n\n在 OpenAPI 中可以使用 `anyOf` 定义。\n\n为此，请使用 Python 标准类型提示 `typing.Union`：\n\n/// note | 笔记\n\n定义 `Union` 类型时，要把详细的类型写在前面，然后是不太详细的类型。下例中，更详细的 `PlaneItem` 位于 `Union[PlaneItem，CarItem]` 中的 `CarItem` 之前。\n\n///\n\n\n```py\nfrom typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass BaseItem(BaseModel):\n    description: str\n    type: str\n\n\nclass CarItem(BaseItem):\n    type: str = ""car""\n\n\nclass PlaneItem(BaseItem):\n    type: str = ""plane""\n    size: int\n\n\nitems = {\n    ""item1"": {""description"": ""All my friends drive a low rider"", ""type"": ""car""},\n    ""item2"": {\n        ""description"": ""Music is my aeroplane, it\'s my aeroplane"",\n        ""type"": ""plane"",\n        ""size"": 5,\n    },\n}\n\n\n@app.get(""/items/{item_id}"", response_model=Union[PlaneItem, CarItem])\nasync def read_item(item_id: str):\n    return items[item_id]\n\n```\n\n\n## 模型列表\n\n使用同样的方式也可以声明由对象列表构成的响应。\n\n为此，请使用标准的 Python `typing.List`：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str\n\n\nitems = [\n    {""name"": ""Foo"", ""description"": ""There comes my hero""},\n    {""name"": ""Red"", ""description"": ""It\'s my aeroplane""},\n]\n\n\n@app.get(""/items/"", response_model=list[Item])\nasync def read_items():\n    return items\n\n```\n\n\n## 任意 `dict` 构成的响应\n\n任意的 `dict` 都能用于声明响应，只要声明键和值的类型，无需使用 Pydantic 模型。\n\n事先不知道可用的字段 / 属性名时（Pydantic 模型必须知道字段是什么），这种方式特别有用。\n\n此时，可以使用 `typing.Dict`：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(""/keyword-weights/"", response_model=dict[str, float])\nasync def read_keyword_weights():\n    return {""foo"": 2.3, ""bar"": 3.4}\n\n```\n\n\n## 小结\n\n针对不同场景，可以随意使用不同的 Pydantic 模型继承定义的基类。\n\n实体必须具有不同的状态时，不必为不同状态的实体单独定义数据模型。例如，用户实体就有包含 `password`、包含 `password_hash` 以及不含密码等多种状态。', '# 生命周期事件\n\n你可以定义在应用启动前执行的逻辑（代码）。这意味着在应用开始接收请求之前，这些代码只会被执行一次。\n\n同样地，你可以定义在应用关闭时应执行的逻辑。在这种情况下，这段代码将在处理可能的多次请求后执行一次。\n\n因为这段代码在应用开始接收请求之前执行，也会在处理可能的若干请求之后执行，它覆盖了整个应用程序的生命周期（""生命周期""这个词很重要😉）。\n\n这对于设置你需要在整个应用中使用的资源非常有用，这些资源在请求之间共享，你可能需要在之后进行释放。例如，数据库连接池，或加载一个共享的机器学习模型。\n\n## 用例\n\n让我们从一个示例用例开始，看看如何解决它。\n\n假设你有几个机器学习的模型，你想要用它们来处理请求。\n\n相同的模型在请求之间是共享的，因此并非每个请求或每个用户各自拥有一个模型。\n\n假设加载模型可能需要相当长的时间，因为它必须从磁盘读取大量数据。因此你不希望每个请求都加载它。\n\n你可以在模块/文件的顶部加载它，但这也意味着即使你只是在运行一个简单的自动化测试，它也会加载模型，这样测试将变慢，因为它必须在能够独立运行代码的其他部分之前等待模型加载完成。\n\n这就是我们要解决的问题——在处理请求前加载模型，但只是在应用开始接收请求前，而不是代码执行时。\n\n## 生命周期 lifespan\n\n你可以使用`FastAPI()`应用的`lifespan`参数和一个上下文管理器（稍后我将为你展示）来定义启动和关闭的逻辑。\n\n让我们从一个例子开始，然后详细介绍。\n\n我们使用`yield`创建了一个异步函数`lifespan()`像这样：\n\n```Python hl_lines=""16  19""\n{!../../docs_src/events/tutorial003.py!}\n```\n\n在这里，我们在 `yield` 之前将（虚拟的）模型函数放入机器学习模型的字典中，以此模拟加载模型的耗时启动操作。这段代码将在应用程序开始处理请求之前执行，即启动期间。\n\n然后，在 `yield` 之后，我们卸载模型。这段代码将会在应用程序完成处理请求后执行，即在关闭之前。这可以释放诸如内存或 GPU 之类的资源。\n\n/// tip | 提示\n\n关闭事件只会在你停止应用时触发。\n\n可能你需要启动一个新版本，或者你只是你厌倦了运行它。 🤷\n\n///\n\n## 生命周期函数\n\n首先要注意的是，我们定义了一个带有 `yield` 的异步函数。这与带有 `yield` 的依赖项非常相似。\n\n```Python hl_lines=""14-19""\n{!../../docs_src/events/tutorial003.py!}\n```\n\n这个函数在 `yield`之前的部分，会在应用启动前执行。\n\n剩下的部分在 `yield` 之后，会在应用完成后执行。\n\n## 异步上下文管理器\n\n如你所见，这个函数有一个装饰器 `@asynccontextmanager` 。\n\n它将函数转化为所谓的“异步上下文管理器”。\n\n```Python hl_lines=""1  13""\n{!../../docs_src/events/tutorial003.py!}\n```\n\n在 Python 中，  上下文管理器是一个你可以在 `with` 语句中使用的东西，例如，`open()` 可以作为上下文管理器使用。\n\n```Python\nwith open(""file.txt"") as file:\n    file.read()\n```\n\nPython 的最近几个版本也有了一个异步上下文管理器，你可以通过 `async with` 来使用：\n\n```Python\nasync with lifespan(app):\n    await do_stuff()\n```\n\n你可以像上面一样创建了一个上下文管理器或者异步上下文管理器，它的作用是在进入 `with` 块时，执行 `yield` 之前的代码，并且在离开 `with` 块时，执行 `yield` 后面的代码。\n\n但在我们上面的例子里，我们并不是直接使用，而是传递给 FastAPI 来供其使用。\n\n`FastAPI()` 的 `lifespan` 参数接受一个异步上下文管理器，所以我们可以把我们新定义的上下文管理器 `lifespan` 传给它。\n\n```Python hl_lines=""22""\n{!../../docs_src/events/tutorial003.py!}\n```\n\n## 替代事件（弃用）\n\n/// warning | 警告\n\n配置启动和关闭事件的推荐方法是使用 `FastAPI()` 应用的 `lifespan` 参数，如前所示。如果你提供了一个 `lifespan` 参数，启动（`startup`）和关闭（`shutdown`）事件处理器将不再生效。要么使用 `lifespan`，要么配置所有事件，两者不能共用。\n\n你可以跳过这一部分。\n\n///\n\n有一种替代方法可以定义在启动和关闭期间执行的逻辑。\n\nFastAPI 支持定义在应用启动前，或应用关闭时执行的事件处理器（函数）。\n\n事件函数既可以声明为异步函数（`async def`），也可以声明为普通函数（`def`）。\n\n### `startup` 事件\n\n使用 `startup` 事件声明 `app` 启动前运行的函数：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nitems = {}\n\n\n@app.on_event(""startup"")\nasync def startup_event():\n    items[""foo""] = {""name"": ""Fighters""}\n    items[""bar""] = {""name"": ""Tenders""}\n\n\n@app.get(""/items/{item_id}"")\nasync def read_items(item_id: str):\n    return items[item_id]\n\n```\n\n\n本例中，`startup` 事件处理器函数为项目数据库（只是字典）提供了一些初始值。\n\nFastAPI 支持多个事件处理器函数。\n\n只有所有 `startup` 事件处理器运行完毕，FastAPI 应用才开始接收请求。\n\n### `shutdown` 事件\n\n使用 `shutdown` 事件声明 `app` 关闭时运行的函数：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.on_event(""shutdown"")\ndef shutdown_event():\n    with open(""log.txt"", mode=""a"") as log:\n        log.write(""Application shutdown"")\n\n\n@app.get(""/items/"")\nasync def read_items():\n    return [{""name"": ""Foo""}]\n\n```\n\n\n此处，`shutdown` 事件处理器函数在 `log.txt` 中写入一行文本 `Application shutdown`。\n\n/// info | 说明\n\n`open()` 函数中，`mode=""a""` 指的是追加。因此这行文本会添加在文件已有内容之后，不会覆盖之前的内容。\n\n///\n\n/// tip | 提示\n\n注意，本例使用 Python `open()` 标准函数与文件交互。\n\n这个函数执行 I/O（输入/输出）操作，需要等待内容写进磁盘。\n\n但 `open()` 函数不支持使用 `async` 与 `await`。\n\n因此，声明事件处理函数要使用 `def`，不能使用 `asnyc def`。\n\n///\n\n### `startup` 和 `shutdown` 一起使用\n\n启动和关闭的逻辑很可能是连接在一起的，你可能希望启动某个东西然后结束它，获取一个资源然后释放它等等。\n\n在不共享逻辑或变量的不同函数中处理这些逻辑比较困难，因为你需要在全局变量中存储值或使用类似的方式。\n\n因此，推荐使用 `lifespan` 。\n\n## 技术细节\n\n只是为好奇者提供的技术细节。🤓\n\n在底层，这部分是生命周期协议的一部分，参见 ASGI 技术规范，定义了称为启动（`startup`）和关闭（`shutdown`）的事件。\n\n/// info | 说明\n\n有关事件处理器的详情，请参阅 Starlette 官档 - 事件。\n\n包括如何处理生命周期状态，这可以用于程序的其他部分。\n\n///\n\n## 子应用\n\n🚨  FastAPI 只会触发主应用中的生命周期事件，不包括[子应用 - 挂载](sub-applications.md){.internal-link target=_blank}中的。']","根据上下文，您可以通过FastAPI的**依赖注入系统**复用代码（如检查用户Token），无需装饰器或每个函数重复调用。以下是解决方案：

1. **创建依赖项函数**（如`get_current_user`）处理Token验证逻辑：
   ```python
   async def get_current_user(token: str = Depends(oauth2_scheme)):
       user = fake_decode_token(token)  # 验证逻辑
       return user
   ```

2. **在路径操作中声明依赖**：
   ```python
   @app.get(""/users/me"")
   async def read_users_me(current_user: User = Depends(get_current_user)):
       return current_user
   ```

这样，FastAPI会自动注入依赖项结果，实现代码复用且保持端点简洁。",你应该使用 FastAPI 的依赖注入系统（Dependency Injection）。你可以定义一个普通的函数（例如 `get_current_user`）来包含 Token 检查逻辑，然后在需要的路由函数参数中使用 `Depends(get_current_user)`。这比装饰器更灵活，因为依赖项可以像普通函数一样接收参数，并且可以被 FastAPI 自动处理和测试，同时也支持依赖项的嵌套。,0.99999999995,1.0,0.6879715030267903
如何在 FastAPI 的 settings.py 里配置内置的 ORM 连接数据库？,"['# SQL（关系型）数据库\n\nFastAPI 并不要求您使用 SQL（关系型）数据库。您可以使用任何想用的数据库。\n\n这里，我们来看一个使用 SQLModel 的示例。\n\nSQLModel 是基于 SQLAlchemy 和 Pydantic 构建的。它由 FastAPI 的同一作者制作，旨在完美匹配需要使用 SQL 数据库的 FastAPI 应用程序。\n\n/// tip\n\n您可以使用任何其他您想要的 SQL 或 NoSQL 数据库（在某些情况下称为 <abbr title=""对象关系映射器（Object Relational Mapper，ORM），一个术语，用来指代一种库，其中某些类对应于 SQL 数据表，这些类的实例则对应于表中的行。"">“ORM”</abbr>），FastAPI 不会强迫您使用任何东西。😎\n\n///\n\n由于 SQLModel 基于 SQLAlchemy，因此您可以轻松使用任何由 SQLAlchemy 支持的数据库（这也让它们被 SQLModel 支持），例如：\n\n* PostgreSQL\n* MySQL\n* SQLite\n* Oracle\n* Microsoft SQL Server 等.\n\n在这个例子中，我们将使用 SQLite，因为它使用单个文件，并且 Python 对其有集成支持。因此，您可以直接复制这个例子并运行。\n\n之后，对于您的生产应用程序，您可能会想要使用像 PostgreSQL 这样的数据库服务器。\n\n/// tip\n\n有一个使用 FastAPI 和 PostgreSQL 的官方的项目生成器，其中包括了前端和更多工具： https://github.com/fastapi/full-stack-fastapi-template\n\n///\n\n这是一个非常简单和简短的教程。如果您想了解一般的数据库、SQL 或更高级的功能，请查看 SQLModel 文档。\n\n## 安装 `SQLModel`\n\n首先，确保您创建并激活了[虚拟环境](../virtual-environments.md){.internal-link target=_blank}，然后安装了 `sqlmodel` :\n\n```console\n$ pip install sqlmodel\n&gt; 100%\n```\n\n## 创建含有单一模型的应用程序\n\n我们首先创建应用程序的最简单的第一个版本，只有一个 SQLModel 模型。\n\n稍后我们将通过下面的多个模型提高其安全性和多功能性。🤓\n\n### 创建模型\n\n导入 `SQLModel` 并创建一个数据库模型：\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException, Query\nfrom sqlmodel import Field, Session, SQLModel, create_engine, select\n\n\nclass Hero(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    name: str = Field(index=True)\n    age: int | None = Field(default=None, index=True)\n    secret_name: str\n\n\nsqlite_file_name = ""database.db""\nsqlite_url = f""sqlite:///{sqlite_file_name}""\n\nconnect_args = {""check_same_thread"": False}\nengine = create_engine(sqlite_url, connect_args=connect_args)\n\n\ndef create_db_and_tables():\n    SQLModel.metadata.create_all(engine)\n\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n\nSessionDep = Annotated[Session, Depends(get_session)]\n\napp = FastAPI()\n\n\n@app.on_event(""startup"")\ndef on_startup():\n    create_db_and_tables()\n\n\n@app.post(""/heroes/"")\ndef create_hero(hero: Hero, session: SessionDep) -> Hero:\n    session.add(hero)\n    session.commit()\n    session.refresh(hero)\n    return hero\n\n\n@app.get(""/heroes/"")\ndef read_heroes(\n    session: SessionDep,\n    offset: int = 0,\n    limit: Annotated[int, Query(le=100)] = 100,\n) -> list[Hero]:\n    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()\n    return heroes\n\n\n@app.get(""/heroes/{hero_id}"")\ndef read_hero(hero_id: int, session: SessionDep) -> Hero:\n    hero = session.get(Hero, hero_id)\n    if not hero:\n        raise HTTPException(status_code=404, detail=""Hero not found"")\n    return hero\n\n\n@app.delete(""/heroes/{hero_id}"")\ndef delete_hero(hero_id: int, session: SessionDep):\n    hero = session.get(Hero, hero_id)\n    if not hero:\n        raise HTTPException(status_code=404, detail=""Hero not found"")\n    session.delete(hero)\n    session.commit()\n    return {""ok"": True}\n\n```\n\n\n`Hero` 类与 Pydantic 模型非常相似（实际上，从底层来看，它确实*就是一个 Pydantic 模型*）。\n\n有一些区别：\n\n* `table=True` 会告诉 SQLModel 这是一个*表模型*，它应该表示 SQL 数据库中的一个*表*，而不仅仅是一个*数据模型*（就像其他常规的 Pydantic 类一样）。\n\n* `Field(primary_key=True)` 会告诉 SQLModel `id` 是 SQL 数据库中的主键（您可以在 SQLModel 文档中了解更多关于 SQL 主键的信息）。\n\n    把类型设置为 `int | None` ，SQLModel 就能知道该列在 SQL 数据库中应该是 `INTEGER` 类型，并且应该是 `NULLABLE` 。\n\n* `Field(index=True)` 会告诉 SQLModel 应该为此列创建一个 SQL 索引，这样在读取按此列过滤的数据时，程序能在数据库中进行更快的查找。\n\n    SQLModel 会知道声明为 `str` 的内容将是类型为 `TEXT` （或 `VARCHAR` ，具体取决于数据库）的 SQL 列。\n\n### 创建引擎（Engine）\n\nSQLModel 的引擎 `engine`（实际上它是一个 SQLAlchemy `engine` ）是用来与数据库保持连接的。\n\n您只需构建一个 `engine`，来让您的所有代码连接到同一个数据库。\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n使用 `check_same_thread=False` 可以让 FastAPI 在不同线程中使用同一个 SQLite 数据库。这很有必要，因为单个请求可能会使用多个线程（例如在依赖项中）。\n\n不用担心，我们会按照代码结构确保**每个请求使用一个单独的 SQLModel *会话***，这实际上就是 `check_same_thread` 想要实现的。\n\n### 创建表\n\n然后，我们来添加一个函数，使用 `SQLModel.metadata.create_all(engine)` 为所有*表模型*创建表。\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n### 创建会话（Session）依赖项\n\n`Session` 会存储内存中的对象并跟踪数据中所需更改的内容，然后它使用 `engine` 与数据库进行通信。\n\n我们会使用 `yield` 创建一个 FastAPI 依赖项，为每个请求提供一个新的 `Session` 。这确保我们每个请求使用一个单独的会话。🤓\n\n然后我们创建一个 `Annotated` 的依赖项 `SessionDep` 来简化其他也会用到此依赖的代码。\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n### 在启动时创建数据库表\n\n我们会在应用程序启动时创建数据库表。\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n此处，在应用程序启动事件中，我们创建了表。\n\n而对于生产环境，您可能会用一个能够在启动应用程序之前运行的迁移脚本。🤓\n\n/// tip\n\nSQLModel 将会拥有封装 Alembic 的迁移工具，但目前您可以直接使用 Alembic。\n\n///\n\n### 创建 Hero 类\n\n因为每个 SQLModel 模型同时也是一个 Pydantic 模型，所以您可以在与 Pydantic 模型相同的类型注释中使用它。\n\n例如，如果您声明一个类型为 `Hero` 的参数，它将从 JSON 主体中读取数据。\n\n同样，您可以将其声明为函数的返回类型，然后数据的结构就会显示在自动生成的 API 文档界面中。\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n这里，我们使用 `SessionDep` 依赖项（一个 `Session` ）将新的 `Hero` 添加到 `Session` 实例中，提交更改到数据库，刷新 hero 中的数据，并返回它。\n\n### 读取 Hero 类\n\n我们可以使用 `select()` 从数据库中读取 `Hero` 类，并利用 `limit` 和 `offset` 来对结果进行分页。\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n### 读取单个 Hero\n\n我们可以读取单个 `Hero` 。\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n### 删除单个 Hero\n\n我们也可以删除单个 `Hero` 。\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n### 运行应用程序\n\n您可以运行这个应用程序：\n\n```console\n$ fastapi dev main.py\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n然后在 `/docs` UI 中，您能够看到 FastAPI 会用这些模型来记录 API，并且还会用它们来序列化和验证数据。\n\n## 更新应用程序以支持多个模型\n\n现在让我们稍微重构一下这个应用，以提高安全性和多功能性。\n\n如果您查看之前的应用程序，您可以在 UI 界面中看到，到目前为止，由客户端决定要创建的 `Hero` 的 `id` 值。😱\n\n我们不应该允许这样做，因为他们可能会覆盖我们在数据库中已经分配的 `id` 。决定 `id` 的行为应该由后端或数据库来完成，而非客户端。\n\n此外，我们为 hero 创建了一个 `secret_name` ，但到目前为止，我们在各处都返回了它，这就不太秘密了……😅\n\n我们将通过添加一些额外的模型来解决这些问题，而 SQLModel 将在这里大放异彩。✨\n\n### 创建多个模型\n\n在 SQLModel 中，任何含有 `table=True` 属性的模型类都是一个表模型。\n\n任何不含有 `table=True` 属性的模型类都是数据模型，这些实际上只是 Pydantic 模型（附带一些小的额外功能）。🤓\n\n有了 SQLModel，我们就可以利用继承来在所有情况下避免重复所有字段。\n\n#### `HeroBase` - 基类\n\n我们从一个 `HeroBase` 模型开始，该模型具有所有模型共享的字段：\n\n* `name`\n* `age`\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException, Query\nfrom sqlmodel import Field, Session, SQLModel, create_engine, select\n\n\nclass HeroBase(SQLModel):\n    name: str = Field(index=True)\n    age: int | None = Field(default=None, index=True)\n\n\nclass Hero(HeroBase, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    secret_name: str\n\n\nclass HeroPublic(HeroBase):\n    id: int\n\n\nclass HeroCreate(HeroBase):\n    secret_name: str\n\n\nclass HeroUpdate(HeroBase):\n    name: str | None = None\n    age: int | None = None\n    secret_name: str | None = None\n\n\nsqlite_file_name = ""database.db""\nsqlite_url = f""sqlite:///{sqlite_file_name}""\n\nconnect_args = {""check_same_thread"": False}\nengine = create_engine(sqlite_url, connect_args=connect_args)\n\n\ndef create_db_and_tables():\n    SQLModel.metadata.create_all(engine)\n\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n\nSessionDep = Annotated[Session, Depends(get_session)]\napp = FastAPI()\n\n\n@app.on_event(""startup"")\ndef on_startup():\n    create_db_and_tables()\n\n\n@app.post(""/heroes/"", response_model=HeroPublic)\ndef create_hero(hero: HeroCreate, session: SessionDep):\n    db_hero = Hero.model_validate(hero)\n    session.add(db_hero)\n    session.commit()\n    session.refresh(db_hero)\n    return db_hero\n\n\n@app.get(""/heroes/"", response_model=list[HeroPublic])\ndef read_heroes(\n    session: SessionDep,\n    offset: int = 0,\n    limit: Annotated[int, Query(le=100)] = 100,\n):\n    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()\n    return heroes\n\n\n@app.get(""/heroes/{hero_id}"", response_model=HeroPublic)\ndef read_hero(hero_id: int, session: SessionDep):\n    hero = session.get(Hero, hero_id)\n    if not hero:\n        raise HTTPException(status_code=404, detail=""Hero not found"")\n    return hero\n\n\n@app.patch(""/heroes/{hero_id}"", response_model=HeroPublic)\ndef update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):\n    hero_db = session.get(Hero, hero_id)\n    if not hero_db:\n        raise HTTPException(status_code=404, detail=""Hero not found"")\n    hero_data = hero.model_dump(exclude_unset=True)\n    hero_db.sqlmodel_update(hero_data)\n    session.add(hero_db)\n    session.commit()\n    session.refresh(hero_db)\n    return hero_db\n\n\n@app.delete(""/heroes/{hero_id}"")\ndef delete_hero(hero_id: int, session: SessionDep):\n    hero = session.get(Hero, hero_id)\n    if not hero:\n        raise HTTPException(status_code=404, detail=""Hero not found"")\n    session.delete(hero)\n    session.commit()\n    return {""ok"": True}\n\n```\n\n\n#### `Hero` - *表模型*\n\n接下来，我们创建 `Hero` ，实际的*表模型*，并添加那些不总是在其他模型中的额外字段：\n\n* `id`\n* `secret_name`\n\n因为 `Hero` 继承自 HeroBase ，所以它也包含了在 `HeroBase` 中声明过的字段。因此 `Hero` 的所有字段为：\n\n* `id`\n* `name`\n* `age`\n* `secret_name`\n\n\n> *[Ref: Code file `tutorial002_an_py310.py` is already included above]*\n\n\n#### `HeroPublic` - 公共*数据模型*\n\n接下来，我们创建一个 `HeroPublic` 模型，这是将返回给 API 客户端的模型。\n\n它包含与 `HeroBase` 相同的字段，因此不会包括 `secret_name` 。\n\n终于，我们英雄（hero）的身份得到了保护！ 🥷\n\n它还重新声明了 `id: int` 。这样我们便与 API 客户端建立了一种约定，使他们始终可以期待 `id` 存在并且是一个整数 `int`（永远不会是 `None` ）。\n\n/// tip\n\n确保返回模型始终提供一个值并且始终是 `int` （而不是 `None` ）对 API 客户端非常有用，他们可以在这种确定性下编写更简单的代码。\n\n此外，自动生成的客户端将拥有更简洁的接口，这样与您的 API 交互的开发者就能更轻松地使用您的 API。😎\n\n///\n\n`HeroPublic` 中的所有字段都与 `HeroBase` 中的相同，其中 `id` 声明为 `int` （不是 `None` ）：\n\n* `id`\n* `name`\n* `age`\n* `secret_name`\n\n\n> *[Ref: Code file `tutorial002_an_py310.py` is already included above]*\n\n\n#### `HeroCreate` - 用于创建 hero 的*数据模型*\n\n现在我们创建一个 `HeroCreate` 模型，这是用于验证客户数据的模型。\n\n它不仅拥有与 `HeroBase` 相同的字段，还有 `secret_name` 。\n\n现在，当客户端创建一个新的 hero 时，他们会发送 `secret_name` ，它会被存储到数据库中，但这些 `secret_name` 不会通过 API 返回给客户端。\n\n/// tip\n\n这应当是密码被处理的方式：接收密码，但不要通过 API 返回它们。\n\n在存储密码之前，您还应该对密码的值进行哈希处理，绝不要以明文形式存储它们。\n\n///\n\n`HeroCreate` 的字段包括：\n\n* `name`\n* `age`\n* `secret_name`\n\n\n> *[Ref: Code file `tutorial002_an_py310.py` is already included above]*\n\n\n#### `HeroUpdate` - 用于更新 hero 的*数据模型*\n\n在之前的应用程序中，我们没有办法更新 hero，但现在有了多个模型，我们便能做到这一点了。🎉\n\n`HeroUpdate` *数据模型*有些特殊，它包含创建新 hero 所需的所有相同字段，但所有字段都是可选的（它们都有默认值）。这样，当您更新一个 hero 时，您可以只发送您想要更新的字段。\n\n因为所有字段实际上都发生了变化（类型现在包括 `None` ，并且它们现在有一个默认值 `None` ），我们需要重新声明它们。\n\n我们会重新声明所有字段，因此我们并不是真的需要从 `HeroBase` 继承。我会让它继承只是为了保持一致，但这并不必要。这更多是个人喜好的问题。🤷\n\n`HeroUpdate` 的字段包括:\n\n* `name`\n* `age`\n* `secret_name`\n\n\n> *[Ref: Code file `tutorial002_an_py310.py` is already included above]*\n\n\n### 使用 `HeroCreate` 创建并返回 `HeroPublic`\n\n既然我们有了多个模型，我们就可以对使用它们的应用程序部分进行更新。\n\n我们在请求中接收到一个 `HeroCreate` *数据模型*，然后从中创建一个 `Hero` *表模型*。\n\n这个新的*表模型* `Hero` 会包含客户端发送的字段，以及一个由数据库生成的 `id` 。\n\n然后我们将与函数中相同的*表模型* `Hero` 原样返回。但是由于我们使用 `HeroPublic` *数据模型*声明了 `response_model` ，FastAPI 会使用 `HeroPublic` 来验证和序列化数据。\n\n\n> *[Ref: Code file `tutorial002_an_py310.py` is already included above]*\n\n\n/// tip\n\n现在我们使用 `response_model=HeroPublic` 来代替返回类型注释 `-&gt; HeroPublic` ，因为我们返回的值实际上并不是 `HeroPublic` 类型。\n\n如果我们声明了 `-&gt; HeroPublic` ，您的编辑器和代码检查工具会抱怨（但也确实理所应当）您返回了一个 `Hero` 而不是一个 `HeroPublic` 。\n\n通过 `response_model` 的声明，我们让 FastAPI 按照它自己的方式处理，而不会干扰类型注解以及编辑器和其他工具提供的帮助。\n\n///\n\n### 用 `HeroPublic` 读取 Hero\n\n我们可以像之前一样读取 `Hero` 。同样，使用 `response_model=list[HeroPublic]` 确保正确地验证和序列化数据。\n\n\n> *[Ref: Code file `tutorial002_an_py310.py` is already included above]*\n\n\n### 用 `HeroPublic` 读取单个 Hero\n\n我们可以读取单个 `hero` 。\n\n\n> *[Ref: Code file `tutorial002_an_py310.py` is already included above]*\n\n\n### 用 `HeroUpdate` 更新单个 Hero\n\n我们可以更新单个 `hero` 。为此，我们会使用 HTTP 的 `PATCH` 操作。\n\n在代码中，我们会得到一个 `dict` ，其中包含客户端发送的所有数据，只有客户端发送的数据，并排除了任何一个仅仅作为默认值存在的值。为此，我们使用 `exclude_unset=True` 。这是最主要的技巧。🪄\n\n然后我们会使用 `hero_db.sqlmodel_update(hero_data)` ，来利用 `hero_data` 的数据更新 `hero_db` 。\n\n\n> *[Ref: Code file `tutorial002_an_py310.py` is already included above]*\n\n\n### （又一次）删除单个 Hero\n\n删除一个 hero 基本保持不变。\n\n我们不会满足在这一部分中重构一切的愿望。😅\n\n\n> *[Ref: Code file `tutorial002_an_py310.py` is already included above]*\n\n\n### （又一次）运行应用程序\n\n您可以再运行一次应用程序：\n\n```console\n$ fastapi dev main.py\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n您会在 `/docs` API UI 看到它现在已经更新，并且在进行创建 hero 等操作时，它不会再期望从客户端接收 `id` 数据。\n\n## 总结\n\n您可以使用 SQLModel 与 SQL 数据库进行交互，并通过*数据模型*和*表模型*简化代码。\n\n您可以在 SQLModel 的文档中学习到更多内容，其中有一个更详细的关于如何将 SQLModel 与 FastAPI 一起使用的教程。🚀', '# 设置和环境变量\n\n在许多情况下，您的应用程序可能需要一些外部设置或配置，例如密钥、数据库凭据、电子邮件服务的凭据等等。\n\n这些设置中的大多数是可变的（可以更改的），比如数据库的 URL。而且许多设置可能是敏感的，比如密钥。\n\n因此，通常会将它们提供为由应用程序读取的环境变量。\n\n## 环境变量\n\n/// tip\n\n如果您已经知道什么是""环境变量""以及如何使用它们，请随意跳到下面的下一节。\n\n///\n\n环境变量（也称为""env var""）是一种存在于 Python 代码之外、存在于操作系统中的变量，可以被您的 Python 代码（或其他程序）读取。\n\n您可以在 shell 中创建和使用环境变量，而无需使用 Python：\n\n//// tab | Linux、macOS、Windows Bash\n\n```console\n// 您可以创建一个名为 MY_NAME 的环境变量\n$ export MY_NAME=""Wade Wilson""\n\n// 然后您可以与其他程序一起使用它，例如\n$ echo ""Hello $MY_NAME""\n\nHello Wade Wilson\n```\n\n////\n\n//// tab | Windows PowerShell\n\n```console\n// 创建一个名为 MY_NAME 的环境变量\n$ $Env:MY_NAME = ""Wade Wilson""\n\n// 与其他程序一起使用它，例如\n$ echo ""Hello $Env:MY_NAME""\n\nHello Wade Wilson\n```\n\n////\n\n### 在 Python 中读取环境变量\n\n您还可以在 Python 之外的地方（例如终端中或使用任何其他方法）创建环境变量，然后在 Python 中读取它们。\n\n例如，您可以有一个名为 `main.py` 的文件，其中包含以下内容：\n\n```Python hl_lines=""3""\nimport os\n\nname = os.getenv(""MY_NAME"", ""World"")\nprint(f""Hello {name} from Python"")\n```\n\n/// tip\n\n`os.getenv()` 的第二个参数是要返回的默认值。\n\n如果没有提供默认值，默认为 `None`，此处我们提供了 `""World""` 作为要使用的默认值。\n\n///\n\n然后，您可以调用该 Python 程序：\n\n```console\n// 这里我们还没有设置环境变量\n$ python main.py\n\n// 因为我们没有设置环境变量，所以我们得到默认值\n\nHello World from Python\n\n// 但是如果我们先创建一个环境变量\n$ export MY_NAME=""Wade Wilson""\n\n// 然后再次调用程序\n$ python main.py\n\n// 现在它可以读取环境变量\n\nHello Wade Wilson from Python\n```\n\n由于环境变量可以在代码之外设置，但可以由代码读取，并且不需要与其他文件一起存储（提交到 `git`），因此通常将它们用于配置或设置。\n\n您还可以仅为特定程序调用创建一个环境变量，该环境变量仅对该程序可用，并且仅在其运行期间有效。\n\n要做到这一点，在程序本身之前的同一行创建它：\n\n```console\n// 在此程序调用行中创建一个名为 MY_NAME 的环境变量\n$ MY_NAME=""Wade Wilson"" python main.py\n\n// 现在它可以读取环境变量\n\nHello Wade Wilson from Python\n\n// 之后环境变量不再存在\n$ python main.py\n\nHello World from Python\n```\n\n/// tip\n\n您可以在 Twelve-Factor App: Config 中阅读更多相关信息。\n\n///\n\n### 类型和验证\n\n这些环境变量只能处理文本字符串，因为它们是外部于 Python 的，并且必须与其他程序和整个系统兼容（甚至与不同的操作系统，如 Linux、Windows、macOS）。\n\n这意味着从环境变量中在 Python 中读取的任何值都将是 `str` 类型，任何类型的转换或验证都必须在代码中完成。\n\n## Pydantic 的 `Settings`\n\n幸运的是，Pydantic 提供了一个很好的工具来处理来自环境变量的设置，即Pydantic: Settings management。\n\n### 创建 `Settings` 对象\n\n从 Pydantic 导入 `BaseSettings` 并创建一个子类，与 Pydantic 模型非常相似。\n\n与 Pydantic 模型一样，您使用类型注释声明类属性，还可以指定默认值。\n\n您可以使用与 Pydantic 模型相同的验证功能和工具，比如不同的数据类型和使用 `Field()` 进行附加验证。\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    app_name: str = ""Awesome API""\n    admin_email: str\n    items_per_user: int = 50\n\n\nsettings = Settings()\napp = FastAPI()\n\n\n@app.get(""/info"")\nasync def info():\n    return {\n        ""app_name"": settings.app_name,\n        ""admin_email"": settings.admin_email,\n        ""items_per_user"": settings.items_per_user,\n    }\n\n```\n\n\n/// tip\n\n如果您需要一个快速的复制粘贴示例，请不要使用此示例，而应使用下面的最后一个示例。\n\n///\n\n然后，当您创建该 `Settings` 类的实例（在此示例中是 `settings` 对象）时，Pydantic 将以不区分大小写的方式读取环境变量，因此，大写的变量 `APP_NAME` 仍将为属性 `app_name` 读取。\n\n然后，它将转换和验证数据。因此，当您使用该 `settings` 对象时，您将获得您声明的类型的数据（例如 `items_per_user` 将为 `int` 类型）。\n\n### 使用 `settings`\n\n然后，您可以在应用程序中使用新的 `settings` 对象：\n\n\n> *[Ref: Code file `tutorial001_py39.py` is already included above]*\n\n\n### 运行服务器\n\n接下来，您将运行服务器，并将配置作为环境变量传递。例如，您可以设置一个 `ADMIN_EMAIL` 和 `APP_NAME`，如下所示：\n\n```console\n$ ADMIN_EMAIL=""deadpool@example.com"" APP_NAME=""ChimichangApp""uvicorn main:app\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n/// tip\n\n要为单个命令设置多个环境变量，只需用空格分隔它们，并将它们全部放在命令之前。\n\n///\n\n然后，`admin_email` 设置将为 `""deadpool@example.com""`。\n\n`app_name` 将为 `""ChimichangApp""`。\n\n而 `items_per_user` 将保持其默认值为 `50`。\n\n## 在另一个模块中设置\n\n您可以将这些设置放在另一个模块文件中，就像您在[Bigger Applications - Multiple Files](../tutorial/bigger-applications.md){.internal-link target=_blank}中所见的那样。\n\n例如，您可以创建一个名为 `config.py` 的文件，其中包含以下内容：\n\n\n[Warning: Code file not found. Looked for: config_an_py39.py, config_py39.py, config.py at ./docs_src/settings/app01]\n\n\n然后在一个名为 `main.py` 的文件中使用它：\n\n\n[Warning: Code file not found. Looked for: main_an_py39.py, main_py39.py, main.py at ./docs_src/settings/app01]\n\n\n/// tip\n\n您还需要一个名为 `init.py` 的文件，就像您在[Bigger Applications - Multiple Files](../tutorial/bigger-applications.md){.internal-link target=_blank}中看到的那样。\n\n///\n\n## 在依赖项中使用设置\n\n在某些情况下，从依赖项中提供设置可能比在所有地方都使用全局对象 `settings` 更有用。\n\n这在测试期间尤其有用，因为很容易用自定义设置覆盖依赖项。\n\n### 配置文件\n\n根据前面的示例，您的 `config.py` 文件可能如下所示：\n\n\n[Warning: Code file not found. Looked for: config_an_py39.py, config_py39.py, config.py at ./docs_src/settings/app02]\n\n\n请注意，现在我们不创建默认实例 `settings = Settings()`。\n\n### 主应用程序文件\n\n现在我们创建一个依赖项，返回一个新的 `config.Settings()`。\n\n\n```py\nfrom functools import lru_cache\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\nfrom .config import Settings\n\napp = FastAPI()\n\n\n@lru_cache\ndef get_settings():\n    return Settings()\n\n\n@app.get(""/info"")\nasync def info(settings: Annotated[Settings, Depends(get_settings)]):\n    return {\n        ""app_name"": settings.app_name,\n        ""admin_email"": settings.admin_email,\n        ""items_per_user"": settings.items_per_user,\n    }\n\n```\n\n\n/// tip\n\n我们稍后会讨论 `@lru_cache`。\n\n目前，您可以将 `get_settings()` 视为普通函数。\n\n///\n\n然后，我们可以将其作为依赖项从“路径操作函数”中引入，并在需要时使用它。\n\n\n> *[Ref: Code file `main.py` is already included above]*\n\n\n### 设置和测试\n\n然后，在测试期间，通过创建 `get_settings` 的依赖项覆盖，很容易提供一个不同的设置对象：\n\n\n[Warning: Code file not found. Looked for: test_main_an_py39.py, test_main_py39.py, test_main.py at ./docs_src/settings/app02]\n\n\n在依赖项覆盖中，我们在创建新的 `Settings` 对象时为 `admin_email` 设置了一个新值，然后返回该新对象。\n\n然后，我们可以测试它是否被使用。\n\n## 从 `.env` 文件中读取设置\n\n如果您有许多可能经常更改的设置，可能在不同的环境中，将它们放在一个文件中，然后从该文件中读取它们，就像它们是环境变量一样，可能非常有用。\n\n这种做法相当常见，有一个名称，这些环境变量通常放在一个名为 `.env` 的文件中，该文件被称为“dotenv”。\n\n/// tip\n\n以点 (`.`) 开头的文件是 Unix-like 系统（如 Linux 和 macOS）中的隐藏文件。\n\n但是，dotenv 文件实际上不一定要具有确切的文件名。\n\n///\n\nPydantic 支持使用外部库从这些类型的文件中读取。您可以在Pydantic 设置: Dotenv (.env) 支持中阅读更多相关信息。\n\n/// tip\n\n要使其工作，您需要执行 `pip install python-dotenv`。\n\n///\n\n### `.env` 文件\n\n您可以使用以下内容创建一个名为 `.env` 的文件：\n\n```bash\nADMIN_EMAIL=""deadpool@example.com""\nAPP_NAME=""ChimichangApp""\n```\n\n### 从 `.env` 文件中读取设置\n\n然后，您可以使用以下方式更新您的 `config.py`：\n\n\n[Warning: Code file not found. Looked for: config_an_py39.py, config_py39.py, config.py at ./docs_src/settings/app03]\n\n\n在这里，我们在 Pydantic 的 `Settings` 类中创建了一个名为 `Config` 的类，并将 `env_file` 设置为我们想要使用的 dotenv 文件的文件名。\n\n/// tip\n\n`Config` 类仅用于 Pydantic 配置。您可以在Pydantic Model Config中阅读更多相关信息。\n\n///\n\n### 使用 `lru_cache` 仅创建一次 `Settings`\n\n从磁盘中读取文件通常是一项耗时的（慢）操作，因此您可能希望仅在首次读取后并重复使用相同的设置对象，而不是为每个请求都读取它。\n\n但是，每次执行以下操作：\n\n```Python\nSettings()\n```\n\n都会创建一个新的 `Settings` 对象，并且在创建时会再次读取 `.env` 文件。\n\n如果依赖项函数只是这样的：\n\n```Python\ndef get_settings():\n    return Settings()\n```\n\n我们将为每个请求创建该对象，并且将在每个请求中读取 `.env` 文件。 ⚠️\n\n但是，由于我们在顶部使用了 `@lru_cache` 装饰器，因此只有在第一次调用它时，才会创建 `Settings` 对象一次。 ✔️\n\n\n```py\nfrom functools import lru_cache\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\nfrom . import config\n\napp = FastAPI()\n\n\n@lru_cache\ndef get_settings():\n    return config.Settings()\n\n\n@app.get(""/info"")\nasync def info(settings: Annotated[config.Settings, Depends(get_settings)]):\n    return {\n        ""app_name"": settings.app_name,\n        ""admin_email"": settings.admin_email,\n        ""items_per_user"": settings.items_per_user,\n    }\n\n```\n\n\n然后，在下一次请求的依赖项中对 `get_settings()` 进行任何后续调用时，它不会执行 `get_settings()` 的内部代码并创建新的 `Settings` 对象，而是返回在第一次调用时返回的相同对象，一次又一次。\n\n#### `lru_cache` 技术细节\n\n`@lru_cache` 修改了它所装饰的函数，以返回第一次返回的相同值，而不是再次计算它，每次都执行函数的代码。\n\n因此，下面的函数将对每个参数组合执行一次。然后，每个参数组合返回的值将在使用完全相同的参数组合调用函数时再次使用。\n\n例如，如果您有一个函数：\n```Python\n@lru_cache\ndef say_hi(name: str, salutation: str = ""Ms.""):\n    return f""Hello {salutation} {name}""\n```\n\n您的程序可以像这样执行：\n\n```mermaid\nsequenceDiagram\n\nparticipant code as Code\nparticipant function as say_hi()\nparticipant execute as Execute function\n\n    rect rgba(0, 255, 0, .1)\n        code -&gt;&gt; function: say_hi(name=""Camila"")\n        function -&gt;&gt; execute: 执行函数代码\n        execute -&gt;&gt; code: 返回结果\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code -&gt;&gt; function: say_hi(name=""Camila"")\n        function -&gt;&gt; code: 返回存储的结果\n    end\n\n    rect rgba(0, 255, 0, .1)\n        code -&gt;&gt; function: say_hi(name=""Rick"")\n        function -&gt;&gt; execute: 执行函数代码\n        execute -&gt;&gt; code: 返回结果\n    end\n\n    rect rgba(0, 255, 0, .1)\n        code -&gt;&gt; function: say_hi(name=""Rick"", salutation=""Mr."")\n        function -&gt;&gt; execute: 执行函数代码\n        execute -&gt;&gt; code: 返回结果\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code -&gt;&gt; function: say_hi(name=""Rick"")\n        function -&gt;&gt; code: 返回存储的结果\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code -&gt;&gt; function: say_hi(name=""Camila"")\n        function -&gt;&gt; code: 返回存储的结果\n    end\n```\n\n对于我们的依赖项 `get_settings()`，该函数甚至不接受任何参数，因此它始终返回相同的值。\n\n这样，它的行为几乎就像是一个全局变量。但是由于它使用了依赖项函数，因此我们可以轻松地进行测试时的覆盖。\n\n`@lru_cache` 是 `functools` 的一部分，它是 Python 标准库的一部分，您可以在Python 文档中了解有关 `@lru_cache` 的更多信息。\n\n## 小结\n\n您可以使用 Pydantic 设置处理应用程序的设置或配置，利用 Pydantic 模型的所有功能。\n\n* 通过使用依赖项，您可以简化测试。\n* 您可以使用 `.env` 文件。\n* 使用 `@lru_cache` 可以避免为每个请求重复读取 dotenv 文件，同时允许您在测试时进行覆盖。', '# 依赖项\n\nFastAPI 提供了简单易用，但功能强大的<abbr title=""也称为组件、资源、提供者、服务、可注入项"">依赖注入</abbr>系统。\n\n这个依赖系统设计的简单易用，可以让开发人员轻松地把组件集成至 FastAPI。\n\n## 什么是「依赖注入」\n\n编程中的「依赖注入」是声明代码（本文中为*路径操作函数* ）运行所需的，或要使用的「依赖」的一种方式。\n\n然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n\n依赖注入常用于以下场景：\n\n* 共享业务逻辑（复用相同的代码逻辑）\n* 共享数据库连接\n* 实现安全、验证、角色权限\n* 等……\n\n上述场景均可以使用依赖注入，将代码重复最小化。\n\n## 第一步\n\n接下来，我们学习一个非常简单的例子，尽管它过于简单，不是很实用。\n\n但通过这个例子，您可以初步了解「依赖注入」的工作机制。\n\n### 创建依赖项\n\n首先，要关注的是依赖项。\n\n依赖项就是一个函数，且可以使用与*路径操作函数*相同的参数：\n\n\n```py\nfrom typing import Annotated, Union\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(\n    q: Union[str, None] = None, skip: int = 0, limit: int = 100\n):\n    return {""q"": q, ""skip"": skip, ""limit"": limit}\n\n\n@app.get(""/items/"")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n\n@app.get(""/users/"")\nasync def read_users(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n```\n\n\n大功告成。\n\n只用了2 行代码。\n\n依赖项函数的形式和结构与*路径操作函数*一样。\n\n因此，可以把依赖项当作没有「装饰器」（即，没有 `@app.get(""/some-path"")` ）的路径操作函数。\n\n依赖项可以返回各种内容。\n\n本例中的依赖项预期接收如下参数：\n\n* 类型为 `str` 的可选查询参数 `q`\n* 类型为 `int` 的可选查询参数 `skip`，默认值是 `0`\n* 类型为 `int` 的可选查询参数 `limit`，默认值是 `100`\n\n然后，依赖项函数返回包含这些值的 `dict`。\n\n### 导入 `Depends`\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n### 声明依赖项\n\n与在*路径操作函数*参数中使用 `Body`、`Query` 的方式相同，声明依赖项需要使用 `Depends` 和一个新的参数：\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n虽然，在路径操作函数的参数中使用 `Depends` 的方式与 `Body`、`Query` 相同，但 `Depends` 的工作方式略有不同。\n\n这里只能传给 Depends 一个参数。\n\n且该参数必须是可调用对象，比如函数。\n\n该函数接收的参数和*路径操作函数*的参数一样。\n\n/// tip | 提示\n\n下一章介绍，除了函数还有哪些「对象」可以用作依赖项。\n\n///\n\n接收到新的请求时，FastAPI 执行如下操作：\n\n* 用正确的参数调用依赖项函数（「可依赖项」）\n* 获取函数返回的结果\n* 把函数返回的结果赋值给*路径操作函数*的参数\n\n```mermaid\ngraph TB\n\ncommon_parameters([""common_parameters""])\nread_items[""/items/""]\nread_users[""/users/""]\n\ncommon_parameters --&gt; read_items\ncommon_parameters --&gt; read_users\n```\n\n这样，只编写一次代码，FastAPI 就可以为多个*路径操作*共享这段代码 。\n\n/// check | 检查\n\n注意，无需创建专门的类，并将之传递给 FastAPI 以进行「注册」或执行类似的操作。\n\n只要把它传递给 `Depends`，FastAPI 就知道该如何执行后续操作。\n\n///\n\n## 要不要使用 `async`？\n\nFastAPI 调用依赖项的方式与*路径操作函数*一样，因此，定义依赖项函数，也要应用与路径操作函数相同的规则。\n\n即，既可以使用异步的 `async def`，也可以使用普通的 `def` 定义依赖项。\n\n在普通的 `def` *路径操作函数*中，可以声明异步的 `async def` 依赖项；也可以在异步的 `async def` *路径操作函数*中声明普通的 `def` 依赖项。\n\n上述这些操作都是可行的，FastAPI 知道该怎么处理。\n\n/// note | 笔记\n\n如里不了解异步，请参阅[异步：*“着急了？”*](../../async.md){.internal-link target=_blank} 一章中 `async` 和 `await` 的内容。\n\n///\n\n## 与 OpenAPI 集成\n\n依赖项及子依赖项的所有请求声明、验证和需求都可以集成至同一个 OpenAPI 概图。\n\n所以，交互文档里也会显示依赖项的所有信息：\n\n## 简单用法\n\n观察一下就会发现，只要*路径* 和*操作*匹配，就可以使用声明的路径操作函数。然后，FastAPI 会用正确的参数调用函数，并提取请求中的数据。\n\n实际上，所有（或大多数）网络框架的工作方式都是这样的。\n\n开发人员永远都不需要直接调用这些函数，这些函数是由框架（在此为 FastAPI ）调用的。\n\n通过依赖注入系统，只要告诉 FastAPI *路径操作函数* 还要「依赖」其他在*路径操作函数*之前执行的内容，FastAPI 就会执行函数代码，并「注入」函数返回的结果。\n\n其他与「依赖注入」概念相同的术语为：\n\n* 资源（Resource）\n* 提供方（Provider）\n* 服务（Service）\n* 可注入（Injectable）\n* 组件（Component）\n\n## FastAPI 插件\n\n依赖注入系统支持构建集成和「插件」。但实际上，FastAPI 根本不需要创建「插件」，因为使用依赖项可以声明不限数量的、可用于*路径操作函数*的集成与交互。\n\n创建依赖项非常简单、直观，并且还支持导入 Python 包。毫不夸张地说，只要几行代码就可以把需要的 Python 包与 API 函数集成在一起。\n\n下一章将详细介绍在关系型数据库、NoSQL 数据库、安全等方面使用依赖项的例子。\n\n## FastAPI 兼容性\n\n依赖注入系统如此简洁的特性，让 FastAPI 可以与下列系统兼容：\n\n* 关系型数据库\n* NoSQL 数据库\n* 外部支持库\n* 外部 API\n* 认证和鉴权系统\n* API 使用监控系统\n* 响应数据注入系统\n* 等等……\n\n## 简单而强大\n\n虽然，层级式依赖注入系统的定义与使用十分简单，但它却非常强大。\n\n比如，可以定义依赖其他依赖项的依赖项。\n\n最后，依赖项层级树构建后，依赖注入系统会处理所有依赖项及其子依赖项，并为每一步操作提供（注入）结果。\n\n比如，下面有 4 个 API 路径操作（*端点*）：\n\n* `/items/public/`\n* `/items/private/`\n* `/users/{user_id}/activate`\n* `/items/pro/`\n\n开发人员可以使用依赖项及其子依赖项为这些路径操作添加不同的权限：\n\n```mermaid\ngraph TB\n\ncurrent_user([""current_user""])\nactive_user([""active_user""])\nadmin_user([""admin_user""])\npaying_user([""paying_user""])\n\npublic[""/items/public/""]\nprivate[""/items/private/""]\nactivate_user[""/users/{user_id}/activate""]\npro_items[""/items/pro/""]\n\ncurrent_user --&gt; active_user\nactive_user --&gt; admin_user\nactive_user --&gt; paying_user\n\ncurrent_user --&gt; public\nactive_user --&gt; private\nadmin_user --&gt; activate_user\npaying_user --&gt; pro_items\n```\n\n## 与 OpenAPI 集成\n\n在声明需求时，所有这些依赖项还会把参数、验证等功能添加至路径操作。\n\nFastAPI 负责把上述内容全部添加到 OpenAPI 概图，并显示在交互文档中。']","根据提供的上下文，无法直接找到在 FastAPI 的 `settings.py` 中配置内置 ORM 连接数据库的具体方法。原因如下：

1. **上下文未提及 `settings.py` 文件**  
   提供的示例代码中，数据库配置（如 SQLite 连接）直接写在主应用文件（如 `main.py`）中，例如：  
   ```python
   sqlite_url = ""sqlite:///database.db""
   engine = create_engine(sqlite_url)
   ```

2. **ORM 配置与主逻辑耦合**  
   数据库引擎创建、会话管理和表初始化均通过代码直接实现（如 `create_engine()` 和 `Session`），未展示独立配置文件的使用。

3. **环境变量管理替代独立配置**  
   上下文介绍了通过 Pydantic 的 `BaseSettings` 管理环境变量（如数据库 URL），但未将其与 `settings.py` 文件关联，而是直接集成在依赖项或主模块中。

**结论**：  
提供的上下文未说明如何在 `settings.py` 中配置内置 ORM。建议查阅 FastAPI 官方文档或 SQLModel 专项指南获取具体配置方法。","这是一个误解。FastAPI 是一个无主见（Unopinionated）的框架，它没有内置的 ORM（对象关系映射）或类似 Django 的 `settings.py` 配置文件。你可以自由选择任何数据库库（如 SQLAlchemy, SQLModel, Tortoise ORM 等）。通常，我们会使用 Pydantic 的 `BaseSettings` 来管理环境变量和配置，并在单独的文件（如 `database.py`）中手动初始化数据库连接。",0.9999999999666667,0.8666666666666667,0.0
为什么我在 path operation 里用了 threading.Thread 去开新线程处理任务，请求还是阻塞了？,"['# 并发 async / await\n\n有关路径操作函数的 `async def` 语法以及异步代码、并发和并行的一些背景知识。\n\n## 赶时间吗？\n\n<abbr title=""too long; didn\'t read(长文警告)"">TL;DR:</abbr>\n\n如果你正在使用第三方库，它们会告诉你使用 `await` 关键字来调用它们，就像这样：\n\n```Python\nresults = await some_library()\n```\n\n然后，通过 `async def` 声明你的 *路径操作函数*：\n\n```Python hl_lines=""2""\n@app.get(\'/\')\nasync def read_results():\n    results = await some_library()\n    return results\n```\n\n/// note\n\n你只能在被 `async def` 创建的函数内使用 `await`\n\n///\n\n如果你正在使用一个第三方库和某些组件（比如：数据库、API、文件系统...）进行通信，第三方库又不支持使用 `await` （目前大多数数据库三方库都是这样），这种情况你可以像平常那样使用 `def` 声明一个路径操作函数，就像这样：\n\n```Python hl_lines=""2""\n@app.get(\'/\')\ndef results():\n    results = some_library()\n    return results\n```\n\n如果你的应用程序不需要与其他任何东西通信而等待其响应，请使用 `async def`。\n\n如果你不清楚，使用 `def` 就好.\n\n注意：你可以根据需要在路径操作函数中混合使用 `def` 和 `async def`，并使用最适合你的方式去定义每个函数。FastAPI 将为他们做正确的事情。\n\n无论如何，在上述任何情况下，FastAPI 仍将异步工作，速度也非常快。\n\n但是，通过遵循上述步骤，它将能够进行一些性能优化。\n\n## 技术细节\n\nPython 的现代版本支持通过一种叫""协程""——使用 `async` 和 `await` 语法的东西来写”异步代码“。\n\n让我们在下面的部分中逐一介绍：\n\n* 异步代码\n* `async` 和 `await`\n* 协程\n\n## 异步代码\n\n异步代码仅仅意味着编程语言 💬 有办法告诉计算机/程序 🤖 在代码中的某个点，它 🤖 将不得不等待在某些地方完成一些事情。让我们假设一些事情被称为 ""慢文件""📝.\n\n所以，在等待""慢文件""📝完成的这段时间，计算机可以做一些其他工作。\n\n然后计算机/程序 🤖 每次有机会都会回来，因为它又在等待，或者它 🤖 完成了当前所有的工作。而且它 🤖 将查看它等待的所有任务中是否有已经完成的，做它必须做的任何事情。\n\n接下来，它 🤖 完成第一个任务（比如是我们的""慢文件""📝) 并继续与之相关的一切。\n\n这个""等待其他事情""通常指的是一些相对较慢（与处理器和 RAM 存储器的速度相比）的 <abbr title=""Input and Output"">I/O</abbr> 操作，比如说：\n\n* 通过网络发送来自客户端的数据\n* 客户端接收来自网络中的数据\n* 磁盘中要由系统读取并提供给程序的文件的内容\n* 程序提供给系统的要写入磁盘的内容\n* 一个 API 的远程调用\n* 一个数据库操作，直到完成\n* 一个数据库查询，直到返回结果\n* 等等.\n\n这个执行的时间大多是在等待 <abbr title=""Input and Output"">I/O</abbr> 操作，因此它们被叫做 ""I/O 密集型"" 操作。\n\n它被称为""异步""的原因是因为计算机/程序不必与慢任务""同步""，去等待任务完成的确切时刻，而在此期间不做任何事情直到能够获取任务结果才继续工作。\n\n相反，作为一个""异步""系统，一旦完成，任务就可以排队等待一段时间（几微秒），等待计算机程序完成它要做的任何事情，然后回来获取结果并继续处理它们。\n\n对于""同步""（与""异步""相反），他们通常也使用""顺序""一词，因为计算机程序在切换到另一个任务之前是按顺序执行所有步骤，即使这些步骤涉及到等待。\n\n### 并发与汉堡\n\n上述异步代码的思想有时也被称为“并发”，它不同于“并行”。\n\n并发和并行都与“不同的事情或多或少同时发生”有关。\n\n但是并发和并行之间的细节是完全不同的。\n\n要了解差异，请想象以下关于汉堡的故事：\n\n### 并发汉堡\n\n你和你的恋人一起去快餐店，你排队在后面，收银员从你前面的人接单。😍\n\n然后轮到你了，你为你的恋人和你选了两个非常豪华的汉堡。🍔🍔\n\n收银员对厨房里的厨师说了一些话，让他们知道他们必须为你准备汉堡（尽管他们目前正在为之前的顾客准备汉堡）。\n\n你付钱了。 💸\n\n收银员给你轮到的号码。\n\n当你在等待的时候，你和你的恋人一起去挑选一张桌子，然后你们坐下来聊了很长时间（因为汉堡很豪华，需要一些时间来准备）。\n\n当你和你的恋人坐在桌子旁，等待汉堡的时候，你可以用这段时间来欣赏你的恋人是多么的棒、可爱和聪明✨😍✨。\n\n在等待中和你的恋人交谈时，你会不时地查看柜台上显示的号码，看看是否已经轮到你了。\n\n然后在某个时刻，终于轮到你了。你去柜台拿汉堡然后回到桌子上。\n\n你们享用了汉堡，整个过程都很开心。✨\n\n/// info\n\n漂亮的插画来自 Ketrina Thompson. 🎨\n\n///\n\n在那个故事里，假设你是计算机程序 🤖 。\n\n当你在排队时，你只是闲着😴， 轮到你前不做任何事情（仅排队）。但排队很快，因为收银员只接订单（不准备订单），所以这一切都还好。\n\n然后，当轮到你时，需要你做一些实际性的工作，比如查看菜单，决定你想要什么，让你的恋人选择，支付，检查你是否提供了正确的账单或卡，检查你的收费是否正确，检查订单是否有正确的项目，等等。\n\n此时，即使你仍然没有汉堡，你和收银员的工作也""暂停""了⏸， 因为你必须等待一段时间 🕙 让你的汉堡做好。\n\n但是，当你离开柜台并坐在桌子旁，在轮到你的号码前的这段时间，你可以将焦点切换到 🔀 你的恋人上，并做一些""工作""⏯ 🤓。你可以做一些非常""有成效""的事情，比如和你的恋人调情😍.\n\n之后，收银员 💁 把号码显示在显示屏上，并说到 ""汉堡做好了""，而当显示的号码是你的号码时，你不会立刻疯狂地跳起来。因为你知道没有人会偷你的汉堡，因为你有你的号码，而其他人又有他们自己的号码。\n\n所以你要等待你的恋人完成故事（完成当前的工作⏯ /正在做的事🤓)， 轻轻微笑，说你要吃汉堡⏸.\n\n然后你去柜台🔀， 到现在初始任务已经完成⏯， 拿起汉堡，说声谢谢，然后把它们送到桌上。这就完成了与计数器交互的步骤/任务⏹. 这反过来又产生了一项新任务，即""吃汉堡""🔀 ⏯， 上一个""拿汉堡""的任务已经结束了⏹.\n\n### 并行汉堡\n\n现在让我们假设不是""并发汉堡""，而是""并行汉堡""。\n\n你和你的恋人一起去吃并行快餐。\n\n你站在队伍中，同时是厨师的几个收银员（比方说8个）从前面的人那里接单。\n\n你之前的每个人都在等待他们的汉堡准备好后才离开柜台，因为8名收银员都会在下一份订单前马上准备好汉堡。\n\n然后，终于轮到你了，你为你的恋人和你订购了两个非常精美的汉堡。\n\n你付钱了 💸。\n\n收银员去厨房。\n\n你站在柜台前 🕙等待着，这样就不会有人在你之前抢走你的汉堡，因为没有轮流的号码。\n\n当你和你的恋人忙于不让任何人出现在你面前，并且在他们到来的时候拿走你的汉堡时，你无法关注到你的恋人。😞\n\n这是""同步""的工作，你被迫与服务员/厨师 👨\u200d🍳""同步""。你在此必须等待 🕙 ，在收银员/厨师 👨\u200d🍳 完成汉堡并将它们交给你的确切时间到达之前一直等待，否则其他人可能会拿走它们。\n\n你经过长时间的等待 🕙 ，收银员/厨师 👨\u200d🍳终于带着汉堡回到了柜台。\n\n你拿着汉堡，和你的情人一起上桌。\n\n你们仅仅是吃了它们，就结束了。⏹\n\n没有太多的交谈或调情，因为大部分时间 🕙 都在柜台前等待😞。\n\n/// info\n\n漂亮的插画来自 Ketrina Thompson. 🎨\n\n///\n\n在这个并行汉堡的场景中，你是一个计算机程序 🤖 且有两个处理器（你和你的恋人），都在等待 🕙 ，并投入他们的注意力 ⏯ 在柜台上等待了很长一段时间。\n\n这家快餐店有 8 个处理器（收银员/厨师）。而并发汉堡店可能只有 2 个（一个收银员和一个厨师）。\n\n但最终的体验仍然不是最好的。😞\n\n这将是与汉堡的类似故事。🍔\n\n一种更""贴近生活""的例子，想象一家银行。\n\n直到最近，大多数银行都有多个出纳员 👨\u200d💼👨\u200d💼👨\u200d💼👨\u200d💼 还有一条长长排队队伍🕙🕙🕙🕙🕙🕙🕙🕙。\n\n所有收银员都是一个接一个的在客户面前做完所有的工作👨\u200d💼⏯.\n\n你必须经过 🕙 较长时间排队，否则你就没机会了。\n\n你可不会想带你的恋人 😍 和你一起去银行办事🏦.\n\n### 汉堡结论\n\n在""你与恋人一起吃汉堡""的这个场景中，因为有很多人在等待🕙， 使用并发系统更有意义⏸🔀⏯.\n\n大多数 Web 应用都是这样的。\n\n你的服务器正在等待很多很多用户通过他们不太好的网络发送来的请求。\n\n然后再次等待 🕙 响应回来。\n\n这个""等待"" 🕙 是以微秒为单位测量的，但总的来说，最后还是等待很久。\n\n这就是为什么使用异步对于 Web API 很有意义的原因 ⏸🔀⏯。\n\n这种异步机制正是 NodeJS 受到欢迎的原因（尽管 NodeJS 不是并行的），以及 Go 作为编程语言的优势所在。\n\n这与 FastAPI 的性能水平相同。\n\n你可以同时拥有并行性和异步性，你可以获得比大多数经过测试的 NodeJS 框架更高的性能，并且与 Go 不相上下， Go 是一种更接近于 C 的编译语言（全部归功于 Starlette）。\n\n### 并发比并行好吗？\n\n不！这不是故事的本意。\n\n并发不同于并行。而是在需要大量等待的特定场景下效果更好。因此，在 Web 应用程序开发中，它通常比并行要好得多，但这并不意味着全部。\n\n因此，为了平衡这一点，想象一下下面的短篇故事：\n\n&gt; 你必须打扫一个又大又脏的房子。\n\n*是的，这就是完整的故事。*\n\n在任何地方， 都不需要等待 🕙 ，只需要在房子的多个地方做着很多工作。\n\n你可以像汉堡的例子那样轮流执行，先是客厅，然后是厨房，但因为你不需要等待 🕙 ，对于任何事情都是清洁，清洁，还是清洁，轮流不会影响任何事情。\n\n无论是否轮流执行（并发），都需要相同的时间来完成，而你也会完成相同的工作量。\n\n但在这种情况下，如果你能带上 8 名前收银员/厨师，现在是清洁工一起清扫，他们中的每一个人（加上你）都能占据房子的一个区域来清扫，你就可以在额外的帮助下并行的更快地完成所有工作。\n\n在这个场景中，每个清洁工（包括你）都将是一个处理器，完成这个工作的一部分。\n\n由于大多数执行时间是由实际工作（而不是等待）占用的，并且计算机中的工作是由 <abbr title=""Central Processing Unit"">CPU</abbr> 完成的，所以他们称这些问题为""CPU 密集型""。\n\nCPU 密集型操作的常见示例是需要复杂的数学处理。\n\n例如：\n\n* 音频或图像处理；\n* 计算机视觉: 一幅图像由数百万像素组成，每个像素有3种颜色值，处理通常需要同时对这些像素进行计算；\n* 机器学习: 它通常需要大量的""矩阵""和""向量""乘法。想象一个包含数字的巨大电子表格，并同时将所有数字相乘；\n* 深度学习: 这是机器学习的一个子领域，同样适用。只是没有一个数字的电子表格可以相乘，而是一个庞大的数字集合，在很多情况下，你需要使用一个特殊的处理器来构建和使用这些模型。\n\n### 并发 + 并行: Web + 机器学习\n\n使用 FastAPI，你可以利用 Web 开发中常见的并发机制的优势（NodeJS 的主要吸引力）。\n\n并且，你也可以利用并行和多进程（让多个进程并行运行）的优点来处理与机器学习系统中类似的 CPU 密集型 工作。\n\n这一点，再加上 Python 是数据科学、机器学习（尤其是深度学习）的主要语言这一简单事实，使得 FastAPI 与数据科学/机器学习 Web API 和应用程序（以及其他许多应用程序）非常匹配。\n\n了解如何在生产环境中实现这种并行性，可查看此文 [Deployment](deployment/index.md){.internal-link target=_blank}。\n\n## `async` 和 `await`\n\n现代版本的 Python 有一种非常直观的方式来定义异步代码。这使它看起来就像正常的""顺序""代码，并在适当的时候""等待""。\n\n当有一个操作需要等待才能给出结果，且支持这个新的 Python 特性时，你可以编写如下代码：\n\n```Python\nburgers = await get_burgers(2)\n```\n\n这里的关键是 `await`。它告诉 Python 它必须等待 ⏸ `get_burgers(2)` 完成它的工作 🕙 ，然后将结果存储在 `burgers` 中。这样，Python 就会知道此时它可以去做其他事情 🔀 ⏯ （比如接收另一个请求）。\n\n要使 `await` 工作，它必须位于支持这种异步机制的函数内。因此，只需使用 `async def` 声明它：\n\n```Python hl_lines=""1""\nasync def get_burgers(number: int):\n    # Do some asynchronous stuff to create the burgers\n    return burgers\n```\n\n...而不是 `def`:\n\n```Python hl_lines=""2""\n# This is not asynchronous\ndef get_sequential_burgers(number: int):\n    # Do some sequential stuff to create the burgers\n    return burgers\n```\n\n使用 `async def`，Python 就知道在该函数中，它将遇上 `await`，并且它可以""暂停"" ⏸ 执行该函数，直至执行其他操作 🔀 后回来。\n\n当你想调用一个 `async def` 函数时，你必须""等待""它。因此，这不会起作用：\n\n```Python\n# This won\'t work, because get_burgers was defined with: async def\nburgers = get_burgers(2)\n```\n\n因此，如果你使用的库告诉你可以使用 `await` 调用它，则需要使用 `async def` 创建路径操作函数 ，如：\n\n```Python hl_lines=""2-3""\n@app.get(\'/burgers\')\nasync def read_burgers():\n    burgers = await get_burgers(2)\n    return burgers\n```\n\n### 更多技术细节\n\n你可能已经注意到，`await` 只能在 `async def` 定义的函数内部使用。\n\n但与此同时，必须""等待""通过 `async def` 定义的函数。因此，带 `async def` 的函数也只能在 `async def` 定义的函数内部调用。\n\n那么，这关于先有鸡还是先有蛋的问题，如何调用第一个 `async` 函数？\n\n如果你使用 FastAPI，你不必担心这一点，因为""第一个""函数将是你的路径操作函数，FastAPI 将知道如何做正确的事情。\n\n但如果你想在没有 FastAPI 的情况下使用 `async` / `await`，则可以这样做。\n\n### 编写自己的异步代码\n\nStarlette （和 FastAPI） 是基于 AnyIO 实现的，这使得它们可以兼容 Python 的标准库 asyncio 和 Trio。\n\n特别是，你可以直接使用 AnyIO 来处理高级的并发用例，这些用例需要在自己的代码中使用更高级的模式。\n\n即使你没有使用 FastAPI，你也可以使用 AnyIO 编写自己的异步程序，使其拥有较高的兼容性并获得一些好处（例如， 结构化并发）。\n\n我（指原作者 —— 译者注）基于 AnyIO 新建了一个库，作为一个轻量级的封装层，用来优化类型注解，同时提供了更好的自动补全、内联错误提示等功能。这个库还附带了一个友好的入门指南和教程，能帮助你理解并编写自己的异步代码：Asyncer。如果你有结合使用异步代码和常规（阻塞/同步）代码的需求，这个库会特别有用。\n\n### 其他形式的异步代码\n\n这种使用 `async` 和 `await` 的风格在语言中相对较新。\n\n但它使处理异步代码变得容易很多。\n\n这种相同的语法（或几乎相同）最近也包含在现代版本的 JavaScript 中（在浏览器和 NodeJS 中）。\n\n但在此之前，处理异步代码非常复杂和困难。\n\n在以前版本的 Python，你可以使用多线程或者 Gevent。但代码的理解、调试和思考都要复杂许多。\n\n在以前版本的 NodeJS / 浏览器 JavaScript 中，你会使用""回调""，因此也可能导致“回调地狱”。\n\n## 协程\n\n协程只是 `async def` 函数返回的一个非常奇特的东西的称呼。Python 知道它有点像一个函数，它可以启动，也会在某个时刻结束，而且它可能会在内部暂停 ⏸ ，只要内部有一个 `await`。\n\n通过使用 `async` 和 `await` 的异步代码的所有功能大多数被概括为""协程""。它可以与 Go 的主要关键特性 ""Goroutines"" 相媲美。\n\n## 结论\n\n让我们再来回顾下上文所说的：\n\n&gt; Python 的现代版本可以通过使用 `async` 和 `await` 语法创建协程，并用于支持异步代码。\n\n现在应该能明白其含义了。✨\n\n所有这些使得 FastAPI（通过 Starlette）如此强大，也是它拥有如此令人印象深刻的性能的原因。\n\n## 非常技术性的细节\n\n/// warning\n\n你可以跳过这里。\n\n这些都是 FastAPI 如何在内部工作的技术细节。\n\n如果你有相当多的技术知识（协程、线程、阻塞等），并且对 FastAPI 如何处理 `async def` 与常规 `def` 感到好奇，请继续。\n\n///\n\n### 路径操作函数\n\n当你使用 `def` 而不是 `async def` 来声明一个*路径操作函数*时，它运行在外部的线程池中并等待其结果，而不是直接调用（因为它会阻塞服务器）。\n\n如果你使用过另一个不以上述方式工作的异步框架，并且你习惯于用普通的 `def` 定义普通的仅计算路径操作函数，以获得微小的性能增益（大约100纳秒），请注意，在 FastAPI 中，效果将完全相反。在这些情况下，最好使用 `async def`，除非路径操作函数内使用执行阻塞 <abbr title=""输入/输出：磁盘读写，网络通讯."">I/O</abbr> 的代码。\n\n在这两种情况下，与你之前的框架相比，FastAPI 可能[仍然很快](index.md#_11){.internal-link target=_blank}。\n\n### 依赖\n\n这同样适用于[依赖](tutorial/dependencies/index.md){.internal-link target=_blank}。如果一个依赖是标准的 `def` 函数而不是 `async def`，它将被运行在外部线程池中。\n\n### 子依赖\n\n你可以拥有多个相互依赖的依赖以及[子依赖](tutorial/dependencies/sub-dependencies.md){.internal-link target=_blank} （作为函数的参数），它们中的一些可能是通过 `async def` 声明，也可能是通过 `def` 声明。它们仍然可以正常工作，这些通过 `def` 声明的函数将会在外部线程中调用（来自线程池），而不是""被等待""。\n\n### 其他函数\n\n你可直接调用通过 `def` 或 `async def` 创建的任何其他函数，FastAPI 不会影响你调用它们的方式。\n\n这与 FastAPI 为你调用*路径操作函数*和依赖项的逻辑相反。\n\n如果你的函数是通过 `def` 声明的，它将被直接调用（在代码中编写的地方），而不会在线程池中，如果这个函数通过 `async def` 声明，当在代码中调用时，你就应该使用 `await` 等待函数的结果。\n\n再次提醒，这些是非常技术性的细节，如果你来搜索它可能对你有用。\n\n否则，你最好应该遵守的指导原则赶时间吗？.']","根据上下文，在 FastAPI 的路径操作中使用 `threading.Thread` 仍导致阻塞的原因如下：  
1. **I/O 密集型操作未使用异步**：`threading.Thread` 无法直接解决 I/O 等待问题（如网络请求、文件读写），而上下文强调此类场景应通过 `async/await` 释放事件循环。  
2. **同步阻塞限制**：若路径操作函数本身为同步（`def`），即使内部开线程，主线程仍可能被阻塞，无法高效处理并发请求。  
3. **解决方案**：对于 I/O 任务，应改用 `async def` 配合 `await` 异步库（如 HTTPX、异步数据库驱动）；CPU 密集型任务可结合多进程处理。  

---  
**总结**：线程在 FastAPI 中不适用于优化 I/O 阻塞，需依赖异步机制或明确的多进程方案。",如果在 `async def` 定义的路由中执行耗时操作（即使是启动线程的开销），仍可能阻塞主事件循环（Event Loop）。FastAPI 的 `async def` 路由运行在单线程循环中。如果你需要进行阻塞性操作或利用多核 CPU，建议不要手动管理 `threading.Thread`，而是将路由定义为普通的 `def`（FastAPI 会自动将其放入外部线程池运行），或者使用 `fastapi.concurrency.run_in_threadpool` 显式将任务派发到线程池。,0.9999999999,0.5555555555555556,0.7832532516767347
我要做计算密集型任务，应该用 async def 还是普通的 def？这跟 Node.js 的处理方式一样吗？,"['# 并发 async / await\n\n有关路径操作函数的 `async def` 语法以及异步代码、并发和并行的一些背景知识。\n\n## 赶时间吗？\n\n<abbr title=""too long; didn\'t read(长文警告)"">TL;DR:</abbr>\n\n如果你正在使用第三方库，它们会告诉你使用 `await` 关键字来调用它们，就像这样：\n\n```Python\nresults = await some_library()\n```\n\n然后，通过 `async def` 声明你的 *路径操作函数*：\n\n```Python hl_lines=""2""\n@app.get(\'/\')\nasync def read_results():\n    results = await some_library()\n    return results\n```\n\n/// note\n\n你只能在被 `async def` 创建的函数内使用 `await`\n\n///\n\n如果你正在使用一个第三方库和某些组件（比如：数据库、API、文件系统...）进行通信，第三方库又不支持使用 `await` （目前大多数数据库三方库都是这样），这种情况你可以像平常那样使用 `def` 声明一个路径操作函数，就像这样：\n\n```Python hl_lines=""2""\n@app.get(\'/\')\ndef results():\n    results = some_library()\n    return results\n```\n\n如果你的应用程序不需要与其他任何东西通信而等待其响应，请使用 `async def`。\n\n如果你不清楚，使用 `def` 就好.\n\n注意：你可以根据需要在路径操作函数中混合使用 `def` 和 `async def`，并使用最适合你的方式去定义每个函数。FastAPI 将为他们做正确的事情。\n\n无论如何，在上述任何情况下，FastAPI 仍将异步工作，速度也非常快。\n\n但是，通过遵循上述步骤，它将能够进行一些性能优化。\n\n## 技术细节\n\nPython 的现代版本支持通过一种叫""协程""——使用 `async` 和 `await` 语法的东西来写”异步代码“。\n\n让我们在下面的部分中逐一介绍：\n\n* 异步代码\n* `async` 和 `await`\n* 协程\n\n## 异步代码\n\n异步代码仅仅意味着编程语言 💬 有办法告诉计算机/程序 🤖 在代码中的某个点，它 🤖 将不得不等待在某些地方完成一些事情。让我们假设一些事情被称为 ""慢文件""📝.\n\n所以，在等待""慢文件""📝完成的这段时间，计算机可以做一些其他工作。\n\n然后计算机/程序 🤖 每次有机会都会回来，因为它又在等待，或者它 🤖 完成了当前所有的工作。而且它 🤖 将查看它等待的所有任务中是否有已经完成的，做它必须做的任何事情。\n\n接下来，它 🤖 完成第一个任务（比如是我们的""慢文件""📝) 并继续与之相关的一切。\n\n这个""等待其他事情""通常指的是一些相对较慢（与处理器和 RAM 存储器的速度相比）的 <abbr title=""Input and Output"">I/O</abbr> 操作，比如说：\n\n* 通过网络发送来自客户端的数据\n* 客户端接收来自网络中的数据\n* 磁盘中要由系统读取并提供给程序的文件的内容\n* 程序提供给系统的要写入磁盘的内容\n* 一个 API 的远程调用\n* 一个数据库操作，直到完成\n* 一个数据库查询，直到返回结果\n* 等等.\n\n这个执行的时间大多是在等待 <abbr title=""Input and Output"">I/O</abbr> 操作，因此它们被叫做 ""I/O 密集型"" 操作。\n\n它被称为""异步""的原因是因为计算机/程序不必与慢任务""同步""，去等待任务完成的确切时刻，而在此期间不做任何事情直到能够获取任务结果才继续工作。\n\n相反，作为一个""异步""系统，一旦完成，任务就可以排队等待一段时间（几微秒），等待计算机程序完成它要做的任何事情，然后回来获取结果并继续处理它们。\n\n对于""同步""（与""异步""相反），他们通常也使用""顺序""一词，因为计算机程序在切换到另一个任务之前是按顺序执行所有步骤，即使这些步骤涉及到等待。\n\n### 并发与汉堡\n\n上述异步代码的思想有时也被称为“并发”，它不同于“并行”。\n\n并发和并行都与“不同的事情或多或少同时发生”有关。\n\n但是并发和并行之间的细节是完全不同的。\n\n要了解差异，请想象以下关于汉堡的故事：\n\n### 并发汉堡\n\n你和你的恋人一起去快餐店，你排队在后面，收银员从你前面的人接单。😍\n\n然后轮到你了，你为你的恋人和你选了两个非常豪华的汉堡。🍔🍔\n\n收银员对厨房里的厨师说了一些话，让他们知道他们必须为你准备汉堡（尽管他们目前正在为之前的顾客准备汉堡）。\n\n你付钱了。 💸\n\n收银员给你轮到的号码。\n\n当你在等待的时候，你和你的恋人一起去挑选一张桌子，然后你们坐下来聊了很长时间（因为汉堡很豪华，需要一些时间来准备）。\n\n当你和你的恋人坐在桌子旁，等待汉堡的时候，你可以用这段时间来欣赏你的恋人是多么的棒、可爱和聪明✨😍✨。\n\n在等待中和你的恋人交谈时，你会不时地查看柜台上显示的号码，看看是否已经轮到你了。\n\n然后在某个时刻，终于轮到你了。你去柜台拿汉堡然后回到桌子上。\n\n你们享用了汉堡，整个过程都很开心。✨\n\n/// info\n\n漂亮的插画来自 Ketrina Thompson. 🎨\n\n///\n\n在那个故事里，假设你是计算机程序 🤖 。\n\n当你在排队时，你只是闲着😴， 轮到你前不做任何事情（仅排队）。但排队很快，因为收银员只接订单（不准备订单），所以这一切都还好。\n\n然后，当轮到你时，需要你做一些实际性的工作，比如查看菜单，决定你想要什么，让你的恋人选择，支付，检查你是否提供了正确的账单或卡，检查你的收费是否正确，检查订单是否有正确的项目，等等。\n\n此时，即使你仍然没有汉堡，你和收银员的工作也""暂停""了⏸， 因为你必须等待一段时间 🕙 让你的汉堡做好。\n\n但是，当你离开柜台并坐在桌子旁，在轮到你的号码前的这段时间，你可以将焦点切换到 🔀 你的恋人上，并做一些""工作""⏯ 🤓。你可以做一些非常""有成效""的事情，比如和你的恋人调情😍.\n\n之后，收银员 💁 把号码显示在显示屏上，并说到 ""汉堡做好了""，而当显示的号码是你的号码时，你不会立刻疯狂地跳起来。因为你知道没有人会偷你的汉堡，因为你有你的号码，而其他人又有他们自己的号码。\n\n所以你要等待你的恋人完成故事（完成当前的工作⏯ /正在做的事🤓)， 轻轻微笑，说你要吃汉堡⏸.\n\n然后你去柜台🔀， 到现在初始任务已经完成⏯， 拿起汉堡，说声谢谢，然后把它们送到桌上。这就完成了与计数器交互的步骤/任务⏹. 这反过来又产生了一项新任务，即""吃汉堡""🔀 ⏯， 上一个""拿汉堡""的任务已经结束了⏹.\n\n### 并行汉堡\n\n现在让我们假设不是""并发汉堡""，而是""并行汉堡""。\n\n你和你的恋人一起去吃并行快餐。\n\n你站在队伍中，同时是厨师的几个收银员（比方说8个）从前面的人那里接单。\n\n你之前的每个人都在等待他们的汉堡准备好后才离开柜台，因为8名收银员都会在下一份订单前马上准备好汉堡。\n\n然后，终于轮到你了，你为你的恋人和你订购了两个非常精美的汉堡。\n\n你付钱了 💸。\n\n收银员去厨房。\n\n你站在柜台前 🕙等待着，这样就不会有人在你之前抢走你的汉堡，因为没有轮流的号码。\n\n当你和你的恋人忙于不让任何人出现在你面前，并且在他们到来的时候拿走你的汉堡时，你无法关注到你的恋人。😞\n\n这是""同步""的工作，你被迫与服务员/厨师 👨\u200d🍳""同步""。你在此必须等待 🕙 ，在收银员/厨师 👨\u200d🍳 完成汉堡并将它们交给你的确切时间到达之前一直等待，否则其他人可能会拿走它们。\n\n你经过长时间的等待 🕙 ，收银员/厨师 👨\u200d🍳终于带着汉堡回到了柜台。\n\n你拿着汉堡，和你的情人一起上桌。\n\n你们仅仅是吃了它们，就结束了。⏹\n\n没有太多的交谈或调情，因为大部分时间 🕙 都在柜台前等待😞。\n\n/// info\n\n漂亮的插画来自 Ketrina Thompson. 🎨\n\n///\n\n在这个并行汉堡的场景中，你是一个计算机程序 🤖 且有两个处理器（你和你的恋人），都在等待 🕙 ，并投入他们的注意力 ⏯ 在柜台上等待了很长一段时间。\n\n这家快餐店有 8 个处理器（收银员/厨师）。而并发汉堡店可能只有 2 个（一个收银员和一个厨师）。\n\n但最终的体验仍然不是最好的。😞\n\n这将是与汉堡的类似故事。🍔\n\n一种更""贴近生活""的例子，想象一家银行。\n\n直到最近，大多数银行都有多个出纳员 👨\u200d💼👨\u200d💼👨\u200d💼👨\u200d💼 还有一条长长排队队伍🕙🕙🕙🕙🕙🕙🕙🕙。\n\n所有收银员都是一个接一个的在客户面前做完所有的工作👨\u200d💼⏯.\n\n你必须经过 🕙 较长时间排队，否则你就没机会了。\n\n你可不会想带你的恋人 😍 和你一起去银行办事🏦.\n\n### 汉堡结论\n\n在""你与恋人一起吃汉堡""的这个场景中，因为有很多人在等待🕙， 使用并发系统更有意义⏸🔀⏯.\n\n大多数 Web 应用都是这样的。\n\n你的服务器正在等待很多很多用户通过他们不太好的网络发送来的请求。\n\n然后再次等待 🕙 响应回来。\n\n这个""等待"" 🕙 是以微秒为单位测量的，但总的来说，最后还是等待很久。\n\n这就是为什么使用异步对于 Web API 很有意义的原因 ⏸🔀⏯。\n\n这种异步机制正是 NodeJS 受到欢迎的原因（尽管 NodeJS 不是并行的），以及 Go 作为编程语言的优势所在。\n\n这与 FastAPI 的性能水平相同。\n\n你可以同时拥有并行性和异步性，你可以获得比大多数经过测试的 NodeJS 框架更高的性能，并且与 Go 不相上下， Go 是一种更接近于 C 的编译语言（全部归功于 Starlette）。\n\n### 并发比并行好吗？\n\n不！这不是故事的本意。\n\n并发不同于并行。而是在需要大量等待的特定场景下效果更好。因此，在 Web 应用程序开发中，它通常比并行要好得多，但这并不意味着全部。\n\n因此，为了平衡这一点，想象一下下面的短篇故事：\n\n&gt; 你必须打扫一个又大又脏的房子。\n\n*是的，这就是完整的故事。*\n\n在任何地方， 都不需要等待 🕙 ，只需要在房子的多个地方做着很多工作。\n\n你可以像汉堡的例子那样轮流执行，先是客厅，然后是厨房，但因为你不需要等待 🕙 ，对于任何事情都是清洁，清洁，还是清洁，轮流不会影响任何事情。\n\n无论是否轮流执行（并发），都需要相同的时间来完成，而你也会完成相同的工作量。\n\n但在这种情况下，如果你能带上 8 名前收银员/厨师，现在是清洁工一起清扫，他们中的每一个人（加上你）都能占据房子的一个区域来清扫，你就可以在额外的帮助下并行的更快地完成所有工作。\n\n在这个场景中，每个清洁工（包括你）都将是一个处理器，完成这个工作的一部分。\n\n由于大多数执行时间是由实际工作（而不是等待）占用的，并且计算机中的工作是由 <abbr title=""Central Processing Unit"">CPU</abbr> 完成的，所以他们称这些问题为""CPU 密集型""。\n\nCPU 密集型操作的常见示例是需要复杂的数学处理。\n\n例如：\n\n* 音频或图像处理；\n* 计算机视觉: 一幅图像由数百万像素组成，每个像素有3种颜色值，处理通常需要同时对这些像素进行计算；\n* 机器学习: 它通常需要大量的""矩阵""和""向量""乘法。想象一个包含数字的巨大电子表格，并同时将所有数字相乘；\n* 深度学习: 这是机器学习的一个子领域，同样适用。只是没有一个数字的电子表格可以相乘，而是一个庞大的数字集合，在很多情况下，你需要使用一个特殊的处理器来构建和使用这些模型。\n\n### 并发 + 并行: Web + 机器学习\n\n使用 FastAPI，你可以利用 Web 开发中常见的并发机制的优势（NodeJS 的主要吸引力）。\n\n并且，你也可以利用并行和多进程（让多个进程并行运行）的优点来处理与机器学习系统中类似的 CPU 密集型 工作。\n\n这一点，再加上 Python 是数据科学、机器学习（尤其是深度学习）的主要语言这一简单事实，使得 FastAPI 与数据科学/机器学习 Web API 和应用程序（以及其他许多应用程序）非常匹配。\n\n了解如何在生产环境中实现这种并行性，可查看此文 [Deployment](deployment/index.md){.internal-link target=_blank}。\n\n## `async` 和 `await`\n\n现代版本的 Python 有一种非常直观的方式来定义异步代码。这使它看起来就像正常的""顺序""代码，并在适当的时候""等待""。\n\n当有一个操作需要等待才能给出结果，且支持这个新的 Python 特性时，你可以编写如下代码：\n\n```Python\nburgers = await get_burgers(2)\n```\n\n这里的关键是 `await`。它告诉 Python 它必须等待 ⏸ `get_burgers(2)` 完成它的工作 🕙 ，然后将结果存储在 `burgers` 中。这样，Python 就会知道此时它可以去做其他事情 🔀 ⏯ （比如接收另一个请求）。\n\n要使 `await` 工作，它必须位于支持这种异步机制的函数内。因此，只需使用 `async def` 声明它：\n\n```Python hl_lines=""1""\nasync def get_burgers(number: int):\n    # Do some asynchronous stuff to create the burgers\n    return burgers\n```\n\n...而不是 `def`:\n\n```Python hl_lines=""2""\n# This is not asynchronous\ndef get_sequential_burgers(number: int):\n    # Do some sequential stuff to create the burgers\n    return burgers\n```\n\n使用 `async def`，Python 就知道在该函数中，它将遇上 `await`，并且它可以""暂停"" ⏸ 执行该函数，直至执行其他操作 🔀 后回来。\n\n当你想调用一个 `async def` 函数时，你必须""等待""它。因此，这不会起作用：\n\n```Python\n# This won\'t work, because get_burgers was defined with: async def\nburgers = get_burgers(2)\n```\n\n因此，如果你使用的库告诉你可以使用 `await` 调用它，则需要使用 `async def` 创建路径操作函数 ，如：\n\n```Python hl_lines=""2-3""\n@app.get(\'/burgers\')\nasync def read_burgers():\n    burgers = await get_burgers(2)\n    return burgers\n```\n\n### 更多技术细节\n\n你可能已经注意到，`await` 只能在 `async def` 定义的函数内部使用。\n\n但与此同时，必须""等待""通过 `async def` 定义的函数。因此，带 `async def` 的函数也只能在 `async def` 定义的函数内部调用。\n\n那么，这关于先有鸡还是先有蛋的问题，如何调用第一个 `async` 函数？\n\n如果你使用 FastAPI，你不必担心这一点，因为""第一个""函数将是你的路径操作函数，FastAPI 将知道如何做正确的事情。\n\n但如果你想在没有 FastAPI 的情况下使用 `async` / `await`，则可以这样做。\n\n### 编写自己的异步代码\n\nStarlette （和 FastAPI） 是基于 AnyIO 实现的，这使得它们可以兼容 Python 的标准库 asyncio 和 Trio。\n\n特别是，你可以直接使用 AnyIO 来处理高级的并发用例，这些用例需要在自己的代码中使用更高级的模式。\n\n即使你没有使用 FastAPI，你也可以使用 AnyIO 编写自己的异步程序，使其拥有较高的兼容性并获得一些好处（例如， 结构化并发）。\n\n我（指原作者 —— 译者注）基于 AnyIO 新建了一个库，作为一个轻量级的封装层，用来优化类型注解，同时提供了更好的自动补全、内联错误提示等功能。这个库还附带了一个友好的入门指南和教程，能帮助你理解并编写自己的异步代码：Asyncer。如果你有结合使用异步代码和常规（阻塞/同步）代码的需求，这个库会特别有用。\n\n### 其他形式的异步代码\n\n这种使用 `async` 和 `await` 的风格在语言中相对较新。\n\n但它使处理异步代码变得容易很多。\n\n这种相同的语法（或几乎相同）最近也包含在现代版本的 JavaScript 中（在浏览器和 NodeJS 中）。\n\n但在此之前，处理异步代码非常复杂和困难。\n\n在以前版本的 Python，你可以使用多线程或者 Gevent。但代码的理解、调试和思考都要复杂许多。\n\n在以前版本的 NodeJS / 浏览器 JavaScript 中，你会使用""回调""，因此也可能导致“回调地狱”。\n\n## 协程\n\n协程只是 `async def` 函数返回的一个非常奇特的东西的称呼。Python 知道它有点像一个函数，它可以启动，也会在某个时刻结束，而且它可能会在内部暂停 ⏸ ，只要内部有一个 `await`。\n\n通过使用 `async` 和 `await` 的异步代码的所有功能大多数被概括为""协程""。它可以与 Go 的主要关键特性 ""Goroutines"" 相媲美。\n\n## 结论\n\n让我们再来回顾下上文所说的：\n\n&gt; Python 的现代版本可以通过使用 `async` 和 `await` 语法创建协程，并用于支持异步代码。\n\n现在应该能明白其含义了。✨\n\n所有这些使得 FastAPI（通过 Starlette）如此强大，也是它拥有如此令人印象深刻的性能的原因。\n\n## 非常技术性的细节\n\n/// warning\n\n你可以跳过这里。\n\n这些都是 FastAPI 如何在内部工作的技术细节。\n\n如果你有相当多的技术知识（协程、线程、阻塞等），并且对 FastAPI 如何处理 `async def` 与常规 `def` 感到好奇，请继续。\n\n///\n\n### 路径操作函数\n\n当你使用 `def` 而不是 `async def` 来声明一个*路径操作函数*时，它运行在外部的线程池中并等待其结果，而不是直接调用（因为它会阻塞服务器）。\n\n如果你使用过另一个不以上述方式工作的异步框架，并且你习惯于用普通的 `def` 定义普通的仅计算路径操作函数，以获得微小的性能增益（大约100纳秒），请注意，在 FastAPI 中，效果将完全相反。在这些情况下，最好使用 `async def`，除非路径操作函数内使用执行阻塞 <abbr title=""输入/输出：磁盘读写，网络通讯."">I/O</abbr> 的代码。\n\n在这两种情况下，与你之前的框架相比，FastAPI 可能[仍然很快](index.md#_11){.internal-link target=_blank}。\n\n### 依赖\n\n这同样适用于[依赖](tutorial/dependencies/index.md){.internal-link target=_blank}。如果一个依赖是标准的 `def` 函数而不是 `async def`，它将被运行在外部线程池中。\n\n### 子依赖\n\n你可以拥有多个相互依赖的依赖以及[子依赖](tutorial/dependencies/sub-dependencies.md){.internal-link target=_blank} （作为函数的参数），它们中的一些可能是通过 `async def` 声明，也可能是通过 `def` 声明。它们仍然可以正常工作，这些通过 `def` 声明的函数将会在外部线程中调用（来自线程池），而不是""被等待""。\n\n### 其他函数\n\n你可直接调用通过 `def` 或 `async def` 创建的任何其他函数，FastAPI 不会影响你调用它们的方式。\n\n这与 FastAPI 为你调用*路径操作函数*和依赖项的逻辑相反。\n\n如果你的函数是通过 `def` 声明的，它将被直接调用（在代码中编写的地方），而不会在线程池中，如果这个函数通过 `async def` 声明，当在代码中调用时，你就应该使用 `await` 等待函数的结果。\n\n再次提醒，这些是非常技术性的细节，如果你来搜索它可能对你有用。\n\n否则，你最好应该遵守的指导原则赶时间吗？.']","根据上下文，对于计算密集型任务（CPU密集型），应使用普通 `def` 而非 `async def`，因为异步机制主要优化I/O等待，对纯计算无增益。这与Node.js不同：Node.js单线程处理CPU任务会阻塞事件循环，而Python可通过多进程并行执行。具体建议：
1. **用 `def`**：避免阻塞事件循环，直接处理计算。
2. **与Node.js差异**：Node.js的CPU任务会阻塞主线程，Python可利用多进程绕过此限制。
3. **优化选择**：若任务无I/O操作，`def` 更高效；否则参考上下文规则。",对于计算密集型（CPU-bound）任务，你应该使用普通的 `def` 定义路由，或者使用 `run_in_process`。因为 `async def` 运行在主事件循环上，计算密集型任务会长时间占用 CPU，导致整个服务无法响应其他请求（阻塞 Loop）。这与 Node.js 类似，Node.js 也是单线程事件循环，如果进行繁重计算也会阻塞整个进程，通常需要 Worker Threads 来解决。但在 FastAPI 中，简单地使用 `def` 就能利用线程池，这通常足以应对非极端的计算需求。,0.9999999999,0.5454545454545454,0.943538619355898
我要记录请求处理时间，FastAPI 的中间件和依赖注入都能做拦截，选哪个更好？,"['# 中间件\n\n你可以向 FastAPI 应用添加中间件.\n\n""中间件""是一个函数,它在每个请求被特定的*路径操作*处理之前,以及在每个响应返回之前工作.\n\n* 它接收你的应用程序的每一个请求.\n* 然后它可以对这个请求做一些事情或者执行任何需要的代码.\n* 然后它将请求传递给应用程序的其他部分 (通过某种*路径操作*).\n* 然后它获取应用程序生产的响应 (通过某种*路径操作*).\n* 它可以对该响应做些什么或者执行任何需要的代码.\n* 然后它返回这个 响应.\n\n/// note | 技术细节\n\n如果你使用了 `yield` 关键字依赖, 依赖中的退出代码将在执行中间件*后*执行.\n\n如果有任何后台任务(稍后记录), 它们将在执行中间件*后*运行.\n\n///\n\n## 创建中间件\n\n要创建中间件你可以在函数的顶部使用装饰器 `@app.middleware(""http"")`.\n\n中间件参数接收如下参数:\n\n* `request`.\n* 一个函数 `call_next` 它将接收 `request` 作为参数.\n    * 这个函数将 `request` 传递给相应的 *路径操作*.\n    * 然后它将返回由相应的*路径操作*生成的 `response`.\n* 然后你可以在返回 `response` 前进一步修改它.\n\n\n```py\nimport time\n\nfrom fastapi import FastAPI, Request\n\napp = FastAPI()\n\n\n@app.middleware(""http"")\nasync def add_process_time_header(request: Request, call_next):\n    start_time = time.perf_counter()\n    response = await call_next(request)\n    process_time = time.perf_counter() - start_time\n    response.headers[""X-Process-Time""] = str(process_time)\n    return response\n\n```\n\n\n/// tip\n\n请记住可以 用\'X-\' 前缀添加专有自定义请求头.\n\n但是如果你想让浏览器中的客户端看到你的自定义请求头, 你需要把它们加到 CORS 配置 ([CORS (Cross-Origin Resource Sharing)](cors.md){.internal-link target=_blank}) 的 `expose_headers` 参数中,在 Starlette\'s CORS docs文档中.\n\n///\n\n/// note | 技术细节\n\n你也可以使用 `from starlette.requests import Request`.\n\nFastAPI 为了开发者方便提供了该对象. 但其实它直接来自于 Starlette.\n\n///\n\n### 在 `response` 的前和后\n\n在任何*路径操作*收到`request`前,可以添加要和请求一起运行的代码.\n\n也可以在*响应*生成但是返回之前添加代码.\n\n例如你可以添加自定义请求头 `X-Process-Time` 包含以秒为单位的接收请求和生成响应的时间:\n\n\n> *[Ref: Code file `tutorial001_py39.py` is already included above]*\n\n\n## 其他中间件\n\n你可以稍后在 [Advanced User Guide: Advanced Middleware](../advanced/middleware.md){.internal-link target=_blank}阅读更多关于中间件的教程.\n\n你将在下一节中学习如何使用中间件处理 <abbr title=""Cross-Origin Resource Sharing"">CORS</abbr> .', '# 依赖项\n\nFastAPI 提供了简单易用，但功能强大的<abbr title=""也称为组件、资源、提供者、服务、可注入项"">依赖注入</abbr>系统。\n\n这个依赖系统设计的简单易用，可以让开发人员轻松地把组件集成至 FastAPI。\n\n## 什么是「依赖注入」\n\n编程中的「依赖注入」是声明代码（本文中为*路径操作函数* ）运行所需的，或要使用的「依赖」的一种方式。\n\n然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n\n依赖注入常用于以下场景：\n\n* 共享业务逻辑（复用相同的代码逻辑）\n* 共享数据库连接\n* 实现安全、验证、角色权限\n* 等……\n\n上述场景均可以使用依赖注入，将代码重复最小化。\n\n## 第一步\n\n接下来，我们学习一个非常简单的例子，尽管它过于简单，不是很实用。\n\n但通过这个例子，您可以初步了解「依赖注入」的工作机制。\n\n### 创建依赖项\n\n首先，要关注的是依赖项。\n\n依赖项就是一个函数，且可以使用与*路径操作函数*相同的参数：\n\n\n```py\nfrom typing import Annotated, Union\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(\n    q: Union[str, None] = None, skip: int = 0, limit: int = 100\n):\n    return {""q"": q, ""skip"": skip, ""limit"": limit}\n\n\n@app.get(""/items/"")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n\n@app.get(""/users/"")\nasync def read_users(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n```\n\n\n大功告成。\n\n只用了2 行代码。\n\n依赖项函数的形式和结构与*路径操作函数*一样。\n\n因此，可以把依赖项当作没有「装饰器」（即，没有 `@app.get(""/some-path"")` ）的路径操作函数。\n\n依赖项可以返回各种内容。\n\n本例中的依赖项预期接收如下参数：\n\n* 类型为 `str` 的可选查询参数 `q`\n* 类型为 `int` 的可选查询参数 `skip`，默认值是 `0`\n* 类型为 `int` 的可选查询参数 `limit`，默认值是 `100`\n\n然后，依赖项函数返回包含这些值的 `dict`。\n\n### 导入 `Depends`\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n### 声明依赖项\n\n与在*路径操作函数*参数中使用 `Body`、`Query` 的方式相同，声明依赖项需要使用 `Depends` 和一个新的参数：\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n虽然，在路径操作函数的参数中使用 `Depends` 的方式与 `Body`、`Query` 相同，但 `Depends` 的工作方式略有不同。\n\n这里只能传给 Depends 一个参数。\n\n且该参数必须是可调用对象，比如函数。\n\n该函数接收的参数和*路径操作函数*的参数一样。\n\n/// tip | 提示\n\n下一章介绍，除了函数还有哪些「对象」可以用作依赖项。\n\n///\n\n接收到新的请求时，FastAPI 执行如下操作：\n\n* 用正确的参数调用依赖项函数（「可依赖项」）\n* 获取函数返回的结果\n* 把函数返回的结果赋值给*路径操作函数*的参数\n\n```mermaid\ngraph TB\n\ncommon_parameters([""common_parameters""])\nread_items[""/items/""]\nread_users[""/users/""]\n\ncommon_parameters --&gt; read_items\ncommon_parameters --&gt; read_users\n```\n\n这样，只编写一次代码，FastAPI 就可以为多个*路径操作*共享这段代码 。\n\n/// check | 检查\n\n注意，无需创建专门的类，并将之传递给 FastAPI 以进行「注册」或执行类似的操作。\n\n只要把它传递给 `Depends`，FastAPI 就知道该如何执行后续操作。\n\n///\n\n## 要不要使用 `async`？\n\nFastAPI 调用依赖项的方式与*路径操作函数*一样，因此，定义依赖项函数，也要应用与路径操作函数相同的规则。\n\n即，既可以使用异步的 `async def`，也可以使用普通的 `def` 定义依赖项。\n\n在普通的 `def` *路径操作函数*中，可以声明异步的 `async def` 依赖项；也可以在异步的 `async def` *路径操作函数*中声明普通的 `def` 依赖项。\n\n上述这些操作都是可行的，FastAPI 知道该怎么处理。\n\n/// note | 笔记\n\n如里不了解异步，请参阅[异步：*“着急了？”*](../../async.md){.internal-link target=_blank} 一章中 `async` 和 `await` 的内容。\n\n///\n\n## 与 OpenAPI 集成\n\n依赖项及子依赖项的所有请求声明、验证和需求都可以集成至同一个 OpenAPI 概图。\n\n所以，交互文档里也会显示依赖项的所有信息：\n\n## 简单用法\n\n观察一下就会发现，只要*路径* 和*操作*匹配，就可以使用声明的路径操作函数。然后，FastAPI 会用正确的参数调用函数，并提取请求中的数据。\n\n实际上，所有（或大多数）网络框架的工作方式都是这样的。\n\n开发人员永远都不需要直接调用这些函数，这些函数是由框架（在此为 FastAPI ）调用的。\n\n通过依赖注入系统，只要告诉 FastAPI *路径操作函数* 还要「依赖」其他在*路径操作函数*之前执行的内容，FastAPI 就会执行函数代码，并「注入」函数返回的结果。\n\n其他与「依赖注入」概念相同的术语为：\n\n* 资源（Resource）\n* 提供方（Provider）\n* 服务（Service）\n* 可注入（Injectable）\n* 组件（Component）\n\n## FastAPI 插件\n\n依赖注入系统支持构建集成和「插件」。但实际上，FastAPI 根本不需要创建「插件」，因为使用依赖项可以声明不限数量的、可用于*路径操作函数*的集成与交互。\n\n创建依赖项非常简单、直观，并且还支持导入 Python 包。毫不夸张地说，只要几行代码就可以把需要的 Python 包与 API 函数集成在一起。\n\n下一章将详细介绍在关系型数据库、NoSQL 数据库、安全等方面使用依赖项的例子。\n\n## FastAPI 兼容性\n\n依赖注入系统如此简洁的特性，让 FastAPI 可以与下列系统兼容：\n\n* 关系型数据库\n* NoSQL 数据库\n* 外部支持库\n* 外部 API\n* 认证和鉴权系统\n* API 使用监控系统\n* 响应数据注入系统\n* 等等……\n\n## 简单而强大\n\n虽然，层级式依赖注入系统的定义与使用十分简单，但它却非常强大。\n\n比如，可以定义依赖其他依赖项的依赖项。\n\n最后，依赖项层级树构建后，依赖注入系统会处理所有依赖项及其子依赖项，并为每一步操作提供（注入）结果。\n\n比如，下面有 4 个 API 路径操作（*端点*）：\n\n* `/items/public/`\n* `/items/private/`\n* `/users/{user_id}/activate`\n* `/items/pro/`\n\n开发人员可以使用依赖项及其子依赖项为这些路径操作添加不同的权限：\n\n```mermaid\ngraph TB\n\ncurrent_user([""current_user""])\nactive_user([""active_user""])\nadmin_user([""admin_user""])\npaying_user([""paying_user""])\n\npublic[""/items/public/""]\nprivate[""/items/private/""]\nactivate_user[""/users/{user_id}/activate""]\npro_items[""/items/pro/""]\n\ncurrent_user --&gt; active_user\nactive_user --&gt; admin_user\nactive_user --&gt; paying_user\n\ncurrent_user --&gt; public\nactive_user --&gt; private\nadmin_user --&gt; activate_user\npaying_user --&gt; pro_items\n```\n\n## 与 OpenAPI 集成\n\n在声明需求时，所有这些依赖项还会把参数、验证等功能添加至路径操作。\n\nFastAPI 负责把上述内容全部添加到 OpenAPI 概图，并显示在交互文档中。', '# 高级中间件\n\n用户指南介绍了如何为应用添加[自定义中间件](../tutorial/middleware.md){.internal-link target=_blank} 。\n\n以及如何[使用 `CORSMiddleware` 处理 CORS](../tutorial/cors.md){.internal-link target=_blank}。\n\n本章学习如何使用其它中间件。\n\n## 添加 ASGI 中间件\n\n因为 FastAPI 基于 Starlette，且执行 <abbr title=""Asynchronous Server Gateway Interface，异步服务器网关界面"">ASGI</abbr> 规范，所以可以使用任意 ASGI 中间件。\n\n中间件不必是专为 FastAPI 或 Starlette 定制的，只要遵循 ASGI 规范即可。\n\n总之，ASGI 中间件是类，并把 ASGI 应用作为第一个参数。\n\n因此，有些第三方 ASGI 中间件的文档推荐以如下方式使用中间件：\n\n```Python\nfrom unicorn import UnicornMiddleware\n\napp = SomeASGIApp()\n\nnew_app = UnicornMiddleware(app, some_config=""rainbow"")\n```\n\n但 FastAPI（实际上是 Starlette）提供了一种更简单的方式，能让内部中间件在处理服务器错误的同时，还能让自定义异常处理器正常运作。\n\n为此，要使用 `app.add_middleware()` （与 CORS 中的示例一样）。\n\n```Python\nfrom fastapi import FastAPI\nfrom unicorn import UnicornMiddleware\n\napp = FastAPI()\n\napp.add_middleware(UnicornMiddleware, some_config=""rainbow"")\n```\n\n`app.add_middleware()` 的第一个参数是中间件的类，其它参数则是要传递给中间件的参数。\n\n## 集成中间件\n\nFastAPI 为常见用例提供了一些中间件，下面介绍怎么使用这些中间件。\n\n/// note | 技术细节\n\n以下几个示例中也可以使用 `from starlette.middleware.something import SomethingMiddleware`。\n\nFastAPI 在 `fastapi.middleware` 中提供的中间件只是为了方便开发者使用，但绝大多数可用的中间件都直接继承自 Starlette。\n\n///\n\n## `HTTPSRedirectMiddleware`\n\n强制所有传入请求必须是 `https` 或 `wss`。\n\n任何传向 `http` 或 `ws` 的请求都会被重定向至安全方案。\n\n\n```py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware\n\napp = FastAPI()\n\napp.add_middleware(HTTPSRedirectMiddleware)\n\n\n@app.get(""/"")\nasync def main():\n    return {""message"": ""Hello World""}\n\n```\n\n\n## `TrustedHostMiddleware`\n\n强制所有传入请求都必须正确设置 `Host` 请求头，以防 HTTP 主机头攻击。\n\n\n```py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\n\napp = FastAPI()\n\napp.add_middleware(\n    TrustedHostMiddleware, allowed_hosts=[""example.com"", ""*.example.com""]\n)\n\n\n@app.get(""/"")\nasync def main():\n    return {""message"": ""Hello World""}\n\n```\n\n\n支持以下参数：\n\n* `allowed_hosts` - 允许的域名（主机名）列表。`*.example.com` 等通配符域名可以匹配子域名，或使用 `allowed_hosts=[""*""]` 允许任意主机名，或省略中间件。\n\n如果传入的请求没有通过验证，则发送 `400` 响应。\n\n## `GZipMiddleware`\n\n处理 `Accept-Encoding` 请求头中包含 `gzip` 请求的 GZip 响应。\n\n中间件会处理标准响应与流响应。\n\n\n```py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.gzip import GZipMiddleware\n\napp = FastAPI()\n\napp.add_middleware(GZipMiddleware, minimum_size=1000, compresslevel=5)\n\n\n@app.get(""/"")\nasync def main():\n    return ""somebigcontent""\n\n```\n\n\n支持以下参数：\n\n* `minimum_size` - 小于最小字节的响应不使用 GZip。 默认值是 `500`。\n\n## 其它中间件\n\n除了上述中间件外，FastAPI 还支持其它ASGI 中间件。\n\n例如：\n\n* Uvicorn 的\xa0`ProxyHeadersMiddleware`\n* MessagePack\n\n其它可用中间件详见 Starlette\xa0官档\xa0-\xa0\xa0中间件 及 ASGI Awesome 列表。']","根据上下文，**推荐使用中间件**记录请求处理时间：  

1. 中间件能全局拦截所有请求和响应，适合统一添加处理时间（如示例中的`X-Process-Time`头）。  
2. 依赖注入更适合针对特定路径操作的逻辑复用（如参数校验），而非全局拦截。  
3. 中间件能直接访问请求/响应完整生命周期，计时逻辑更简洁（见示例代码）。",如果目的是记录整个请求的处理时间（包括序列化、验证和网络传输），应该选择中间件（Middleware）（如 `BaseHTTPMiddleware`）。因为中间件作用于请求-响应的整个生命周期，能够捕获从请求到达服务器到响应发送回客户端的完整耗时。而依赖注入（Dependencies）通常在路由匹配和部分验证之后才执行，且无法轻易捕获响应发送后的时间点。,0.8333333332916666,0.8571428571428571,0.8542702364472818
我有一个字段既可以是 int 也可以是 float，甚至有时候是 string，怎么定义 Schema 能让它通过校验？,"['# 请求体 - 字段\n\n与在*路径操作函数*中使用 `Query`、`Path` 、`Body` 声明校验与元数据的方式一样，可以使用 Pydantic 的 `Field` 在 Pydantic 模型内部声明校验和元数据。\n\n## 导入 `Field`\n\n首先，从 Pydantic 中导入 `Field`：\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import Body, FastAPI\nfrom pydantic import BaseModel, Field\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = Field(\n        default=None, title=""The description of the item"", max_length=300\n    )\n    price: float = Field(gt=0, description=""The price must be greater than zero"")\n    tax: float | None = None\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n/// warning | 警告\n\n注意，与从 `fastapi` 导入 `Query`，`Path`、`Body` 不同，要直接从 `pydantic` 导入 `Field` 。\n\n///\n\n## 声明模型属性\n\n然后，使用 `Field` 定义模型的属性：\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*\n\n\n`Field` 的工作方式和 `Query`、`Path`、`Body` 相同，参数也相同。\n\n/// note | 技术细节\n\n实际上，`Query`、`Path` 都是 `Params` 的子类，而 `Params` 类又是 Pydantic 中 `FieldInfo` 的子类。\n\nPydantic 的 `Field` 返回也是 `FieldInfo` 的类实例。\n\n`Body` 直接返回的也是 `FieldInfo` 的子类的对象。后文还会介绍一些 `Body` 的子类。\n\n注意，从 `fastapi` 导入的 `Query`、`Path` 等对象实际上都是返回特殊类的函数。\n\n///\n\n/// tip | 提示\n\n注意，模型属性的类型、默认值及 `Field` 的代码结构与*路径操作函数*的参数相同，只不过是用 `Field` 替换了`Path`、`Query`、`Body`。\n\n///\n\n## 添加更多信息\n\n`Field`、`Query`、`Body` 等对象里可以声明更多信息，并且 JSON Schema 中也会集成这些信息。\n\n*声明示例*一章中将详细介绍添加更多信息的知识。\n\n## 小结\n\nPydantic 的 `Field` 可以为模型属性声明更多校验和元数据。\n\n传递 JSON Schema 元数据还可以使用更多关键字参数。', '# 请求体 - 嵌套模型\n\n使用 FastAPI，你可以定义、校验、记录文档并使用任意深度嵌套的模型（归功于Pydantic）。\n\n## List 字段\n\n你可以将一个属性定义为拥有子元素的类型。例如 Python `list`：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: list = []\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n这将使 `tags` 成为一个由元素组成的列表。不过它没有声明每个元素的类型。\n\n## 具有子类型的 List 字段\n\n但是 Python 有一种特定的方法来声明具有子类型的列表：\n\n### 从 typing 导入 `List`\n\n首先，从 Python 的标准库 `typing` 模块中导入 `List`：\n\n\n```py\nfrom typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: Union[float, None] = None\n    tags: list[str] = []\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n### 声明具有子类型的 List\n\n要声明具有子类型的类型，例如 `list`、`dict`、`tuple`：\n\n* 从 `typing` 模块导入它们\n* 使用方括号 `[` 和 `]` 将子类型作为「类型参数」传入\n\n```Python\nfrom typing import List\n\nmy_list: List[str]\n```\n\n这完全是用于类型声明的标准 Python 语法。\n\n对具有子类型的模型属性也使用相同的标准语法。\n\n因此，在我们的示例中，我们可以将 `tags` 明确地指定为一个「字符串列表」：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: list[str] = []\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n## Set 类型\n\n但是随后我们考虑了一下，意识到标签不应该重复，它们很大可能会是唯一的字符串。\n\nPython 具有一种特殊的数据类型来保存一组唯一的元素，即 `set`。\n\n然后我们可以导入 `Set` 并将 `tag` 声明为一个由 `str` 组成的 `set`：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n这样，即使你收到带有重复数据的请求，这些数据也会被转换为一组唯一项。\n\n而且，每当你输出该数据时，即使源数据有重复，它们也将作为一组唯一项输出。\n\n并且还会被相应地标注 / 记录文档。\n\n## 嵌套模型\n\nPydantic 模型的每个属性都具有类型。\n\n但是这个类型本身可以是另一个 Pydantic 模型。\n\n因此，你可以声明拥有特定属性名称、类型和校验的深度嵌套的 JSON 对象。\n\n上述这些都可以任意的嵌套。\n\n### 定义子模型\n\n例如，我们可以定义一个 `Image` 模型：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: str\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n    image: Image | None = None\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n### 将子模型用作类型\n\n然后我们可以将其用作一个属性的类型：\n\n\n> *[Ref: Code file `tutorial004_py310.py` is already included above]*\n\n\n这意味着 FastAPI 将期望类似于以下内容的请求体：\n\n```JSON\n{\n    ""name"": ""Foo"",\n    ""description"": ""The pretender"",\n    ""price"": 42.0,\n    ""tax"": 3.2,\n    ""tags"": [""rock"", ""metal"", ""bar""],\n    ""image"": {\n        ""url"": ""http://example.com/baz.jpg"",\n        ""name"": ""The Foo live""\n    }\n}\n```\n\n再一次，仅仅进行这样的声明，你将通过 FastAPI 获得：\n\n* 对被嵌入的模型也适用的编辑器支持（自动补全等）\n* 数据转换\n* 数据校验\n* 自动生成文档\n\n## 特殊的类型和校验\n\n除了普通的单一值类型（如 `str`、`int`、`float` 等）外，你还可以使用从 `str` 继承的更复杂的单一值类型。\n\n要了解所有的可用选项，请查看关于 来自 Pydantic 的外部类型 的文档。你将在下一章节中看到一些示例。\n\n例如，在 `Image` 模型中我们有一个 `url` 字段，我们可以把它声明为 Pydantic 的 `HttpUrl`，而不是 `str`：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n    image: Image | None = None\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n该字符串将被检查是否为有效的 URL，并在 JSON Schema / OpenAPI 文档中进行记录。\n\n## 带有一组子模型的属性\n\n你还可以将 Pydantic 模型用作 `list`、`set` 等的子类型：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n    images: list[Image] | None = None\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n这将期望（转换，校验，记录文档等）下面这样的 JSON 请求体：\n\n```JSON hl_lines=""11""\n{\n    ""name"": ""Foo"",\n    ""description"": ""The pretender"",\n    ""price"": 42.0,\n    ""tax"": 3.2,\n    ""tags"": [\n        ""rock"",\n        ""metal"",\n        ""bar""\n    ],\n    ""images"": [\n        {\n            ""url"": ""http://example.com/baz.jpg"",\n            ""name"": ""The Foo live""\n        },\n        {\n            ""url"": ""http://example.com/dave.jpg"",\n            ""name"": ""The Baz""\n        }\n    ]\n}\n```\n\n/// info\n\n请注意 `images` 键现在具有一组 image 对象是如何发生的。\n\n///\n\n## 深度嵌套模型\n\n你可以定义任意深度的嵌套模型：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n    images: list[Image] | None = None\n\n\nclass Offer(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    items: list[Item]\n\n\n@app.post(""/offers/"")\nasync def create_offer(offer: Offer):\n    return offer\n\n```\n\n\n/// info\n\n请注意 `Offer` 拥有一组 `Item` 而反过来 `Item` 又是一个可选的 `Image` 列表是如何发生的。\n\n///\n\n## 纯列表请求体\n\n如果你期望的 JSON 请求体的最外层是一个 JSON `array`（即 Python `list`），则可以在路径操作函数的参数中声明此类型，就像声明 Pydantic 模型一样：\n\n```Python\nimages: List[Image]\n```\n\n例如：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\n@app.post(""/images/multiple/"")\nasync def create_multiple_images(images: list[Image]):\n    return images\n\n```\n\n\n## 无处不在的编辑器支持\n\n你可以随处获得编辑器支持。\n\n即使是列表中的元素：\n\n如果你直接使用 `dict` 而不是 Pydantic 模型，那你将无法获得这种编辑器支持。\n\n但是你根本不必担心这两者，传入的字典会自动被转换，你的输出也会自动被转换为 JSON。\n\n## 任意 `dict` 构成的请求体\n\n你也可以将请求体声明为使用某类型的键和其他类型值的 `dict`。\n\n无需事先知道有效的字段/属性（在使用 Pydantic 模型的场景）名称是什么。\n\n如果你想接收一些尚且未知的键，这将很有用。\n\n其他有用的场景是当你想要接收其他类型的键时，例如 `int`。\n\n这也是我们在接下来将看到的。\n\n在下面的例子中，你将接受任意键为 `int` 类型并且值为 `float` 类型的 `dict`：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.post(""/index-weights/"")\nasync def create_index_weights(weights: dict[int, float]):\n    return weights\n\n```\n\n\n/// tip\n\n请记住 JSON 仅支持将 `str` 作为键。\n\n但是 Pydantic 具有自动转换数据的功能。\n\n这意味着，即使你的 API 客户端只能将字符串作为键发送，只要这些字符串内容仅包含整数，Pydantic 就会对其进行转换并校验。\n\n然后你接收的名为 `weights` 的 `dict` 实际上将具有 `int` 类型的键和 `float` 类型的值。\n\n///\n\n## 总结\n\n使用 FastAPI 你可以拥有 Pydantic 模型提供的极高灵活性，同时保持代码的简单、简短和优雅。\n\n而且还具有下列好处：\n\n* 编辑器支持（处处皆可自动补全！）\n* 数据转换（也被称为解析/序列化）\n* 数据校验\n* 模式文档\n* 自动生成的文档', '# 额外数据类型\n\n到目前为止，您一直在使用常见的数据类型，如:\n\n* `int`\n* `float`\n* `str`\n* `bool`\n\n但是您也可以使用更复杂的数据类型。\n\n您仍然会拥有现在已经看到的相同的特性:\n\n* 很棒的编辑器支持。\n* 传入请求的数据转换。\n* 响应数据转换。\n* 数据验证。\n* 自动补全和文档。\n\n## 其他数据类型\n\n下面是一些你可以使用的其他数据类型:\n\n* `UUID`:\n    * 一种标准的 ""通用唯一标识符"" ，在许多数据库和系统中用作ID。\n    * 在请求和响应中将以 `str` 表示。\n* `datetime.datetime`:\n    * 一个 Python `datetime.datetime`.\n    * 在请求和响应中将表示为 ISO 8601 格式的 `str` ，比如: `2008-09-15T15:53:00+05:00`.\n* `datetime.date`:\n    * Python `datetime.date`.\n    * 在请求和响应中将表示为 ISO 8601 格式的 `str` ，比如: `2008-09-15`.\n* `datetime.time`:\n    * 一个 Python `datetime.time`.\n    * 在请求和响应中将表示为 ISO 8601 格式的 `str` ，比如:  `14:23:55.003`.\n* `datetime.timedelta`:\n    * 一个 Python `datetime.timedelta`.\n    * 在请求和响应中将表示为 `float` 代表总秒数。\n    * Pydantic 也允许将其表示为 ""ISO 8601 时间差异编码"", 查看文档了解更多信息。\n* `frozenset`:\n    * 在请求和响应中，作为 `set` 对待：\n        * 在请求中，列表将被读取，消除重复，并将其转换为一个 `set`。\n        * 在响应中 `set` 将被转换为 `list` 。\n        * 产生的模式将指定那些 `set` 的值是唯一的 (使用 JSON 模式的 `uniqueItems`)。\n* `bytes`:\n    * 标准的 Python `bytes`。\n    * 在请求和响应中被当作 `str` 处理。\n    * 生成的模式将指定这个 `str` 是 `binary` ""格式""。\n* `Decimal`:\n    * 标准的 Python `Decimal`。\n    * 在请求和响应中被当做 `float` 一样处理。\n* 您可以在这里检查所有有效的pydantic数据类型: Pydantic data types.\n\n## 例子\n\n下面是一个*路径操作*的示例，其中的参数使用了上面的一些类型。\n\n\n```py\nfrom datetime import datetime, time, timedelta\nfrom typing import Annotated\nfrom uuid import UUID\n\nfrom fastapi import Body, FastAPI\n\napp = FastAPI()\n\n\n@app.put(""/items/{item_id}"")\nasync def read_items(\n    item_id: UUID,\n    start_datetime: Annotated[datetime, Body()],\n    end_datetime: Annotated[datetime, Body()],\n    process_after: Annotated[timedelta, Body()],\n    repeat_at: Annotated[time | None, Body()] = None,\n):\n    start_process = start_datetime + process_after\n    duration = end_datetime - start_process\n    return {\n        ""item_id"": item_id,\n        ""start_datetime"": start_datetime,\n        ""end_datetime"": end_datetime,\n        ""process_after"": process_after,\n        ""repeat_at"": repeat_at,\n        ""start_process"": start_process,\n        ""duration"": duration,\n    }\n\n```\n\n\n注意，函数内的参数有原生的数据类型，你可以，例如，执行正常的日期操作，如:\n\n\n> *[Ref: Code file `tutorial001_an_py310.py` is already included above]*']","根据上下文，可以使用Pydantic的`Union`类型（或Python 3.10的 `|` 运算符）定义多类型字段。示例：
```python
from pydantic import BaseModel
from typing import Union

class MyModel(BaseModel):
    mixed_field: Union[int, float, str]  # 同时支持int/float/string
```

若需默认值或校验规则，可结合`Field`使用：
```python
mixed_field: Union[int, float, str] = Field(default=0, description=""支持多种类型"")
```","你可以使用 Python `typing` 模块中的 `Union` 类型。在 Pydantic 模型中，将字段定义为 `Union[int, float, str]`。Pydantic 会按照定义的顺序尝试进行类型校验和转换。如果一定要接收任意类型，可以使用 `Any`，但这会失去校验的意义。对于复杂的条件校验，还可以结合 Pydantic 的 `validator` 装饰器进行自定义逻辑判断。",0.49999999995,0.42857142857142855,0.6208973703305943
我想在服务器启动前预加载一个很大的机器学习模型到内存里，服务关闭时再释放掉，代码应该写在哪里？,"['# 生命周期事件\n\n你可以定义在应用启动前执行的逻辑（代码）。这意味着在应用开始接收请求之前，这些代码只会被执行一次。\n\n同样地，你可以定义在应用关闭时应执行的逻辑。在这种情况下，这段代码将在处理可能的多次请求后执行一次。\n\n因为这段代码在应用开始接收请求之前执行，也会在处理可能的若干请求之后执行，它覆盖了整个应用程序的生命周期（""生命周期""这个词很重要😉）。\n\n这对于设置你需要在整个应用中使用的资源非常有用，这些资源在请求之间共享，你可能需要在之后进行释放。例如，数据库连接池，或加载一个共享的机器学习模型。\n\n## 用例\n\n让我们从一个示例用例开始，看看如何解决它。\n\n假设你有几个机器学习的模型，你想要用它们来处理请求。\n\n相同的模型在请求之间是共享的，因此并非每个请求或每个用户各自拥有一个模型。\n\n假设加载模型可能需要相当长的时间，因为它必须从磁盘读取大量数据。因此你不希望每个请求都加载它。\n\n你可以在模块/文件的顶部加载它，但这也意味着即使你只是在运行一个简单的自动化测试，它也会加载模型，这样测试将变慢，因为它必须在能够独立运行代码的其他部分之前等待模型加载完成。\n\n这就是我们要解决的问题——在处理请求前加载模型，但只是在应用开始接收请求前，而不是代码执行时。\n\n## 生命周期 lifespan\n\n你可以使用`FastAPI()`应用的`lifespan`参数和一个上下文管理器（稍后我将为你展示）来定义启动和关闭的逻辑。\n\n让我们从一个例子开始，然后详细介绍。\n\n我们使用`yield`创建了一个异步函数`lifespan()`像这样：\n\n```Python hl_lines=""16  19""\n{!../../docs_src/events/tutorial003.py!}\n```\n\n在这里，我们在 `yield` 之前将（虚拟的）模型函数放入机器学习模型的字典中，以此模拟加载模型的耗时启动操作。这段代码将在应用程序开始处理请求之前执行，即启动期间。\n\n然后，在 `yield` 之后，我们卸载模型。这段代码将会在应用程序完成处理请求后执行，即在关闭之前。这可以释放诸如内存或 GPU 之类的资源。\n\n/// tip | 提示\n\n关闭事件只会在你停止应用时触发。\n\n可能你需要启动一个新版本，或者你只是你厌倦了运行它。 🤷\n\n///\n\n## 生命周期函数\n\n首先要注意的是，我们定义了一个带有 `yield` 的异步函数。这与带有 `yield` 的依赖项非常相似。\n\n```Python hl_lines=""14-19""\n{!../../docs_src/events/tutorial003.py!}\n```\n\n这个函数在 `yield`之前的部分，会在应用启动前执行。\n\n剩下的部分在 `yield` 之后，会在应用完成后执行。\n\n## 异步上下文管理器\n\n如你所见，这个函数有一个装饰器 `@asynccontextmanager` 。\n\n它将函数转化为所谓的“异步上下文管理器”。\n\n```Python hl_lines=""1  13""\n{!../../docs_src/events/tutorial003.py!}\n```\n\n在 Python 中，  上下文管理器是一个你可以在 `with` 语句中使用的东西，例如，`open()` 可以作为上下文管理器使用。\n\n```Python\nwith open(""file.txt"") as file:\n    file.read()\n```\n\nPython 的最近几个版本也有了一个异步上下文管理器，你可以通过 `async with` 来使用：\n\n```Python\nasync with lifespan(app):\n    await do_stuff()\n```\n\n你可以像上面一样创建了一个上下文管理器或者异步上下文管理器，它的作用是在进入 `with` 块时，执行 `yield` 之前的代码，并且在离开 `with` 块时，执行 `yield` 后面的代码。\n\n但在我们上面的例子里，我们并不是直接使用，而是传递给 FastAPI 来供其使用。\n\n`FastAPI()` 的 `lifespan` 参数接受一个异步上下文管理器，所以我们可以把我们新定义的上下文管理器 `lifespan` 传给它。\n\n```Python hl_lines=""22""\n{!../../docs_src/events/tutorial003.py!}\n```\n\n## 替代事件（弃用）\n\n/// warning | 警告\n\n配置启动和关闭事件的推荐方法是使用 `FastAPI()` 应用的 `lifespan` 参数，如前所示。如果你提供了一个 `lifespan` 参数，启动（`startup`）和关闭（`shutdown`）事件处理器将不再生效。要么使用 `lifespan`，要么配置所有事件，两者不能共用。\n\n你可以跳过这一部分。\n\n///\n\n有一种替代方法可以定义在启动和关闭期间执行的逻辑。\n\nFastAPI 支持定义在应用启动前，或应用关闭时执行的事件处理器（函数）。\n\n事件函数既可以声明为异步函数（`async def`），也可以声明为普通函数（`def`）。\n\n### `startup` 事件\n\n使用 `startup` 事件声明 `app` 启动前运行的函数：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nitems = {}\n\n\n@app.on_event(""startup"")\nasync def startup_event():\n    items[""foo""] = {""name"": ""Fighters""}\n    items[""bar""] = {""name"": ""Tenders""}\n\n\n@app.get(""/items/{item_id}"")\nasync def read_items(item_id: str):\n    return items[item_id]\n\n```\n\n\n本例中，`startup` 事件处理器函数为项目数据库（只是字典）提供了一些初始值。\n\nFastAPI 支持多个事件处理器函数。\n\n只有所有 `startup` 事件处理器运行完毕，FastAPI 应用才开始接收请求。\n\n### `shutdown` 事件\n\n使用 `shutdown` 事件声明 `app` 关闭时运行的函数：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.on_event(""shutdown"")\ndef shutdown_event():\n    with open(""log.txt"", mode=""a"") as log:\n        log.write(""Application shutdown"")\n\n\n@app.get(""/items/"")\nasync def read_items():\n    return [{""name"": ""Foo""}]\n\n```\n\n\n此处，`shutdown` 事件处理器函数在 `log.txt` 中写入一行文本 `Application shutdown`。\n\n/// info | 说明\n\n`open()` 函数中，`mode=""a""` 指的是追加。因此这行文本会添加在文件已有内容之后，不会覆盖之前的内容。\n\n///\n\n/// tip | 提示\n\n注意，本例使用 Python `open()` 标准函数与文件交互。\n\n这个函数执行 I/O（输入/输出）操作，需要等待内容写进磁盘。\n\n但 `open()` 函数不支持使用 `async` 与 `await`。\n\n因此，声明事件处理函数要使用 `def`，不能使用 `asnyc def`。\n\n///\n\n### `startup` 和 `shutdown` 一起使用\n\n启动和关闭的逻辑很可能是连接在一起的，你可能希望启动某个东西然后结束它，获取一个资源然后释放它等等。\n\n在不共享逻辑或变量的不同函数中处理这些逻辑比较困难，因为你需要在全局变量中存储值或使用类似的方式。\n\n因此，推荐使用 `lifespan` 。\n\n## 技术细节\n\n只是为好奇者提供的技术细节。🤓\n\n在底层，这部分是生命周期协议的一部分，参见 ASGI 技术规范，定义了称为启动（`startup`）和关闭（`shutdown`）的事件。\n\n/// info | 说明\n\n有关事件处理器的详情，请参阅 Starlette 官档 - 事件。\n\n包括如何处理生命周期状态，这可以用于程序的其他部分。\n\n///\n\n## 子应用\n\n🚨  FastAPI 只会触发主应用中的生命周期事件，不包括[子应用 - 挂载](sub-applications.md){.internal-link target=_blank}中的。', '# 部署概念\n\n在部署 FastAPI 应用程序或任何类型的 Web API 时，有几个概念值得了解，通过掌握这些概念您可以找到最合适的方法来部署您的应用程序。\n\n一些重要的概念是：\n\n* 安全性 - HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 开始前的先前步骤\n\n我们接下来了解它们将如何影响部署。\n\n我们的最终目标是能够以安全的方式为您的 API 客户端提供服务，同时要避免中断，并且尽可能高效地利用计算资源（ 例如服务器CPU资源）。 🚀\n\n我将在这里告诉您更多关于这些概念的信息，希望能给您提供直觉来决定如何在非常不同的环境中部署 API，甚至在是尚不存在的未来的环境里。\n\n通过考虑这些概念，您将能够评估和设计部署您自己的 API的最佳方式。\n\n在接下来的章节中，我将为您提供更多部署 FastAPI 应用程序的具体方法。\n\n但现在，让我们仔细看一下这些重要的概念。 这些概念也适用于任何其他类型的 Web API。 💡\n\n## 安全性 - HTTPS\n\n在[上一章有关 HTTPS](https.md){.internal-link target=_blank} 中，我们了解了 HTTPS 如何为您的 API 提供加密。\n\n我们还看到，HTTPS 通常由应用程序服务器的外部组件（TLS 终止代理）提供。\n\n并且必须有某个东西负责更新 HTTPS 证书，它可以是相同的组件，也可以是不同的组件。\n\n### HTTPS 示例工具\n\n您可以用作 TLS 终止代理的一些工具包括：\n\n* Traefik\n     * 自动处理证书更新 ✨\n* Caddy\n     * 自动处理证书更新 ✨\n* Nginx\n     * 使用 Certbot 等外部组件进行证书更新\n* HAProxy\n     * 使用 Certbot 等外部组件进行证书更新\n* 带有 Ingress Controller(如Nginx) 的 Kubernetes\n     * 使用诸如 cert-manager 之类的外部组件来进行证书更新\n* 由云服务商内部处理，作为其服务的一部分（请阅读下文👇）\n\n另一种选择是您可以使用云服务来完成更多工作，包括设置 HTTPS。 它可能有一些限制或向您收取更多费用等。但在这种情况下，您不必自己设置 TLS 终止代理。\n\n我将在接下来的章节中向您展示一些具体示例。\n\n接下来要考虑的概念都是关于运行实际 API 的程序（例如 Uvicorn）。\n\n## 程序和进程\n\n我们将讨论很多关于正在运行的“进程”的内容，因此弄清楚它的含义以及与“程序”这个词有什么区别是很有用的。\n\n### 什么是程序\n\n程序这个词通常用来描述很多东西：\n\n* 您编写的 代码，Python 文件。\n* 操作系统可以执行的文件，例如：`python`、`python.exe`或`uvicorn`。\n* 在操作系统上运行、使用CPU 并将内容存储在内存上的特定程序。 这也被称为进程。\n\n### 什么是进程\n\n进程 这个词通常以更具体的方式使用，仅指在操作系统中运行的东西（如上面的最后一点）：\n\n* 在操作系统上运行的特定程序。\n     * 这不是指文件，也不是指代码，它具体指的是操作系统正在执行和管理的东西。\n* 任何程序，任何代码，只有在执行时才能做事。 因此，是当有进程正在运行时。\n* 该进程可以由您或操作系统终止（或“杀死”）。 那时，它停止运行/被执行，并且它可以不再做事情。\n* 您计算机上运行的每个应用程序背后都有一些进程，每个正在运行的程序，每个窗口等。并且通常在计算机打开时同时运行许多进程。\n* 同一程序可以有多个进程同时运行。\n\n如果您检查操作系统中的“任务管理器”或“系统监视器”（或类似工具），您将能够看到许多正在运行的进程。\n\n例如，您可能会看到有多个进程运行同一个浏览器程序（Firefox、Chrome、Edge 等）。 他们通常每个tab运行一个进程，再加上一些其他额外的进程。\n\n现在我们知道了术语“进程”和“程序”之间的区别，让我们继续讨论部署。\n\n## 启动时运行\n\n在大多数情况下，当您创建 Web API 时，您希望它始终运行、不间断，以便您的客户端始终可以访问它。 这是当然的，除非您有特定原因希望它仅在某些情况下运行，但大多数时候您希望它不断运行并且可用。\n\n### 在远程服务器中\n\n当您设置远程服务器（云服务器、虚拟机等）时，您可以做的最简单的事情就是手动运行 Uvicorn（或类似的），就像本地开发时一样。\n\n它将会在开发过程中发挥作用并发挥作用。\n\n但是，如果您与服务器的连接丢失，正在运行的进程可能会终止。\n\n如果服务器重新启动（例如更新后或从云提供商迁移后），您可能不会注意到它。 因此，您甚至不知道必须手动重新启动该进程。 所以，你的 API 将一直处于挂掉的状态。 😱\n\n### 启动时自动运行\n\n一般来说，您可能希望服务器程序（例如 Uvicorn）在服务器启动时自动启动，并且不需要任何人为干预，让进程始终与您的 API 一起运行（例如 Uvicorn 运行您的 FastAPI 应用程序） 。\n\n### 单独的程序\n\n为了实现这一点，您通常会有一个单独的程序来确保您的应用程序在启动时运行。 在许多情况下，它还可以确保其他组件或应用程序也运行，例如数据库。\n\n### 启动时运行的示例工具\n\n可以完成这项工作的工具的一些示例是：\n\n* Docker\n* Kubernetes\n* Docker Compose\n* Docker in Swarm Mode\n* Systemd\n* Supervisor\n* 作为其服务的一部分由云提供商内部处理\n* 其他的...\n\n我将在接下来的章节中为您提供更具体的示例。\n\n## 重新启动\n\n与确保应用程序在启动时运行类似，您可能还想确保它在挂掉后重新启动。\n\n### 我们会犯错误\n\n作为人类，我们总是会犯错误。 软件几乎*总是*在不同的地方隐藏着bug。 🐛\n\n作为开发人员，当我们发现这些bug并实现新功能（也可能添加新bug😅）时，我们会不断改进代码。\n\n### 自动处理小错误\n\n使用 FastAPI 构建 Web API 时，如果我们的代码中存在错误，FastAPI 通常会将其包含到触发错误的单个请求中。 🛡\n\n对于该请求，客户端将收到 500 内部服务器错误，但应用程序将继续处理下一个请求，而不是完全崩溃。\n\n### 更大的错误 - 崩溃\n\n尽管如此，在某些情况下，我们编写的一些代码可能会导致整个应用程序崩溃，从而导致 Uvicorn 和 Python 崩溃。 💥\n\n尽管如此，您可能不希望应用程序因为某个地方出现错误而保持死机状态，您可能希望它继续运行，至少对于未破坏的*路径操作*。\n\n### 崩溃后重新启动\n\n但在那些严重错误导致正在运行的进程崩溃的情况下，您需要一个外部组件来负责重新启动进程，至少尝试几次......\n\n/// tip\n\n...尽管如果整个应用程序只是立即崩溃，那么永远重新启动它可能没有意义。 但在这些情况下，您可能会在开发过程中注意到它，或者至少在部署后立即注意到它。\n\n 因此，让我们关注主要情况，在未来的某些特定情况下，它可能会完全崩溃，但重新启动它仍然有意义。\n\n///\n\n您可能希望让这个东西作为 外部组件 负责重新启动您的应用程序，因为到那时，使用 Uvicorn 和 Python 的同一应用程序已经崩溃了，因此同一应用程序的相同代码中没有东西可以对此做出什么。\n\n### 自动重新启动的示例工具\n\n在大多数情况下，用于启动时运行程序的同一工具也用于处理自动重新启动。\n\n例如，可以通过以下方式处理：\n\n* Docker\n* Kubernetes\n* Docker Compose\n* Docker in Swarm mode\n* Systemd\n* Supervisor\n* 作为其服务的一部分由云提供商内部处理\n* 其他的...\n\n## 复制 - 进程和内存\n\n对于 FastAPI 应用程序，使用像 Uvicorn 这样的服务器程序，在一个进程中运行一次就可以同时为多个客户端提供服务。\n\n但在许多情况下，您会希望同时运行多个工作进程。\n\n### 多进程 - Workers\n\n如果您的客户端数量多于单个进程可以处理的数量（例如，如果虚拟机不是太大），并且服务器的 CPU 中有 多个核心，那么您可以让 多个进程 运行 同时处理同一个应用程序，并在它们之间分发所有请求。\n\n当您运行同一 API 程序的多个进程时，它们通常称为 workers。\n\n### 工作进程和端口\n\n还记得文档 [About HTTPS](https.md){.internal-link target=_blank} 中只有一个进程可以侦听服务器中的端口和 IP 地址的一种组合吗？\n\n现在仍然是对的。\n\n因此，为了能够同时拥有多个进程，必须有一个单个进程侦听端口，然后以某种方式将通信传输到每个工作进程。\n\n### 每个进程的内存\n\n现在，当程序将内容加载到内存中时，例如，将机器学习模型加载到变量中，或者将大文件的内容加载到变量中，所有这些都会消耗服务器的一点内存 (RAM) 。\n\n多个进程通常不共享任何内存。 这意味着每个正在运行的进程都有自己的东西、变量和内存。 如果您的代码消耗了大量内存，每个进程将消耗等量的内存。\n\n### 服务器内存\n\n例如，如果您的代码加载 1 GB 大小的机器学习模型，则当您使用 API 运行一个进程时，它将至少消耗 1 GB RAM。 如果您启动 4 个进程（4 个工作进程），每个进程将消耗 1 GB RAM。 因此，您的 API 总共将消耗 4 GB RAM。\n\n如果您的远程服务器或虚拟机只有 3 GB RAM，尝试加载超过 4 GB RAM 将导致问题。 🚨\n\n### 多进程 - 一个例子\n\n在此示例中，有一个 Manager Process 启动并控制两个 Worker Processes。\n\n该管理器进程可能是监听 IP 中的 端口 的进程。 它将所有通信传输到工作进程。\n\n这些工作进程将是运行您的应用程序的进程，它们将执行主要计算以接收 请求 并返回 响应，并且它们将加载您放入 RAM 中的变量中的任何内容。\n\n当然，除了您的应用程序之外，同一台机器可能还运行其他进程。\n\n一个有趣的细节是，随着时间的推移，每个进程使用的 CPU 百分比可能会发生很大变化，但内存 (RAM) 通常会或多或少保持稳定。\n\n如果您有一个每次执行相当数量的计算的 API，并且您有很多客户端，那么 CPU 利用率 可能也会保持稳定（而不是不断快速上升和下降）。\n\n### 复制工具和策略示例\n\n可以通过多种方法来实现这一目标，我将在接下来的章节中向您详细介绍具体策略，例如在谈论 Docker 和容器时。\n\n要考虑的主要限制是必须有一个单个组件来处理公共IP中的端口。 然后它必须有一种方法将通信传输到复制的进程/worker。\n\n以下是一些可能的组合和策略：\n\n* Gunicorn 管理 Uvicorn workers\n     * Gunicorn 将是监听 IP 和 端口 的 进程管理器，复制将通过 多个 Uvicorn 工作进程 进行\n* Uvicorn 管理 Uvicorn workers\n     * 一个 Uvicorn 进程管理器 将监听 IP 和 端口，并且它将启动 多个 Uvicorn 工作进程\n* Kubernetes 和其他分布式 容器系统\n     * Kubernetes 层中的某些东西将侦听 IP 和 端口。 复制将通过拥有多个容器，每个容器运行一个 Uvicorn 进程\n* 云服务 为您处理此问题\n     * 云服务可能为您处理复制。 它可能会让您定义 要运行的进程，或要使用的 容器映像，在任何情况下，它很可能是 单个 Uvicorn 进程，并且云服务将负责复制它。\n\n/// tip\n\n如果这些关于 容器、Docker 或 Kubernetes 的内容还没有多大意义，请不要担心。\n\n 我将在以后的章节中向您详细介绍容器镜像、Docker、Kubernetes 等：[容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank}。\n\n///\n\n## 启动之前的步骤\n\n在很多情况下，您希望在启动应用程序之前执行一些步骤。\n\n例如，您可能想要运行数据库迁移。\n\n但在大多数情况下，您只想执行这些步骤一次。\n\n因此，在启动应用程序之前，您将需要一个单个进程来执行这些前面的步骤。\n\n而且您必须确保它是运行前面步骤的单个进程, *即使*之后您为应用程序本身启动多个进程（多个worker）。 如果这些步骤由多个进程运行，它们会通过在并行运行来重复工作，并且如果这些步骤像数据库迁移一样需要小心处理，它们可能会导致每个进程和其他进程发生冲突。\n\n当然，也有一些情况，多次运行前面的步骤也没有问题，这样的话就好办多了。\n\n/// tip\n\n另外，请记住，根据您的设置，在某些情况下，您在开始应用程序之前可能甚至不需要任何先前的步骤。\n\n 在这种情况下，您就不必担心这些。 🤷\n\n///\n\n### 前面步骤策略的示例\n\n这将在很大程度上取决于您部署系统的方式，并且可能与您启动程序、处理重启等的方式有关。\n\n以下是一些可能的想法：\n\n* Kubernetes 中的“Init Container”在应用程序容器之前运行\n* 一个 bash 脚本，运行前面的步骤，然后启动您的应用程序\n     * 您仍然需要一种方法来启动/重新启动 bash 脚本、检测错误等。\n\n/// tip\n\n我将在以后的章节中为您提供使用容器执行此操作的更具体示例：[容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank}。\n\n///\n\n## 资源利用率\n\n您的服务器是一个资源，您可以通过您的程序消耗或利用CPU 上的计算时间以及可用的 RAM 内存。\n\n您想要消耗/利用多少系统资源？ 您可能很容易认为“不多”，但实际上，您可能希望在不崩溃的情况下尽可能多地消耗。\n\n如果您支付了 3 台服务器的费用，但只使用了它们的一点点 RAM 和 CPU，那么您可能浪费金钱 💸，并且可能 浪费服务器电力 🌎，等等。\n\n在这种情况下，最好只拥有 2 台服务器并使用更高比例的资源（CPU、内存、磁盘、网络带宽等）。\n\n另一方面，如果您有 2 台服务器，并且正在使用 100% 的 CPU 和 RAM，则在某些时候，一个进程会要求更多内存，并且服务器将不得不使用磁盘作为“内存” （这可能会慢数千倍），甚至崩溃。 或者一个进程可能需要执行一些计算，并且必须等到 CPU 再次空闲。\n\n在这种情况下，最好购买一台额外的服务器并在其上运行一些进程，以便它们都有足够的 RAM 和 CPU 时间。\n\n由于某种原因，您的 API 的使用量也有可能出现激增。 也许它像病毒一样传播开来，或者也许其他一些服务或机器人开始使用它。 在这些情况下，您可能需要额外的资源来保证安全。\n\n您可以将一个任意数字设置为目标，例如，资源利用率在 50% 到 90% 之间。 重点是，这些可能是您想要衡量和用来调整部署的主要内容。\n\n您可以使用“htop”等简单工具来查看服务器中使用的 CPU 和 RAM 或每个进程使用的数量。 或者您可以使用更复杂的监控工具，这些工具可能分布在服务器等上。\n\n## 回顾\n\n您在这里阅读了一些在决定如何部署应用程序时可能需要牢记的主要概念：\n\n* 安全性 - HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 开始前的先前步骤\n\n了解这些想法以及如何应用它们应该会给您足够的直觉在配置和调整部署时做出任何决定。 🤓\n\n在接下来的部分中，我将为您提供更具体的示例，说明您可以遵循的可能策略。 🚀']","根据上下文中的生命周期事件机制，预加载和释放机器学习模型的代码应写在 FastAPI 应用的 `lifespan` 异步上下文管理器中：  
1. **启动时加载**：在 `yield` 前执行模型加载（例如 `app.state.model = load_model()`），应用接收请求前仅运行一次。  
2. **关闭时释放**：在 `yield` 后执行模型释放（例如 `unload_model(app.state.model)`），应用停止后触发。  
避免使用已弃用的 `@app.on_event(""startup/shutdown"")`，优先使用 `lifespan` 参数传递该管理器。",代码应该写在 Lifespan（生命周期）事件处理器中。FastAPI 推荐使用 `contextlib.asynccontextmanager` 装饰器创建一个异步上下文管理器，并将其传递给 `FastAPI(lifespan=...)` 参数。在该函数 `yield` 关键字之前的代码会在应用启动（Startup）时执行（适合加载模型），`yield` 之后的代码会在应用关闭（Shutdown）时执行（适合释放内存）。不建议再使用已废弃的 `@app.on_event`。,0.9999999999,0.7777777777777778,0.6943994960403758
如果我想在这个接口上同时用 OAuth2 验证，又要校验一个 API Key header，怎么把这两个安全验证串起来？,"['# OAuth2 实现简单的 Password 和 Bearer 验证\n\n本章添加上一章示例中欠缺的部分，实现完整的安全流。\n\n## 获取 `username` 和 `password`\n\n首先，使用 FastAPI 安全工具获取 `username` 和 `password`。\n\nOAuth2 规范要求使用密码流时，客户端或用户必须以表单数据形式发送 `username` 和 `password` 字段。\n\n并且，这两个字段必须命名为 `username` 和 `password` ，不能使用 `user-name` 或 `email` 等其它名称。\n\n不过也不用担心，前端仍可以显示终端用户所需的名称。\n\n数据库模型也可以使用所需的名称。\n\n但对于登录*路径操作*，则要使用兼容规范的 `username` 和 `password`，（例如，实现与 API 文档集成）。\n\n该规范要求必须以表单数据形式发送 `username` 和 `password`，因此，不能使用 JSON 对象。\n\n### `Scope`（作用域）\n\nOAuth2 还支持客户端发送`scope`表单字段。\n\n虽然表单字段的名称是 `scope`（单数），但实际上，它是以空格分隔的，由多个scope组成的长字符串。\n\n作用域只是不带空格的字符串。\n\n常用于声明指定安全权限，例如：\n\n* 常见用例为，`users:read` 或 `users:write`\n* 脸书和 Instagram 使用 `instagram_basic`\n* 谷歌使用 `https://www.googleapis.com/auth/drive`\n\n/// info | 说明\n\nOAuth2 中，作用域只是声明指定权限的字符串。\n\n是否使用冒号 `:` 等符号，或是不是 URL 并不重要。\n\n这些细节只是特定的实现方式。\n\n对 OAuth2 来说，都只是字符串而已。\n\n///\n\n## 获取 `username` 和 `password` 的代码\n\n接下来，使用 FastAPI 工具获取用户名与密码。\n\n### `OAuth2PasswordRequestForm`\n\n首先，导入 `OAuth2PasswordRequestForm`，然后，在 `/token` *路径操作* 中，用 `Depends` 把该类作为依赖项。\n\n\n```py\nfrom typing import Annotated, Union\n\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\n\nfake_users_db = {\n    ""johndoe"": {\n        ""username"": ""johndoe"",\n        ""full_name"": ""John Doe"",\n        ""email"": ""johndoe@example.com"",\n        ""hashed_password"": ""fakehashedsecret"",\n        ""disabled"": False,\n    },\n    ""alice"": {\n        ""username"": ""alice"",\n        ""full_name"": ""Alice Wonderson"",\n        ""email"": ""alice@example.com"",\n        ""hashed_password"": ""fakehashedsecret2"",\n        ""disabled"": True,\n    },\n}\n\napp = FastAPI()\n\n\ndef fake_hash_password(password: str):\n    return ""fakehashed"" + password\n\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=""token"")\n\n\nclass User(BaseModel):\n    username: str\n    email: Union[str, None] = None\n    full_name: Union[str, None] = None\n    disabled: Union[bool, None] = None\n\n\nclass UserInDB(User):\n    hashed_password: str\n\n\ndef get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)\n\n\ndef fake_decode_token(token):\n    # This doesn\'t provide any security at all\n    # Check the next version\n    user = get_user(fake_users_db, token)\n    return user\n\n\nasync def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):\n    user = fake_decode_token(token)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=""Not authenticated"",\n            headers={""WWW-Authenticate"": ""Bearer""},\n        )\n    return user\n\n\nasync def get_current_active_user(\n    current_user: Annotated[User, Depends(get_current_user)],\n):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=""Inactive user"")\n    return current_user\n\n\n@app.post(""/token"")\nasync def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):\n    user_dict = fake_users_db.get(form_data.username)\n    if not user_dict:\n        raise HTTPException(status_code=400, detail=""Incorrect username or password"")\n    user = UserInDB(**user_dict)\n    hashed_password = fake_hash_password(form_data.password)\n    if not hashed_password == user.hashed_password:\n        raise HTTPException(status_code=400, detail=""Incorrect username or password"")\n\n    return {""access_token"": user.username, ""token_type"": ""bearer""}\n\n\n@app.get(""/users/me"")\nasync def read_users_me(\n    current_user: Annotated[User, Depends(get_current_active_user)],\n):\n    return current_user\n\n```\n\n\n`OAuth2PasswordRequestForm` 是用以下几项内容声明表单请求体的类依赖项：\n\n* `username`\n* `password`\n* 可选的 `scope` 字段，由多个空格分隔的字符串组成的长字符串\n* 可选的 `grant_type`\n\n/// tip | 提示\n\n实际上，OAuth2 规范*要求* `grant_type` 字段使用固定值 `password`，但 `OAuth2PasswordRequestForm` 没有作强制约束。\n\n如需强制使用固定值 `password`，则不要用 `OAuth2PasswordRequestForm`，而是用 `OAuth2PasswordRequestFormStrict`。\n\n///\n\n* 可选的 `client_id`（本例未使用）\n* 可选的 `client_secret`（本例未使用）\n\n/// info | 说明\n\n`OAuth2PasswordRequestForm` 与 `OAuth2PasswordBearer` 一样，都不是 FastAPI 的特殊类。\n\nFastAPI 把 `OAuth2PasswordBearer` 识别为安全方案。因此，可以通过这种方式把它添加至 OpenAPI。\n\n但 `OAuth2PasswordRequestForm` 只是可以自行编写的类依赖项，也可以直接声明 `Form` 参数。\n\n但由于这种用例很常见，FastAPI 为了简便，就直接提供了对它的支持。\n\n///\n\n### 使用表单数据\n\n/// tip | 提示\n\n`OAuth2PasswordRequestForm` 类依赖项的实例没有以空格分隔的长字符串属性 `scope`，但它支持 `scopes` 属性，由已发送的 scope 字符串列表组成。\n\n本例没有使用 `scopes`，但开发者也可以根据需要使用该属性。\n\n///\n\n现在，即可使用表单字段 `username`，从（伪）数据库中获取用户数据。\n\n如果不存在指定用户，则返回错误消息，提示用户名或密码错误。\n\n本例使用 `HTTPException` 异常显示此错误：\n\n\n> *[Ref: Code file `tutorial003_an_py39.py` is already included above]*\n\n\n### 校验密码\n\n至此，我们已经从数据库中获取了用户数据，但尚未校验密码。\n\n接下来，首先将数据放入 Pydantic 的 `UserInDB` 模型。\n\n注意：永远不要保存明文密码，本例暂时先使用（伪）哈希密码系统。\n\n如果密码不匹配，则返回与上面相同的错误。\n\n#### 密码哈希\n\n哈希是指，将指定内容（本例中为密码）转换为形似乱码的字节序列（其实就是字符串）。\n\n每次传入完全相同的内容（比如，完全相同的密码）时，得到的都是完全相同的乱码。\n\n但这个乱码无法转换回传入的密码。\n\n##### 为什么使用密码哈希\n\n原因很简单，假如数据库被盗，窃贼无法获取用户的明文密码，得到的只是哈希值。\n\n这样一来，窃贼就无法在其它应用中使用窃取的密码，要知道，很多用户在所有系统中都使用相同的密码，风险超大。\n\n\n> *[Ref: Code file `tutorial003_an_py39.py` is already included above]*\n\n\n#### 关于 `user_dict`\n\n`UserInDB(user_dict)` 是指：\n\n*直接把 `user_dict` 的键与值当作关键字参数传递，等效于：*\n\n```Python\nUserInDB(\n    username = user_dict[""username""],\n    email = user_dict[""email""],\n    full_name = user_dict[""full_name""],\n    disabled = user_dict[""disabled""],\n    hashed_password = user_dict[""hashed_password""],\n)\n```\n\n/// info | 说明\n\n`user_dict` 的说明，详见[更多模型一章](../extra-models.md#user_indict){.internal-link target=_blank}。\n\n///\n\n## 返回 Token\n\n`token` 端点的响应必须是 JSON 对象。\n\n响应返回的内容应该包含 `token_type`。本例中用的是BearerToken，因此， Token 类型应为`bearer`。\n\n返回内容还应包含 `access_token` 字段，它是包含权限 Token 的字符串。\n\n本例只是简单的演示，返回的 Token 就是 `username`，但这种方式极不安全。\n\n/// tip | 提示\n\n下一章介绍使用哈希密码和 <abbr title=""JSON Web Tokens"">JWT</abbr> Token 的真正安全机制。\n\n但现在，仅关注所需的特定细节。\n\n///\n\n\n> *[Ref: Code file `tutorial003_an_py39.py` is already included above]*\n\n\n/// tip | 提示\n\n按规范的要求，应像本示例一样，返回带有 `access_token` 和 `token_type` 的 JSON 对象。\n\n这是开发者必须在代码中自行完成的工作，并且要确保使用这些 JSON 的键。\n\n这几乎是唯一需要开发者牢记在心，并按规范要求正确执行的事。\n\nFastAPI 则负责处理其它的工作。\n\n///\n\n## 更新依赖项\n\n接下来，更新依赖项。\n\n使之仅在当前用户为激活状态时，才能获取 `current_user`。\n\n为此，要再创建一个依赖项 `get_current_active_user`，此依赖项以 `get_current_user` 依赖项为基础。\n\n如果用户不存在，或状态为未激活，这两个依赖项都会返回 HTTP 错误。\n\n因此，在端点中，只有当用户存在、通过身份验证、且状态为激活时，才能获得该用户：\n\n\n> *[Ref: Code file `tutorial003_an_py39.py` is already included above]*\n\n\n/// info | 说明\n\n此处返回值为 `Bearer` 的响应头 `WWW-Authenticate` 也是规范的一部分。\n\n任何 401UNAUTHORIZEDHTTP（错误）状态码都应返回 `WWW-Authenticate` 响应头。\n\n本例中，因为使用的是 Bearer Token，该响应头的值应为 `Bearer`。\n\n实际上，忽略这个附加响应头，也不会有什么问题。\n\n之所以在此提供这个附加响应头，是为了符合规范的要求。\n\n说不定什么时候，就有工具用得上它，而且，开发者或用户也可能用得上。\n\n这就是遵循标准的好处……\n\n///\n\n## 实际效果\n\n打开 API 文档：http://127.0.0.1:8000/docs。\n\n### 身份验证\n\n点击Authorize按钮。\n\n使用以下凭证：\n\n用户名：`johndoe`\n\n密码：`secret`\n\n通过身份验证后，显示下图所示的内容：\n\n### 获取当前用户数据\n\n使用 `/users/me` 路径的 `GET` 操作。\n\n可以提取如下当前用户数据：\n\n```JSON\n{\n  ""username"": ""johndoe"",\n  ""email"": ""johndoe@example.com"",\n  ""full_name"": ""John Doe"",\n  ""disabled"": false,\n  ""hashed_password"": ""fakehashedsecret""\n}\n```\n\n点击小锁图标，注销后，再执行同样的操作，则会得到 HTTP 401 错误：\n\n```JSON\n{\n  ""detail"": ""Not authenticated""\n}\n```\n\n### 未激活用户\n\n测试未激活用户，输入以下信息，进行身份验证：\n\n用户名：`alice`\n\n密码：`secret2`\n\n然后，执行 `/users/me` 路径的 `GET` 操作。\n\n显示下列未激活用户错误信息：\n\n```JSON\n{\n  ""detail"": ""Inactive user""\n}\n```\n\n## 小结\n\n使用本章的工具实现基于 `username` 和 `password` 的完整 API 安全系统。\n\n这些工具让安全系统兼容任何数据库、用户及数据模型。\n\n唯一欠缺的是，它仍然不是真的安全。\n\n下一章，介绍使用密码哈希支持库与 <abbr title=""JSON Web Tokens"">JWT</abbr> 令牌实现真正的安全机制。', ""# 安全性\n\n有许多方法可以处理安全性、身份认证和授权等问题。\n\n而且这通常是一个复杂而「困难」的话题。\n\n在许多框架和系统中，仅处理安全性和身份认证就会花费大量的精力和代码（在许多情况下，可能占编写的所有代码的 50％ 或更多）。\n\nFastAPI 提供了多种工具，可帮助你以标准的方式轻松、快速地处理安全性，而无需研究和学习所有的安全规范。\n\n但首先，让我们来看一些小的概念。\n\n## 没有时间？\n\n如果你不关心这些术语，而只需要*立即*通过基于用户名和密码的身份认证来增加安全性，请跳转到下一章。\n\n## OAuth2\n\nOAuth2是一个规范，它定义了几种处理身份认证和授权的方法。\n\n它是一个相当广泛的规范，涵盖了一些复杂的使用场景。\n\n它包括了使用「第三方」进行身份认证的方法。\n\n这就是所有带有「使用 Facebook，Google，X (Twitter)，GitHub 登录」的系统背后所使用的机制。\n\n### OAuth 1\n\n有一个 OAuth 1，它与 OAuth2 完全不同，并且更为复杂，因为它直接包含了有关如何加密通信的规范。\n\n如今它已经不是很流行，没有被广泛使用了。\n\nOAuth2 没有指定如何加密通信，它期望你为应用程序使用 HTTPS 进行通信。\n\n/// tip\n\n在有关部署的章节中，你将了解如何使用 Traefik 和 Let's Encrypt 免费设置 HTTPS。\n\n///\n\n## OpenID Connect\n\nOpenID Connect 是另一个基于 OAuth2 的规范。\n\n它只是扩展了 OAuth2，并明确了一些在 OAuth2 中相对模糊的内容，以尝试使其更具互操作性。\n\n例如，Google 登录使用 OpenID Connect（底层使用OAuth2）。\n\n但是 Facebook 登录不支持 OpenID Connect。它具有自己的 OAuth2 风格。\n\n### OpenID（非「OpenID Connect」）\n\n还有一个「OpenID」规范。它试图解决与 OpenID Connect 相同的问题，但它不是基于 OAuth2。\n\n因此，它是一个完整的附加系统。\n\n如今它已经不是很流行，没有被广泛使用了。\n\n## OpenAPI\n\nOpenAPI（以前称为 Swagger）是用于构建 API 的开放规范（现已成为 Linux Foundation 的一部分）。\n\nFastAPI 基于 OpenAPI。\n\n这就是使多个自动交互式文档界面，代码生成等成为可能的原因。\n\nOpenAPI 有一种定义多个安全「方案」的方法。\n\n通过使用它们，你可以利用所有这些基于标准的工具，包括这些交互式文档系统。\n\nOpenAPI 定义了以下安全方案：\n\n* `apiKey`：一个特定于应用程序的密钥，可以来自：\n    * 查询参数。\n    * 请求头。\n    * cookie。\n* `http`：标准的 HTTP 身份认证系统，包括：\n    * `bearer`: 一个值为 `Bearer` 加令牌字符串的 `Authorization` 请求头。这是从 OAuth2 继承的。\n    * HTTP Basic 认证方式。\n    * HTTP Digest，等等。\n* `oauth2`：所有的 OAuth2 处理安全性的方式（称为「流程」）。\n    *以下几种流程适合构建 OAuth 2.0 身份认证的提供者（例如 Google，Facebook，X (Twitter)，GitHub 等）：\n        * `implicit`\n        * `clientCredentials`\n        * `authorizationCode`\n    * 但是有一个特定的「流程」可以完美地用于直接在同一应用程序中处理身份认证：\n        * `password`：接下来的几章将介绍它的示例。\n* `openIdConnect`：提供了一种定义如何自动发现 OAuth2 身份认证数据的方法。\n    * 此自动发现机制是 OpenID Connect 规范中定义的内容。\n\n/// tip\n\n集成其他身份认证/授权提供者（例如Google，Facebook，X (Twitter)，GitHub等）也是可能的，而且较为容易。\n\n最复杂的问题是创建一个像这样的身份认证/授权提供程序，但是 FastAPI 为你提供了轻松完成任务的工具，同时为你解决了重活。\n\n///\n\n## FastAPI 实用工具\n\nFastAPI 在 `fastapi.security` 模块中为每个安全方案提供了几种工具，这些工具简化了这些安全机制的使用方法。\n\n在下一章中，你将看到如何使用 FastAPI 所提供的这些工具为你的 API 增加安全性。\n\n而且你还将看到它如何自动地被集成到交互式文档系统中。"", '# OAuth2 作用域\n\nFastAPI 无缝集成 OAuth2 作用域（`Scopes`），可以直接使用。\n\n作用域是更精密的权限系统，遵循 OAuth2 标准，与 OpenAPI 应用（和 API 自动文档）集成。\n\nOAuth2 也是脸书、谷歌、GitHub、微软、推特等第三方身份验证应用使用的机制。这些身份验证应用在用户登录应用时使用 OAuth2 提供指定权限。\n\n脸书、谷歌、GitHub、微软、推特就是 OAuth2 作用域登录。\n\n本章介绍如何在 FastAPI 应用中使用 OAuth2 作用域管理验证与授权。\n\n/// warning | 警告\n\n本章内容较难，刚接触 FastAPI 的新手可以跳过。\n\nOAuth2 作用域不是必需的，没有它，您也可以处理身份验证与授权。\n\n但 OAuth2 作用域与 API（通过 OpenAPI）及 API 文档集成地更好。\n\n不管怎么说，FastAPI 支持在代码中使用作用域或其它安全/授权需求项。\n\n很多情况下，OAuth2 作用域就像一把牛刀。\n\n但如果您确定要使用作用域，或对它有兴趣，请继续阅读。\n\n///\n\n## OAuth2 作用域与 OpenAPI\n\nOAuth2 规范的作用域是由空格分割的字符串组成的列表。\n\n这些字符串支持任何格式，但不能包含空格。\n\n作用域表示的是权限。\n\nOpenAPI 中（例如 API 文档）可以定义安全方案。\n\n这些安全方案在使用 OAuth2 时，还可以声明和使用作用域。\n\n作用域只是（不带空格的）字符串。\n\n常用于声明特定安全权限，例如：\n\n* 常见用例为，`users:read` 或 `users:write`\n* 脸书和 Instagram 使用 `instagram_basic`\n* 谷歌使用 `https://www.googleapis.com/auth/drive`\n\n/// info | 说明\n\nOAuth2 中，作用域只是声明特定权限的字符串。\n\n是否使用冒号 `:` 等符号，或是不是 URL 并不重要。\n\n这些细节只是特定的实现方式。\n\n对 OAuth2 来说，它们都只是字符串而已。\n\n///\n\n## 全局纵览\n\n首先，快速浏览一下以下代码与用户指南中 [OAuth2 实现密码哈希与 Bearer  JWT 令牌验证](../../tutorial/security/oauth2-jwt.md){.internal-link target=_blank}一章中代码的区别。以下代码使用 OAuth2 作用域：\n\n\n```py\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Annotated, Union\n\nimport jwt\nfrom fastapi import Depends, FastAPI, HTTPException, Security, status\nfrom fastapi.security import (\n    OAuth2PasswordBearer,\n    OAuth2PasswordRequestForm,\n    SecurityScopes,\n)\nfrom jwt.exceptions import InvalidTokenError\nfrom pwdlib import PasswordHash\nfrom pydantic import BaseModel, ValidationError\n\n# to get a string like this run:\n# openssl rand -hex 32\nSECRET_KEY = ""09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7""\nALGORITHM = ""HS256""\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n\nfake_users_db = {\n    ""johndoe"": {\n        ""username"": ""johndoe"",\n        ""full_name"": ""John Doe"",\n        ""email"": ""johndoe@example.com"",\n        ""hashed_password"": ""$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc"",\n        ""disabled"": False,\n    },\n    ""alice"": {\n        ""username"": ""alice"",\n        ""full_name"": ""Alice Chains"",\n        ""email"": ""alicechains@example.com"",\n        ""hashed_password"": ""$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE"",\n        ""disabled"": True,\n    },\n}\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: Union[str, None] = None\n    scopes: list[str] = []\n\n\nclass User(BaseModel):\n    username: str\n    email: Union[str, None] = None\n    full_name: Union[str, None] = None\n    disabled: Union[bool, None] = None\n\n\nclass UserInDB(User):\n    hashed_password: str\n\n\npassword_hash = PasswordHash.recommended()\n\noauth2_scheme = OAuth2PasswordBearer(\n    tokenUrl=""token"",\n    scopes={""me"": ""Read information about the current user."", ""items"": ""Read items.""},\n)\n\napp = FastAPI()\n\n\ndef verify_password(plain_password, hashed_password):\n    return password_hash.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password):\n    return password_hash.hash(password)\n\n\ndef get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)\n\n\ndef authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user\n\n\ndef create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(timezone.utc) + expires_delta\n    else:\n        expire = datetime.now(timezone.utc) + timedelta(minutes=15)\n    to_encode.update({""exp"": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\nasync def get_current_user(\n    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]\n):\n    if security_scopes.scopes:\n        authenticate_value = f\'Bearer scope=""{security_scopes.scope_str}""\'\n    else:\n        authenticate_value = ""Bearer""\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=""Could not validate credentials"",\n        headers={""WWW-Authenticate"": authenticate_value},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username = payload.get(""sub"")\n        if username is None:\n            raise credentials_exception\n        scope: str = payload.get(""scope"", """")\n        token_scopes = scope.split("" "")\n        token_data = TokenData(scopes=token_scopes, username=username)\n    except (InvalidTokenError, ValidationError):\n        raise credentials_exception\n    user = get_user(fake_users_db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    for scope in security_scopes.scopes:\n        if scope not in token_data.scopes:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=""Not enough permissions"",\n                headers={""WWW-Authenticate"": authenticate_value},\n            )\n    return user\n\n\nasync def get_current_active_user(\n    current_user: Annotated[User, Security(get_current_user, scopes=[""me""])],\n):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=""Inactive user"")\n    return current_user\n\n\n@app.post(""/token"")\nasync def login_for_access_token(\n    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],\n) -> Token:\n    user = authenticate_user(fake_users_db, form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(status_code=400, detail=""Incorrect username or password"")\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={""sub"": user.username, ""scope"": "" "".join(form_data.scopes)},\n        expires_delta=access_token_expires,\n    )\n    return Token(access_token=access_token, token_type=""bearer"")\n\n\n@app.get(""/users/me/"", response_model=User)\nasync def read_users_me(\n    current_user: Annotated[User, Depends(get_current_active_user)],\n):\n    return current_user\n\n\n@app.get(""/users/me/items/"")\nasync def read_own_items(\n    current_user: Annotated[User, Security(get_current_active_user, scopes=[""items""])],\n):\n    return [{""item_id"": ""Foo"", ""owner"": current_user.username}]\n\n\n@app.get(""/status/"")\nasync def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):\n    return {""status"": ""ok""}\n\n```\n\n\n下面，我们逐步说明修改的代码内容。\n\n## OAuth2 安全方案\n\n第一个修改的地方是，使用两个作用域 `me` 和 `items ` 声明 OAuth2 安全方案。\n\n`scopes` 参数接收字典，键是作用域、值是作用域的描述：\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n因为声明了作用域，所以登录或授权时会在 API 文档中显示。\n\n此处，选择给予访问权限的作用域： `me` 和 `items`。\n\n这也是使用脸书、谷歌、GitHub 登录时的授权机制。\n\n## JWT 令牌作用域\n\n现在，修改令牌*路径操作*，返回请求的作用域。\n\n此处仍然使用 `OAuth2PasswordRequestForm`。它包含类型为字符串列表的 `scopes` 属性，且`scopes` 属性中包含要在请求里接收的每个作用域。\n\n这样，返回的 JWT 令牌中就包含了作用域。\n\n/// danger | 危险\n\n为了简明起见，本例把接收的作用域直接添加到了令牌里。\n\n但在您的应用中，为了安全，应该只把作用域添加到确实需要作用域的用户，或预定义的用户。\n\n///\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 在*路径操作*与依赖项中声明作用域\n\n接下来，为*路径操作*  `/users/me/items/` 声明作用域 `items`。\n\n为此，要从 `fastapi` 中导入并使用 `Security` 。\n\n`Security` 声明依赖项的方式和 `Depends` 一样，但 `Security` 还能接收作用域（字符串）列表类型的参数 `scopes`。\n\n此处使用与 `Depends` 相同的方式，把依赖项函数 `get_current_active_user` 传递给 `Security`。\n\n同时，还传递了作用域列表，本例中只传递了一个作用域：`items`（此处支持传递更多作用域）。\n\n依赖项函数 `get_current_active_user` 还能声明子依赖项，不仅可以使用 `Depends`，也可以使用 `Security`。声明子依赖项函数（`get_current_user`）及更多作用域。\n\n本例要求使用作用域 `me`（还可以使用更多作用域）。\n\n/// note | 笔记\n\n不必在不同位置添加不同的作用域。\n\n本例使用的这种方式只是为了展示 FastAPI 如何处理在不同层级声明的作用域。\n\n///\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n/// info | 技术细节\n\n`Security` 实际上是 `Depends` 的子类，而且只比 `Depends` 多一个参数。\n\n但使用 `Security` 代替 `Depends`，FastAPI 可以声明安全作用域，并在内部使用这些作用域，同时，使用 OpenAPI 存档 API。\n\n但实际上，从 `fastapi` 导入的 `Query`、`Path`、`Depends`、`Security` 等对象，只是返回特殊类的函数。\n\n///\n\n## 使用 `SecurityScopes`\n\n修改依赖项 `get_current_user`。\n\n这是上面的依赖项使用的依赖项。\n\n这里使用的也是之前创建的 OAuth2 方案，并把它声明为依赖项：`oauth2_scheme`。\n\n该依赖项函数本身不需要作用域，因此，可以使用 `Depends` 和 `oauth2_scheme`。不需要指定安全作用域时，不必使用 `Security`。\n\n此处还声明了从 `fastapi.security` 导入的 `SecurityScopes` 类型的特殊参数。\n\n`SecuriScopes` 类与 `Request` 类似（`Request` 用于直接提取请求对象）。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 使用 `scopes`\n\n参数 `security_scopes` 的类型是 `SecurityScopes`。\n\n它的属性 `scopes`  是作用域列表，所有依赖项都把它作为子依赖项。也就是说所有依赖……这听起来有些绕，后文会有解释。\n\n（类 `SecurityScopes` 的）`security_scopes` 对象还提供了单字符串类型的属性 `scope_str`，该属性是（要在本例中使用的）用空格分割的作用域。\n\n此处还创建了后续代码中要复用（`raise`）的 `HTTPException` 。\n\n该异常包含了作用域所需的（如有），以空格分割的字符串（使用 `scope_str`）。该字符串要放到包含作用域的 `WWW-Authenticate` 请求头中（这也是规范的要求）。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 校验 `username` 与数据形状\n\n我们可以校验是否获取了 `username`，并抽取作用域。\n\n然后，使用 Pydantic 模型校验数据（捕获 `ValidationError` 异常），如果读取 JWT 令牌或使用 Pydantic 模型验证数据时出错，就会触发之前创建的 `HTTPException` 异常。\n\n对此，要使用新的属性 `scopes` 更新 Pydantic 模型 `TokenData`。\n\n使用 Pydantic 验证数据可以确保数据中含有由作用域组成的字符串列表，以及 `username` 字符串等内容。\n\n反之，如果使用字典或其它数据结构，就有可能在后面某些位置破坏应用，形成安全隐患。\n\n还可以使用用户名验证用户，如果没有用户，也会触发之前创建的异常。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 校验 `scopes`\n\n接下来，校验所有依赖项和依赖要素（包括*路径操作*）所需的作用域。这些作用域包含在令牌的 `scopes` 里，如果不在其中就会触发 `HTTPException` 异常。\n\n为此，要使用包含所有作用域字符串列表的 `security_scopes.scopes`， 。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 依赖项树与作用域\n\n再次查看这个依赖项树与作用域。\n\n`get_current_active_user` 依赖项包含子依赖项 `get_current_user`，并在 `get_current_active_user`中声明了作用域 `""me""` 包含所需作用域列表 ，在 `security_scopes.scopes` 中传递给 `get_current_user`。\n\n*路径操作*自身也声明了作用域，`""items""`，这也是 `security_scopes.scopes` 列表传递给 `get_current_user` 的。\n\n依赖项与作用域的层级架构如下：\n\n* *路径操作* `read_own_items` 包含：\n    * 依赖项所需的作用域 `[""items""]`：\n    * `get_current_active_user`:\n        *  依赖项函数 `get_current_active_user` 包含：\n            * 所需的作用域 `""me""` 包含依赖项：\n            * `get_current_user`:\n                * 依赖项函数 `get_current_user` 包含：\n                    * 没有作用域需求其自身\n                    * 依赖项使用 `oauth2_scheme`\n                    * `security_scopes` 参数的类型是 `SecurityScopes`：\n                        * `security_scopes` 参数的属性 `scopes` 是包含上述声明的所有作用域的列表，因此：\n                            * `security_scopes.scopes` 包含用于*路径操作*的 `[""me"", ""items""]`\n                            * `security_scopes.scopes` 包含*路径操作* `read_users_me` 的 `[""me""]`，因为它在依赖项里被声明\n                            * `security_scopes.scopes` 包含用于*路径操作* `read_system_status` 的 `[]`（空列表），并且它的依赖项 `get_current_user` 也没有声明任何 `scope`\n\n/// tip | 提示\n\n此处重要且神奇的事情是，`get_current_user` 检查每个*路径操作*时可以使用不同的 `scopes` 列表。\n\n所有这些都依赖于在每个*路径操作*和指定*路径操作*的依赖树中的每个依赖项。\n\n///\n\n## `SecurityScopes` 的更多细节\n\n您可以任何位置或多个位置使用 `SecurityScopes`，不一定非得在根依赖项中使用。\n\n它总是在当前 `Security` 依赖项中和所有依赖因子对于特定 *路径操作*和特定依赖树中安全作用域\n\n因为 `SecurityScopes` 包含所有由依赖项声明的作用域，可以在核心依赖函数中用它验证所需作用域的令牌，然后再在不同的*路径操作*中声明不同作用域需求。\n\n它们会为每个*路径操作*进行单独检查。\n\n## 查看文档\n\n打开 API 文档，进行身份验证，并指定要授权的作用域。\n\n没有选择任何作用域，也可以进行身份验证，但访问 `/uses/me` 或 `/users/me/items` 时，会显示没有足够的权限。但仍可以访问 `/status/`。\n\n如果选择了作用域 `me`，但没有选择作用域 `items`，则可以访问 `/users/me/`，但不能访问 `/users/me/items`。\n\n这就是通过用户提供的令牌使用第三方应用访问这些*路径操作*时会发生的情况，具体怎样取决于用户授予第三方应用的权限。\n\n## 关于第三方集成\n\n本例使用 OAuth2 密码流。\n\n这种方式适用于登录我们自己的应用，最好使用我们自己的前端。\n\n因为我们能控制自己的前端应用，可以信任它接收 `username` 与 `password`。\n\n但如果构建的是连接其它应用的 OAuth2 应用，比如具有与脸书、谷歌、GitHub 相同功能的第三方身份验证应用。那您就应该使用其它安全流。\n\n最常用的是隐式流。\n\n最安全的是代码流，但实现起来更复杂，而且需要更多步骤。因为它更复杂，很多第三方身份验证应用最终建议使用隐式流。\n\n/// note | 笔记\n\n每个身份验证应用都会采用不同方式会命名流，以便融合入自己的品牌。\n\n但归根结底，它们使用的都是 OAuth2 标准。\n\n///\n\nFastAPI 的 `fastapi.security.oauth2` 里包含了所有 OAuth2 身份验证流工具。\n\n## 装饰器 `dependencies` 中的 `Security`\n\n同样，您可以在装饰器的 `dependencies` 参数中定义 `Depends` 列表，（详见[路径操作装饰器依赖项](../../tutorial/dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank})），也可以把 `scopes` 与 `Security` 一起使用。']","根据提供的上下文，没有明确说明如何将OAuth2验证与API Key header验证串联使用。上下文主要聚焦于OAuth2的Password和Bearer验证流程的实现细节，包括令牌生成、作用域管理和依赖项校验，但未涉及API Key的集成方案。

因此，我无法从给定上下文中找到相关答案。","你可以在路由操作函数（Path Operation）中同时声明多个依赖项。可以将它们作为参数分别注入，例如 `def route(token: str = Depends(oauth2_scheme), key: str = Depends(api_key_header))`。如果不需要在函数内部使用这些返回值，也可以将它们放入路由装饰器的 `dependencies` 参数列表中，例如 `@app.get('/items', dependencies=[Depends(oauth2_scheme), Depends(verify_api_key)])`，这样 FastAPI 会按顺序执行所有安全验证。",0.9999999999,1.0,0.0
Uvicorn 的 workers 数量设置成多少合适？是不是越多越好？跟 CPU 核数有什么关系？,"['# 服务器工作进程（Workers） - 使用 Uvicorn 的多工作进程模式\n\n让我们回顾一下之前的部署概念：\n\n* 安全性 - HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 启动前的先前步骤\n\n到目前为止，在文档中的所有教程中，您可能一直是在运行一个服务器程序，例如使用 `fastapi` 命令来启动 Uvicorn，而它默认运行的是单进程模式。\n\n部署应用程序时，您可能希望进行一些进程复制，以利用多核 CPU 并能够处理更多请求。\n\n正如您在上一章有关[部署概念](concepts.md){.internal-link target=_blank}中看到的，您可以使用多种策略。\n\n在本章节中，我将向您展示如何使用 `fastapi` 命令或直接使用 `uvicorn` 命令以多工作进程模式运行 Uvicorn。\n\n/// info\n\n如果您正在使用容器，例如 Docker 或 Kubernetes，我将在下一章中告诉您更多相关信息：[容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank}。\n\n比较特别的是，在 Kubernetes 环境中运行时，您通常不需要使用多个工作进程，而是每个容器运行一个 Uvicorn 进程。不过，我会在本章节的后续部分详细介绍这一点。\n\n///\n\n## 多个工作进程\n\n您可以使用 `--workers` 命令行选项来启动多个工作进程：\n\n//// tab | `fastapi`\n\n如果您使用 `fastapi` 命令：\n\n```console\n$ fastapi run --workers 4 main.py\n\n   FastAPI   Starting production server 🚀\n\n             Searching for package file structure from directories with\n             init.py files\n             Importing from /home/user/code/awesomeapp\n\n    module   🐍 main.py\n\n      code   Importing the FastAPI app object from the module with the\n             following code:\n\n             from main import app\n\n       app   Using import string: main:app\n\n    server   Server started at http://0.0.0.0:8000\n    server   Documentation at http://0.0.0.0:8000/docs\n\n             Logs:\n\n      INFO   Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to\n             quit)\n      INFO   Started parent process [27365]\n      INFO   Started server process [27368]\n      INFO   Started server process [27369]\n      INFO   Started server process [27370]\n      INFO   Started server process [27367]\n      INFO   Waiting for application startup.\n      INFO   Waiting for application startup.\n      INFO   Waiting for application startup.\n      INFO   Waiting for application startup.\n      INFO   Application startup complete.\n      INFO   Application startup complete.\n      INFO   Application startup complete.\n      INFO   Application startup complete.\n```\n\n////\n\n//// tab | `uvicorn`\n\n如果您更想要直接使用 `uvicorn` 命令：\n\n```console\n$ uvicorn main:app --host 0.0.0.0 --port 8080 --workers 4\nINFO:     Uvicorn running on http://0.0.0.0:8080 (Press CTRL+C to quit)\nINFO:     Started parent process [27365]\nINFO:     Started server process [27368]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [27369]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [27370]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [27367]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```\n\n////\n\n这里唯一的新选项是 `--workers` 告诉 Uvicorn 启动 4 个工作进程。\n\n您还可以看到它显示了每个进程的 PID，父进程（这是进程管理器）的 PID 为`27365`，每个工作进程的 PID 为：`27368`、`27369`， `27370`和`27367`。\n\n## 部署概念\n\n在这里，您学习了如何使用多个工作进程（workers）来让应用程序的执行并行化，充分利用 CPU 的多核性能，并能够处理更多的请求。\n\n从上面的部署概念列表来看，使用worker主要有助于复制部分，并对重新启动有一点帮助，但您仍然需要照顾其他部分：\n\n* 安全 - HTTPS\n* 启动时运行\n* *重新启动*\n* 复制（运行的进程数）\n* 内存\n* 启动之前的先前步骤\n\n## 容器和 Docker\n\n在关于 [容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank} 的下一章中，我将介绍一些可用于处理其他部署概念的策略。\n\n我将向您展示如何从零开始构建自己的镜像，以运行一个单独的 Uvicorn 进程。这个过程相对简单，并且在使用 Kubernetes 等分布式容器管理系统时，这通常是您需要采取的方法。\n\n## 回顾\n\n您可以在使用 `fastapi` 或 `uvicorn` 命令时，通过 `--workers` CLI 选项启用多个工作进程（workers），以充分利用多核 CPU，以并行运行多个进程。\n\n如果您要设置自己的部署系统，同时自己处理其他部署概念，则可以使用这些工具和想法。\n\n请查看下一章，了解带有容器（例如 Docker 和 Kubernetes）的 FastAPI。 您将看到这些工具也有简单的方法来解决其他部署概念。 ✨', '# 部署概念\n\n在部署 FastAPI 应用程序或任何类型的 Web API 时，有几个概念值得了解，通过掌握这些概念您可以找到最合适的方法来部署您的应用程序。\n\n一些重要的概念是：\n\n* 安全性 - HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 开始前的先前步骤\n\n我们接下来了解它们将如何影响部署。\n\n我们的最终目标是能够以安全的方式为您的 API 客户端提供服务，同时要避免中断，并且尽可能高效地利用计算资源（ 例如服务器CPU资源）。 🚀\n\n我将在这里告诉您更多关于这些概念的信息，希望能给您提供直觉来决定如何在非常不同的环境中部署 API，甚至在是尚不存在的未来的环境里。\n\n通过考虑这些概念，您将能够评估和设计部署您自己的 API的最佳方式。\n\n在接下来的章节中，我将为您提供更多部署 FastAPI 应用程序的具体方法。\n\n但现在，让我们仔细看一下这些重要的概念。 这些概念也适用于任何其他类型的 Web API。 💡\n\n## 安全性 - HTTPS\n\n在[上一章有关 HTTPS](https.md){.internal-link target=_blank} 中，我们了解了 HTTPS 如何为您的 API 提供加密。\n\n我们还看到，HTTPS 通常由应用程序服务器的外部组件（TLS 终止代理）提供。\n\n并且必须有某个东西负责更新 HTTPS 证书，它可以是相同的组件，也可以是不同的组件。\n\n### HTTPS 示例工具\n\n您可以用作 TLS 终止代理的一些工具包括：\n\n* Traefik\n     * 自动处理证书更新 ✨\n* Caddy\n     * 自动处理证书更新 ✨\n* Nginx\n     * 使用 Certbot 等外部组件进行证书更新\n* HAProxy\n     * 使用 Certbot 等外部组件进行证书更新\n* 带有 Ingress Controller(如Nginx) 的 Kubernetes\n     * 使用诸如 cert-manager 之类的外部组件来进行证书更新\n* 由云服务商内部处理，作为其服务的一部分（请阅读下文👇）\n\n另一种选择是您可以使用云服务来完成更多工作，包括设置 HTTPS。 它可能有一些限制或向您收取更多费用等。但在这种情况下，您不必自己设置 TLS 终止代理。\n\n我将在接下来的章节中向您展示一些具体示例。\n\n接下来要考虑的概念都是关于运行实际 API 的程序（例如 Uvicorn）。\n\n## 程序和进程\n\n我们将讨论很多关于正在运行的“进程”的内容，因此弄清楚它的含义以及与“程序”这个词有什么区别是很有用的。\n\n### 什么是程序\n\n程序这个词通常用来描述很多东西：\n\n* 您编写的 代码，Python 文件。\n* 操作系统可以执行的文件，例如：`python`、`python.exe`或`uvicorn`。\n* 在操作系统上运行、使用CPU 并将内容存储在内存上的特定程序。 这也被称为进程。\n\n### 什么是进程\n\n进程 这个词通常以更具体的方式使用，仅指在操作系统中运行的东西（如上面的最后一点）：\n\n* 在操作系统上运行的特定程序。\n     * 这不是指文件，也不是指代码，它具体指的是操作系统正在执行和管理的东西。\n* 任何程序，任何代码，只有在执行时才能做事。 因此，是当有进程正在运行时。\n* 该进程可以由您或操作系统终止（或“杀死”）。 那时，它停止运行/被执行，并且它可以不再做事情。\n* 您计算机上运行的每个应用程序背后都有一些进程，每个正在运行的程序，每个窗口等。并且通常在计算机打开时同时运行许多进程。\n* 同一程序可以有多个进程同时运行。\n\n如果您检查操作系统中的“任务管理器”或“系统监视器”（或类似工具），您将能够看到许多正在运行的进程。\n\n例如，您可能会看到有多个进程运行同一个浏览器程序（Firefox、Chrome、Edge 等）。 他们通常每个tab运行一个进程，再加上一些其他额外的进程。\n\n现在我们知道了术语“进程”和“程序”之间的区别，让我们继续讨论部署。\n\n## 启动时运行\n\n在大多数情况下，当您创建 Web API 时，您希望它始终运行、不间断，以便您的客户端始终可以访问它。 这是当然的，除非您有特定原因希望它仅在某些情况下运行，但大多数时候您希望它不断运行并且可用。\n\n### 在远程服务器中\n\n当您设置远程服务器（云服务器、虚拟机等）时，您可以做的最简单的事情就是手动运行 Uvicorn（或类似的），就像本地开发时一样。\n\n它将会在开发过程中发挥作用并发挥作用。\n\n但是，如果您与服务器的连接丢失，正在运行的进程可能会终止。\n\n如果服务器重新启动（例如更新后或从云提供商迁移后），您可能不会注意到它。 因此，您甚至不知道必须手动重新启动该进程。 所以，你的 API 将一直处于挂掉的状态。 😱\n\n### 启动时自动运行\n\n一般来说，您可能希望服务器程序（例如 Uvicorn）在服务器启动时自动启动，并且不需要任何人为干预，让进程始终与您的 API 一起运行（例如 Uvicorn 运行您的 FastAPI 应用程序） 。\n\n### 单独的程序\n\n为了实现这一点，您通常会有一个单独的程序来确保您的应用程序在启动时运行。 在许多情况下，它还可以确保其他组件或应用程序也运行，例如数据库。\n\n### 启动时运行的示例工具\n\n可以完成这项工作的工具的一些示例是：\n\n* Docker\n* Kubernetes\n* Docker Compose\n* Docker in Swarm Mode\n* Systemd\n* Supervisor\n* 作为其服务的一部分由云提供商内部处理\n* 其他的...\n\n我将在接下来的章节中为您提供更具体的示例。\n\n## 重新启动\n\n与确保应用程序在启动时运行类似，您可能还想确保它在挂掉后重新启动。\n\n### 我们会犯错误\n\n作为人类，我们总是会犯错误。 软件几乎*总是*在不同的地方隐藏着bug。 🐛\n\n作为开发人员，当我们发现这些bug并实现新功能（也可能添加新bug😅）时，我们会不断改进代码。\n\n### 自动处理小错误\n\n使用 FastAPI 构建 Web API 时，如果我们的代码中存在错误，FastAPI 通常会将其包含到触发错误的单个请求中。 🛡\n\n对于该请求，客户端将收到 500 内部服务器错误，但应用程序将继续处理下一个请求，而不是完全崩溃。\n\n### 更大的错误 - 崩溃\n\n尽管如此，在某些情况下，我们编写的一些代码可能会导致整个应用程序崩溃，从而导致 Uvicorn 和 Python 崩溃。 💥\n\n尽管如此，您可能不希望应用程序因为某个地方出现错误而保持死机状态，您可能希望它继续运行，至少对于未破坏的*路径操作*。\n\n### 崩溃后重新启动\n\n但在那些严重错误导致正在运行的进程崩溃的情况下，您需要一个外部组件来负责重新启动进程，至少尝试几次......\n\n/// tip\n\n...尽管如果整个应用程序只是立即崩溃，那么永远重新启动它可能没有意义。 但在这些情况下，您可能会在开发过程中注意到它，或者至少在部署后立即注意到它。\n\n 因此，让我们关注主要情况，在未来的某些特定情况下，它可能会完全崩溃，但重新启动它仍然有意义。\n\n///\n\n您可能希望让这个东西作为 外部组件 负责重新启动您的应用程序，因为到那时，使用 Uvicorn 和 Python 的同一应用程序已经崩溃了，因此同一应用程序的相同代码中没有东西可以对此做出什么。\n\n### 自动重新启动的示例工具\n\n在大多数情况下，用于启动时运行程序的同一工具也用于处理自动重新启动。\n\n例如，可以通过以下方式处理：\n\n* Docker\n* Kubernetes\n* Docker Compose\n* Docker in Swarm mode\n* Systemd\n* Supervisor\n* 作为其服务的一部分由云提供商内部处理\n* 其他的...\n\n## 复制 - 进程和内存\n\n对于 FastAPI 应用程序，使用像 Uvicorn 这样的服务器程序，在一个进程中运行一次就可以同时为多个客户端提供服务。\n\n但在许多情况下，您会希望同时运行多个工作进程。\n\n### 多进程 - Workers\n\n如果您的客户端数量多于单个进程可以处理的数量（例如，如果虚拟机不是太大），并且服务器的 CPU 中有 多个核心，那么您可以让 多个进程 运行 同时处理同一个应用程序，并在它们之间分发所有请求。\n\n当您运行同一 API 程序的多个进程时，它们通常称为 workers。\n\n### 工作进程和端口\n\n还记得文档 [About HTTPS](https.md){.internal-link target=_blank} 中只有一个进程可以侦听服务器中的端口和 IP 地址的一种组合吗？\n\n现在仍然是对的。\n\n因此，为了能够同时拥有多个进程，必须有一个单个进程侦听端口，然后以某种方式将通信传输到每个工作进程。\n\n### 每个进程的内存\n\n现在，当程序将内容加载到内存中时，例如，将机器学习模型加载到变量中，或者将大文件的内容加载到变量中，所有这些都会消耗服务器的一点内存 (RAM) 。\n\n多个进程通常不共享任何内存。 这意味着每个正在运行的进程都有自己的东西、变量和内存。 如果您的代码消耗了大量内存，每个进程将消耗等量的内存。\n\n### 服务器内存\n\n例如，如果您的代码加载 1 GB 大小的机器学习模型，则当您使用 API 运行一个进程时，它将至少消耗 1 GB RAM。 如果您启动 4 个进程（4 个工作进程），每个进程将消耗 1 GB RAM。 因此，您的 API 总共将消耗 4 GB RAM。\n\n如果您的远程服务器或虚拟机只有 3 GB RAM，尝试加载超过 4 GB RAM 将导致问题。 🚨\n\n### 多进程 - 一个例子\n\n在此示例中，有一个 Manager Process 启动并控制两个 Worker Processes。\n\n该管理器进程可能是监听 IP 中的 端口 的进程。 它将所有通信传输到工作进程。\n\n这些工作进程将是运行您的应用程序的进程，它们将执行主要计算以接收 请求 并返回 响应，并且它们将加载您放入 RAM 中的变量中的任何内容。\n\n当然，除了您的应用程序之外，同一台机器可能还运行其他进程。\n\n一个有趣的细节是，随着时间的推移，每个进程使用的 CPU 百分比可能会发生很大变化，但内存 (RAM) 通常会或多或少保持稳定。\n\n如果您有一个每次执行相当数量的计算的 API，并且您有很多客户端，那么 CPU 利用率 可能也会保持稳定（而不是不断快速上升和下降）。\n\n### 复制工具和策略示例\n\n可以通过多种方法来实现这一目标，我将在接下来的章节中向您详细介绍具体策略，例如在谈论 Docker 和容器时。\n\n要考虑的主要限制是必须有一个单个组件来处理公共IP中的端口。 然后它必须有一种方法将通信传输到复制的进程/worker。\n\n以下是一些可能的组合和策略：\n\n* Gunicorn 管理 Uvicorn workers\n     * Gunicorn 将是监听 IP 和 端口 的 进程管理器，复制将通过 多个 Uvicorn 工作进程 进行\n* Uvicorn 管理 Uvicorn workers\n     * 一个 Uvicorn 进程管理器 将监听 IP 和 端口，并且它将启动 多个 Uvicorn 工作进程\n* Kubernetes 和其他分布式 容器系统\n     * Kubernetes 层中的某些东西将侦听 IP 和 端口。 复制将通过拥有多个容器，每个容器运行一个 Uvicorn 进程\n* 云服务 为您处理此问题\n     * 云服务可能为您处理复制。 它可能会让您定义 要运行的进程，或要使用的 容器映像，在任何情况下，它很可能是 单个 Uvicorn 进程，并且云服务将负责复制它。\n\n/// tip\n\n如果这些关于 容器、Docker 或 Kubernetes 的内容还没有多大意义，请不要担心。\n\n 我将在以后的章节中向您详细介绍容器镜像、Docker、Kubernetes 等：[容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank}。\n\n///\n\n## 启动之前的步骤\n\n在很多情况下，您希望在启动应用程序之前执行一些步骤。\n\n例如，您可能想要运行数据库迁移。\n\n但在大多数情况下，您只想执行这些步骤一次。\n\n因此，在启动应用程序之前，您将需要一个单个进程来执行这些前面的步骤。\n\n而且您必须确保它是运行前面步骤的单个进程, *即使*之后您为应用程序本身启动多个进程（多个worker）。 如果这些步骤由多个进程运行，它们会通过在并行运行来重复工作，并且如果这些步骤像数据库迁移一样需要小心处理，它们可能会导致每个进程和其他进程发生冲突。\n\n当然，也有一些情况，多次运行前面的步骤也没有问题，这样的话就好办多了。\n\n/// tip\n\n另外，请记住，根据您的设置，在某些情况下，您在开始应用程序之前可能甚至不需要任何先前的步骤。\n\n 在这种情况下，您就不必担心这些。 🤷\n\n///\n\n### 前面步骤策略的示例\n\n这将在很大程度上取决于您部署系统的方式，并且可能与您启动程序、处理重启等的方式有关。\n\n以下是一些可能的想法：\n\n* Kubernetes 中的“Init Container”在应用程序容器之前运行\n* 一个 bash 脚本，运行前面的步骤，然后启动您的应用程序\n     * 您仍然需要一种方法来启动/重新启动 bash 脚本、检测错误等。\n\n/// tip\n\n我将在以后的章节中为您提供使用容器执行此操作的更具体示例：[容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank}。\n\n///\n\n## 资源利用率\n\n您的服务器是一个资源，您可以通过您的程序消耗或利用CPU 上的计算时间以及可用的 RAM 内存。\n\n您想要消耗/利用多少系统资源？ 您可能很容易认为“不多”，但实际上，您可能希望在不崩溃的情况下尽可能多地消耗。\n\n如果您支付了 3 台服务器的费用，但只使用了它们的一点点 RAM 和 CPU，那么您可能浪费金钱 💸，并且可能 浪费服务器电力 🌎，等等。\n\n在这种情况下，最好只拥有 2 台服务器并使用更高比例的资源（CPU、内存、磁盘、网络带宽等）。\n\n另一方面，如果您有 2 台服务器，并且正在使用 100% 的 CPU 和 RAM，则在某些时候，一个进程会要求更多内存，并且服务器将不得不使用磁盘作为“内存” （这可能会慢数千倍），甚至崩溃。 或者一个进程可能需要执行一些计算，并且必须等到 CPU 再次空闲。\n\n在这种情况下，最好购买一台额外的服务器并在其上运行一些进程，以便它们都有足够的 RAM 和 CPU 时间。\n\n由于某种原因，您的 API 的使用量也有可能出现激增。 也许它像病毒一样传播开来，或者也许其他一些服务或机器人开始使用它。 在这些情况下，您可能需要额外的资源来保证安全。\n\n您可以将一个任意数字设置为目标，例如，资源利用率在 50% 到 90% 之间。 重点是，这些可能是您想要衡量和用来调整部署的主要内容。\n\n您可以使用“htop”等简单工具来查看服务器中使用的 CPU 和 RAM 或每个进程使用的数量。 或者您可以使用更复杂的监控工具，这些工具可能分布在服务器等上。\n\n## 回顾\n\n您在这里阅读了一些在决定如何部署应用程序时可能需要牢记的主要概念：\n\n* 安全性 - HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 开始前的先前步骤\n\n了解这些想法以及如何应用它们应该会给您足够的直觉在配置和调整部署时做出任何决定。 🤓\n\n在接下来的部分中，我将为您提供更具体的示例，说明您可以遵循的可能策略。 🚀']","根据上下文：  
1. Uvicorn的workers数量应与CPU核心数匹配，以充分利用多核并行处理能力。  
2. 并非越多越好，因每个worker独立占用内存，过多会导致内存不足（例：若单worker占1GB内存，4个worker需4GB）。  
3. 在Kubernetes等容器环境中，通常每个容器只需1个worker。",Uvicorn 的 workers 数量并非越多越好。官方建议的经验值通常是 CPU 核心数（num_cores）或 CPU 核心数 + 1。因为 Python 的全局解释器锁（GIL）限制了单个进程只能利用一个 CPU 核心，过多的 Worker 只会增加上下文切换的开销并消耗更多内存。在生产环境中，通常配合 Gunicorn 作为进程管理器，通过 `-w` 参数设置 worker 数量，并指定 `-k uvicorn.workers.UvicornWorker` 类。,0.99999999995,0.8571428571428571,0.8644179090207162
