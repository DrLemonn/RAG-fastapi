user_input,retrieved_contexts,response,reference,context_precision,faithfulness,answer_relevancy
怎么保证前端传给我的 JSON 数据里，'price' 字段一定是数字而不是字符串？如果不合法自动报错吗？,"['通过浏览器访问 http://127.0.0.1:8000/items/foo，接收如下 HTTP 错误信息：  \n```JSON\n{\n""detail"": [\n{\n""loc"": [\n""path"",\n""item_id""\n],\n""msg"": ""value is not a valid integer"",\n""type"": ""type_error.integer""\n}\n]\n}\n```  \n这是因为路径参数 `item_id` 的值 （`""foo""`）的类型不是 `int`。  \n值的类型不是 `int ` 而是浮点数（`float`）时也会显示同样的错误，比如： http://127.0.0.1:8000/items/4.2。  \n/// check | 检查  \nFastAPI 使用 Python 类型声明实现了数据校验。  \n注意，上面的错误清晰地指出了未通过校验的具体原因。  \n这在开发调试与 API 交互的代码时非常有用。  \n///', '运行示例并访问 http://127.0.0.1:8000/items/3，返回的响应如下：  \n```JSON\n{""item_id"":3}\n```  \n/// check | 检查  \n注意，函数接收并返回的值是 `3`（ `int`），不是 `""3""`（`str`）。  \nFastAPI 通过类型声明自动<abbr title=""将来自 HTTP 请求中的字符串转换为 Python 数据类型"">解析请求中的数据</abbr>。  \n///', '让我们从一个简单的 FastAPI 应用开始：  \n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\nname: str\nprice: float\n\n\nclass ResponseMessage(BaseModel):\nmessage: str\n\n\n@app.post(""/items/"", response_model=ResponseMessage)\nasync def create_item(item: Item):\nreturn {""message"": ""item received""}\n\n\n@app.get(""/items/"", response_model=list[Item])\nasync def get_items():\nreturn [\n{""name"": ""Plumbus"", ""price"": 3},\n{""name"": ""Portal Gun"", ""price"": 9001},\n]\n\n```  \n请注意，*路径操作* 定义了他们所用于请求数据和回应数据的模型，所使用的模型是`Item` 和 `ResponseMessage`。  \n### API 文档  \n如果您访问API文档，您将看到它具有在请求中发送和在响应中接收数据的模式(schemas)：  \n您可以看到这些模式，因为它们是用程序中的模型声明的。  \n那些信息可以在应用的 OpenAPI模式 被找到，然后显示在API文档中（通过Swagger UI）。  \nOpenAPI中所包含的模型里有相同的信息可以用于 生成客户端代码。  \n### 生成一个TypeScript 客户端  \n现在我们有了带有模型的应用，我们可以为前端生成客户端代码。  \n#### 安装 `openapi-ts`  \n您可以使用以下工具在前端代码中安装 `openapi-ts`:  \n```console\n$ npm install @hey-api/openapi-ts --save-dev\n\n&gt; 100%\n```  \n#### 生成客户端代码  \n要生成客户端代码，您可以使用现在将要安装的命令行应用程序 `openapi-ts`。  \n因为它安装在本地项目中，所以您可能无法直接使用此命令，但您可以将其放在 `package.json` 文件中。  \n它可能看起来是这样的:  \n```JSON  hl_lines=""7""\n{\n""name"": ""frontend-app"",\n""version"": ""1.0.0"",\n""description"": """",\n""main"": ""index.js"",\n""scripts"": {\n""generate-client"": ""openapi-ts --input http://localhost:8000/openapi.json --output ./src/client --client axios""\n},\n""author"": """",\n""license"": """",\n""devDependencies"": {\n""@hey-api/openapi-ts"": ""^0.27.38"",\n""typescript"": ""^4.6.2""\n}\n}\n```  \n在这里添加 NPM `generate-client` 脚本后，您可以使用以下命令运行它:  \n```console\n$ npm run generate-client\n\nfrontend-app@1.0.0 generate-client /home/user/code/frontend-app\n&gt; openapi-ts --input http://localhost:8000/openapi.json --output ./src/client --client axios\n```  \n此命令将在 `./src/client` 中生成代码，并将在其内部使用 `axios`（前端HTTP库）。  \n### 尝试客户端代码  \n现在您可以导入并使用客户端代码，它可能看起来像这样，请注意，您可以为这些方法使用自动补全：  \n您还将自动补全要发送的数据：  \n/// tip  \n请注意， `name` 和 `price` 的自动补全，是通过其在`Item`模型(FastAPI)中的定义实现的。  \n///  \n如果发送的数据字段不符，你也会看到编辑器的错误提示:  \n响应(response)对象也拥有自动补全:', '数值校验同样适用于 `float` 值。  \n能够声明 <abbr title=""大于""><code>gt</code></abbr> 而不仅仅是 <abbr title=""大于等于""><code>ge</code></abbr> 在这个前提下变得重要起来。例如，你可以要求一个值必须大于 `0`，即使它小于 `1`。  \n因此，`0.5` 将是有效值。但是 `0.0`或 `0` 不是。  \n对于 <abbr title=""less than""><code>lt</code></abbr> 也是一样的。  \n```py\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Path, Query\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_items(\n*,\nitem_id: Annotated[int, Path(title=""The ID of the item to get"", ge=0, le=1000)],\nq: str,\nsize: Annotated[float, Query(gt=0, lt=10.5)],\n):\nresults = {""item_id"": item_id}\nif q:\nresults.update({""q"": q})\nif size:\nresults.update({""size"": size})\nreturn results\n\n```']","在FastAPI中使用Pydantic模型（如定义`price: float`）会自动校验数据类型，若字段类型不匹配（如字符串传入数字字段），会返回包含具体错误详情的HTTP响应（如`""type_error.float""`）。非法数据会触发自动报错，无需手动处理。上下文中的错误示例和模型定义已证明此机制。",你应该使用 Pydantic 模型来定义数据结构。通过创建一个继承自 `pydantic.BaseModel` 的类，并将 'price' 字段声明为 `float` 或 `int` 类型（例如 `price: float`），FastAPI 会自动进行数据校验。如果前端传来的数据类型不匹配（且无法转换），FastAPI 会自动拦截请求并返回 422 Unprocessable Entity 错误，其中包含详细的错误信息，无需手动编写报错逻辑。,0.999999999975,0.8888888888888888,0.39263620785672226
我想在好几个接口里复用同一段代码，比如检查用户 Token，但我不想写装饰器，也不想在每个函数里写一遍调用。,"['这个示例看起来有些冗长。毕竟这个文件同时包含了安全、数据模型的工具函数，以及路径操作等代码。  \n但，关键是：  \n安全和依赖注入的代码只需要写一次。  \n就算写得再复杂，也只是在一个位置写一次就够了。所以，要多复杂就可以写多复杂。  \n但是，就算有数千个端点（*路径操作*），它们都可以使用同一个安全系统。  \n而且，所有端点（或它们的任何部件）都可以利用这些依赖项或任何其它依赖项。  \n所有*路径操作*只需 3 行代码就可以了：  \n> *[Ref: Code file `tutorial002_an_py39.py` is already included above]*', '编程中的「依赖注入」是声明代码（本文中为*路径操作函数* ）运行所需的，或要使用的「依赖」的一种方式。  \n然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。  \n依赖注入常用于以下场景：  \n* 共享业务逻辑（复用相同的代码逻辑）\n* 共享数据库连接\n* 实现安全、验证、角色权限\n* 等……  \n上述场景均可以使用依赖注入，将代码重复最小化。', 'FastAPI** 的核心思想就是减少代码重复。  \n代码重复会导致 bug、安全问题、代码失步等问题（更新了某个位置的代码，但没有同步更新其它位置的代码）。  \n上面的这些模型共享了大量数据，拥有重复的属性名和类型。  \nFastAPI 可以做得更好。  \n声明 `UserBase` 模型作为其它模型的基类。然后，用该类衍生出继承其属性（类型声明、验证等）的子类。  \n所有数据转换、校验、文档等功能仍将正常运行。  \n这样，就可以仅声明模型之间的差异部分（具有明文的 `password`、具有 `hashed_password` 以及不包括密码）。  \n通过这种方式，可以只声明模型之间的区别（分别包含明文密码、哈希密码，以及无密码的模型）。  \n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n\nclass UserBase(BaseModel):\nusername: str\nemail: EmailStr\nfull_name: str | None = None\n\n\nclass UserIn(UserBase):\npassword: str\n\n\nclass UserOut(UserBase):\npass\n\n\nclass UserInDB(UserBase):\nhashed_password: str\n\n\ndef fake_password_hasher(raw_password: str):\nreturn ""supersecret"" + raw_password\n\n\ndef fake_save_user(user_in: UserIn):\nhashed_password = fake_password_hasher(user_in.password)\nuser_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password)\nprint(""User saved! ..not really"")\nreturn user_in_db\n\n\n@app.post(""/user/"", response_model=UserOut)\nasync def create_user(user_in: UserIn):\nuser_saved = fake_save_user(user_in)\nreturn user_saved\n\n```', '让我们从一个示例用例开始，看看如何解决它。  \n假设你有几个机器学习的模型，你想要用它们来处理请求。  \n相同的模型在请求之间是共享的，因此并非每个请求或每个用户各自拥有一个模型。  \n假设加载模型可能需要相当长的时间，因为它必须从磁盘读取大量数据。因此你不希望每个请求都加载它。  \n你可以在模块/文件的顶部加载它，但这也意味着即使你只是在运行一个简单的自动化测试，它也会加载模型，这样测试将变慢，因为它必须在能够独立运行代码的其他部分之前等待模型加载完成。  \n这就是我们要解决的问题——在处理请求前加载模型，但只是在应用开始接收请求前，而不是代码执行时。']",基于上下文，FastAPI的依赖注入功能可解决此问题：定义一个检查Token的依赖函数，然后在多个接口中使用`Depends`声明该依赖项，无需重复代码或装饰器。这样只需写一次逻辑，所有路径操作均可复用。上下文明确说明依赖注入专用于此类共享逻辑（如安全验证），以减少代码重复。,你应该使用 FastAPI 的依赖注入系统（Dependency Injection）。你可以定义一个普通的函数（例如 `get_current_user`）来包含 Token 检查逻辑，然后在需要的路由函数参数中使用 `Depends(get_current_user)`。这比装饰器更灵活，因为依赖项可以像普通函数一样接收参数，并且可以被 FastAPI 自动处理和测试，同时也支持依赖项的嵌套。,0.99999999995,0.75,0.6599671731216813
如何在 FastAPI 的 settings.py 里配置内置的 ORM 连接数据库？,"['# SQL（关系型）数据库  \nFastAPI 并不要求您使用 SQL（关系型）数据库。您可以使用任何想用的数据库。  \n这里，我们来看一个使用 SQLModel 的示例。  \nSQLModel 是基于 SQLAlchemy 和 Pydantic 构建的。它由 FastAPI 的同一作者制作，旨在完美匹配需要使用 SQL 数据库的 FastAPI 应用程序。  \n/// tip  \n您可以使用任何其他您想要的 SQL 或 NoSQL 数据库（在某些情况下称为 <abbr title=""对象关系映射器（Object Relational Mapper，ORM），一个术语，用来指代一种库，其中某些类对应于 SQL 数据表，这些类的实例则对应于表中的行。"">“ORM”</abbr>），FastAPI 不会强迫您使用任何东西。😎  \n///  \n由于 SQLModel 基于 SQLAlchemy，因此您可以轻松使用任何由 SQLAlchemy 支持的数据库（这也让它们被 SQLModel 支持），例如：  \n* PostgreSQL\n* MySQL\n* SQLite\n* Oracle\n* Microsoft SQL Server 等.  \n在这个例子中，我们将使用 SQLite，因为它使用单个文件，并且 Python 对其有集成支持。因此，您可以直接复制这个例子并运行。  \n之后，对于您的生产应用程序，您可能会想要使用像 PostgreSQL 这样的数据库服务器。  \n/// tip  \n有一个使用 FastAPI 和 PostgreSQL 的官方的项目生成器，其中包括了前端和更多工具： https://github.com/fastapi/full-stack-fastapi-template  \n///  \n这是一个非常简单和简短的教程。如果您想了解一般的数据库、SQL 或更高级的功能，请查看 SQLModel 文档。', '幸运的是，Pydantic 提供了一个很好的工具来处理来自环境变量的设置，即Pydantic: Settings management。  \n### 创建 `Settings` 对象  \n从 Pydantic 导入 `BaseSettings` 并创建一个子类，与 Pydantic 模型非常相似。  \n与 Pydantic 模型一样，您使用类型注释声明类属性，还可以指定默认值。  \n您可以使用与 Pydantic 模型相同的验证功能和工具，比如不同的数据类型和使用 `Field()` 进行附加验证。  \n```py\nfrom fastapi import FastAPI\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\napp_name: str = ""Awesome API""\nadmin_email: str\nitems_per_user: int = 50\n\n\nsettings = Settings()\napp = FastAPI()\n\n\n@app.get(""/info"")\nasync def info():\nreturn {\n""app_name"": settings.app_name,\n""admin_email"": settings.admin_email,\n""items_per_user"": settings.items_per_user,\n}\n\n```  \n/// tip  \n如果您需要一个快速的复制粘贴示例，请不要使用此示例，而应使用下面的最后一个示例。  \n///  \n然后，当您创建该 `Settings` 类的实例（在此示例中是 `settings` 对象）时，Pydantic 将以不区分大小写的方式读取环境变量，因此，大写的变量 `APP_NAME` 仍将为属性 `app_name` 读取。  \n然后，它将转换和验证数据。因此，当您使用该 `settings` 对象时，您将获得您声明的类型的数据（例如 `items_per_user` 将为 `int` 类型）。  \n### 使用 `settings`  \n然后，您可以在应用程序中使用新的 `settings` 对象：  \n> *[Ref: Code file `tutorial001_py39.py` is already included above]*  \n### 运行服务器  \n接下来，您将运行服务器，并将配置作为环境变量传递。例如，您可以设置一个 `ADMIN_EMAIL` 和 `APP_NAME`，如下所示：  \n```console\n$ ADMIN_EMAIL=""deadpool@example.com"" APP_NAME=""ChimichangApp""uvicorn main:app\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```  \n/// tip  \n要为单个命令设置多个环境变量，只需用空格分隔它们，并将它们全部放在命令之前。  \n///  \n然后，`admin_email` 设置将为 `""deadpool@example.com""`。  \n`app_name` 将为 `""ChimichangApp""`。  \n而 `items_per_user` 将保持其默认值为 `50`。', '依赖注入系统如此简洁的特性，让 FastAPI 可以与下列系统兼容：  \n* 关系型数据库\n* NoSQL 数据库\n* 外部支持库\n* 外部 API\n* 认证和鉴权系统\n* API 使用监控系统\n* 响应数据注入系统\n* 等等……', '您可以使用 Pydantic 设置处理应用程序的设置或配置，利用 Pydantic 模型的所有功能。  \n* 通过使用依赖项，您可以简化测试。\n* 您可以使用 `.env` 文件。\n* 使用 `@lru_cache` 可以避免为每个请求重复读取 dotenv 文件，同时允许您在测试时进行覆盖。']",根据上下文，FastAPI 使用 SQLModel（基于 SQLAlchemy）连接数据库时，需在 Pydantic 的 `Settings` 类中定义数据库配置参数（如连接 URL），并通过环境变量注入。但上下文未展示具体的数据库配置字段（如数据库 URL 的声明），因此无法提供确切代码示例。建议查阅 SQLModel 文档获取详细配置方法。,"这是一个误解。FastAPI 是一个无主见（Unopinionated）的框架，它没有内置的 ORM（对象关系映射）或类似 Django 的 `settings.py` 配置文件。你可以自由选择任何数据库库（如 SQLAlchemy, SQLModel, Tortoise ORM 等）。通常，我们会使用 Pydantic 的 `BaseSettings` 来管理环境变量和配置，并在单独的文件（如 `database.py`）中手动初始化数据库连接。",0.9166666666361111,0.875,0.0
为什么我在 path operation 里用了 threading.Thread 去开新线程处理任务，请求还是阻塞了？,"['# 并发 async / await  \n有关路径操作函数的 `async def` 语法以及异步代码、并发和并行的一些背景知识。', '/// warning  \n你可以跳过这里。  \n这些都是 FastAPI 如何在内部工作的技术细节。  \n如果你有相当多的技术知识（协程、线程、阻塞等），并且对 FastAPI 如何处理 `async def` 与常规 `def` 感到好奇，请继续。  \n///  \n### 路径操作函数  \n当你使用 `def` 而不是 `async def` 来声明一个*路径操作函数*时，它运行在外部的线程池中并等待其结果，而不是直接调用（因为它会阻塞服务器）。  \n如果你使用过另一个不以上述方式工作的异步框架，并且你习惯于用普通的 `def` 定义普通的仅计算路径操作函数，以获得微小的性能增益（大约100纳秒），请注意，在 FastAPI 中，效果将完全相反。在这些情况下，最好使用 `async def`，除非路径操作函数内使用执行阻塞 <abbr title=""输入/输出：磁盘读写，网络通讯."">I/O</abbr> 的代码。  \n在这两种情况下，与你之前的框架相比，FastAPI 可能[仍然很快](index.md#_11){.internal-link target=_blank}。  \n### 依赖  \n这同样适用于[依赖](tutorial/dependencies/index.md){.internal-link target=_blank}。如果一个依赖是标准的 `def` 函数而不是 `async def`，它将被运行在外部线程池中。  \n### 子依赖  \n你可以拥有多个相互依赖的依赖以及[子依赖](tutorial/dependencies/sub-dependencies.md){.internal-link target=_blank} （作为函数的参数），它们中的一些可能是通过 `async def` 声明，也可能是通过 `def` 声明。它们仍然可以正常工作，这些通过 `def` 声明的函数将会在外部线程中调用（来自线程池），而不是""被等待""。  \n### 其他函数  \n你可直接调用通过 `def` 或 `async def` 创建的任何其他函数，FastAPI 不会影响你调用它们的方式。  \n这与 FastAPI 为你调用*路径操作函数*和依赖项的逻辑相反。  \n如果你的函数是通过 `def` 声明的，它将被直接调用（在代码中编写的地方），而不会在线程池中，如果这个函数通过 `async def` 声明，当在代码中调用时，你就应该使用 `await` 等待函数的结果。  \n再次提醒，这些是非常技术性的细节，如果你来搜索它可能对你有用。  \n否则，你最好应该遵守的指导原则赶时间吗？.', '异步代码仅仅意味着编程语言 💬 有办法告诉计算机/程序 🤖 在代码中的某个点，它 🤖 将不得不等待在某些地方完成一些事情。让我们假设一些事情被称为 ""慢文件""📝.  \n所以，在等待""慢文件""📝完成的这段时间，计算机可以做一些其他工作。  \n然后计算机/程序 🤖 每次有机会都会回来，因为它又在等待，或者它 🤖 完成了当前所有的工作。而且它 🤖 将查看它等待的所有任务中是否有已经完成的，做它必须做的任何事情。  \n接下来，它 🤖 完成第一个任务（比如是我们的""慢文件""📝) 并继续与之相关的一切。  \n这个""等待其他事情""通常指的是一些相对较慢（与处理器和 RAM 存储器的速度相比）的 <abbr title=""Input and Output"">I/O</abbr> 操作，比如说：  \n* 通过网络发送来自客户端的数据\n* 客户端接收来自网络中的数据\n* 磁盘中要由系统读取并提供给程序的文件的内容\n* 程序提供给系统的要写入磁盘的内容\n* 一个 API 的远程调用\n* 一个数据库操作，直到完成\n* 一个数据库查询，直到返回结果\n* 等等.  \n这个执行的时间大多是在等待 <abbr title=""Input and Output"">I/O</abbr> 操作，因此它们被叫做 ""I/O 密集型"" 操作。  \n它被称为""异步""的原因是因为计算机/程序不必与慢任务""同步""，去等待任务完成的确切时刻，而在此期间不做任何事情直到能够获取任务结果才继续工作。  \n相反，作为一个""异步""系统，一旦完成，任务就可以排队等待一段时间（几微秒），等待计算机程序完成它要做的任何事情，然后回来获取结果并继续处理它们。  \n对于""同步""（与""异步""相反），他们通常也使用""顺序""一词，因为计算机程序在切换到另一个任务之前是按顺序执行所有步骤，即使这些步骤涉及到等待。  \n### 并发与汉堡  \n上述异步代码的思想有时也被称为“并发”，它不同于“并行”。  \n并发和并行都与“不同的事情或多或少同时发生”有关。  \n但是并发和并行之间的细节是完全不同的。  \n要了解差异，请想象以下关于汉堡的故事：  \n### 并发汉堡  \n你和你的恋人一起去快餐店，你排队在后面，收银员从你前面的人接单。😍  \n然后轮到你了，你为你的恋人和你选了两个非常豪华的汉堡。🍔🍔  \n收银员对厨房里的厨师说了一些话，让他们知道他们必须为你准备汉堡（尽管他们目前正在为之前的顾客准备汉堡）。  \n你付钱了。 💸  \n收银员给你轮到的号码。  \n当你在等待的时候，你和你的恋人一起去挑选一张桌子，然后你们坐下来聊了很长时间（因为汉堡很豪华，需要一些时间来准备）。  \n当你和你的恋人坐在桌子旁，等待汉堡的时候，你可以用这段时间来欣赏你的恋人是多么的棒、可爱和聪明✨😍✨。  \n在等待中和你的恋人交谈时，你会不时地查看柜台上显示的号码，看看是否已经轮到你了。  \n然后在某个时刻，终于轮到你了。你去柜台拿汉堡然后回到桌子上。  \n你们享用了汉堡，整个过程都很开心。✨  \n/// info  \n漂亮的插画来自 Ketrina Thompson. 🎨  \n///  \n在那个故事里，假设你是计算机程序 🤖 。  \n当你在排队时，你只是闲着😴， 轮到你前不做任何事情（仅排队）。但排队很快，因为收银员只接订单（不准备订单），所以这一切都还好。  \n然后，当轮到你时，需要你做一些实际性的工作，比如查看菜单，决定你想要什么，让你的恋人选择，支付，检查你是否提供了正确的账单或卡，检查你的收费是否正确，检查订单是否有正确的项目，等等。  \n此时，即使你仍然没有汉堡，你和收银员的工作也""暂停""了⏸， 因为你必须等待一段时间 🕙 让你的汉堡做好。  \n但是，当你离开柜台并坐在桌子旁，在轮到你的号码前的这段时间，你可以将焦点切换到 🔀 你的恋人上，并做一些""工作""⏯ 🤓。你可以做一些非常""有成效""的事情，比如和你的恋人调情😍.  \n之后，收银员 💁 把号码显示在显示屏上，并说到 ""汉堡做好了""，而当显示的号码是你的号码时，你不会立刻疯狂地跳起来。因为你知道没有人会偷你的汉堡，因为你有你的号码，而其他人又有他们自己的号码。  \n所以你要等待你的恋人完成故事（完成当前的工作⏯ /正在做的事🤓)， 轻轻微笑，说你要吃汉堡⏸.  \n然后你去柜台🔀， 到现在初始任务已经完成⏯， 拿起汉堡，说声谢谢，然后把它们送到桌上。这就完成了与计数器交互的步骤/任务⏹. 这反过来又产生了一项新任务，即""吃汉堡""🔀 ⏯， 上一个""拿汉堡""的任务已经结束了⏹.  \n### 并行汉堡  \n现在让我们假设不是""并发汉堡""，而是""并行汉堡""。  \n你和你的恋人一起去吃并行快餐。  \n你站在队伍中，同时是厨师的几个收银员（比方说8个）从前面的人那里接单。  \n你之前的每个人都在等待他们的汉堡准备好后才离开柜台，因为8名收银员都会在下一份订单前马上准备好汉堡。  \n然后，终于轮到你了，你为你的恋人和你订购了两个非常精美的汉堡。  \n你付钱了 💸。  \n收银员去厨房。  \n你站在柜台前 🕙等待着，这样就不会有人在你之前抢走你的汉堡，因为没有轮流的号码。  \n当你和你的恋人忙于不让任何人出现在你面前，并且在他们到来的时候拿走你的汉堡时，你无法关注到你的恋人。😞  \n这是""同步""的工作，你被迫与服务员/厨师 👨🍳""同步""。你在此必须等待 🕙 ，在收银员/厨师 👨🍳 完成汉堡并将它们交给你的确切时间到达之前一直等待，否则其他人可能会拿走它们。  \n你经过长时间的等待 🕙 ，收银员/厨师 👨🍳终于带着汉堡回到了柜台。  \n你拿着汉堡，和你的情人一起上桌。  \n你们仅仅是吃了它们，就结束了。⏹  \n没有太多的交谈或调情，因为大部分时间 🕙 都在柜台前等待😞。  \n/// info  \n漂亮的插画来自 Ketrina Thompson. 🎨  \n///  \n在这个并行汉堡的场景中，你是一个计算机程序 🤖 且有两个处理器（你和你的恋人），都在等待 🕙 ，并投入他们的注意力 ⏯ 在柜台上等待了很长一段时间。  \n这家快餐店有 8 个处理器（收银员/厨师）。而并发汉堡店可能只有 2 个（一个收银员和一个厨师）。  \n但最终的体验仍然不是最好的。😞  \n这将是与汉堡的类似故事。🍔  \n一种更""贴近生活""的例子，想象一家银行。  \n直到最近，大多数银行都有多个出纳员 👨💼👨💼👨💼👨💼 还有一条长长排队队伍🕙🕙🕙🕙🕙🕙🕙🕙。  \n所有收银员都是一个接一个的在客户面前做完所有的工作👨💼⏯.  \n你必须经过 🕙 较长时间排队，否则你就没机会了。  \n你可不会想带你的恋人 😍 和你一起去银行办事🏦.  \n### 汉堡结论  \n在""你与恋人一起吃汉堡""的这个场景中，因为有很多人在等待🕙， 使用并发系统更有意义⏸🔀⏯.  \n大多数 Web 应用都是这样的。  \n你的服务器正在等待很多很多用户通过他们不太好的网络发送来的请求。  \n然后再次等待 🕙 响应回来。  \n这个""等待"" 🕙 是以微秒为单位测量的，但总的来说，最后还是等待很久。  \n这就是为什么使用异步对于 Web API 很有意义的原因 ⏸🔀⏯。  \n这种异步机制正是 NodeJS 受到欢迎的原因（尽管 NodeJS 不是并行的），以及 Go 作为编程语言的优势所在。  \n这与 FastAPI 的性能水平相同。  \n你可以同时拥有并行性和异步性，你可以获得比大多数经过测试的 NodeJS 框架更高的性能，并且与 Go 不相上下， Go 是一种更接近于 C 的编译语言（全部归功于 Starlette）。  \n### 并发比并行好吗？  \n不！这不是故事的本意。  \n并发不同于并行。而是在需要大量等待的特定场景下效果更好。因此，在 Web 应用程序开发中，它通常比并行要好得多，但这并不意味着全部。  \n因此，为了平衡这一点，想象一下下面的短篇故事：  \n&gt; 你必须打扫一个又大又脏的房子。  \n*是的，这就是完整的故事。*  \n在任何地方， 都不需要等待 🕙 ，只需要在房子的多个地方做着很多工作。  \n你可以像汉堡的例子那样轮流执行，先是客厅，然后是厨房，但因为你不需要等待 🕙 ，对于任何事情都是清洁，清洁，还是清洁，轮流不会影响任何事情。  \n无论是否轮流执行（并发），都需要相同的时间来完成，而你也会完成相同的工作量。  \n但在这种情况下，如果你能带上 8 名前收银员/厨师，现在是清洁工一起清扫，他们中的每一个人（加上你）都能占据房子的一个区域来清扫，你就可以在额外的帮助下并行的更快地完成所有工作。  \n在这个场景中，每个清洁工（包括你）都将是一个处理器，完成这个工作的一部分。  \n由于大多数执行时间是由实际工作（而不是等待）占用的，并且计算机中的工作是由 <abbr title=""Central Processing Unit"">CPU</abbr> 完成的，所以他们称这些问题为""CPU 密集型""。  \nCPU 密集型操作的常见示例是需要复杂的数学处理。  \n例如：  \n* 音频或图像处理；\n* 计算机视觉: 一幅图像由数百万像素组成，每个像素有3种颜色值，处理通常需要同时对这些像素进行计算；\n* 机器学习: 它通常需要大量的""矩阵""和""向量""乘法。想象一个包含数字的巨大电子表格，并同时将所有数字相乘；\n* 深度学习: 这是机器学习的一个子领域，同样适用。只是没有一个数字的电子表格可以相乘，而是一个庞大的数字集合，在很多情况下，你需要使用一个特殊的处理器来构建和使用这些模型。  \n### 并发 + 并行: Web + 机器学习  \n使用 FastAPI，你可以利用 Web 开发中常见的并发机制的优势（NodeJS 的主要吸引力）。  \n并且，你也可以利用并行和多进程（让多个进程并行运行）的优点来处理与机器学习系统中类似的 CPU 密集型 工作。  \n这一点，再加上 Python 是数据科学、机器学习（尤其是深度学习）的主要语言这一简单事实，使得 FastAPI 与数据科学/机器学习 Web API 和应用程序（以及其他许多应用程序）非常匹配。  \n了解如何在生产环境中实现这种并行性，可查看此文 [Deployment](deployment/index.md){.internal-link target=_blank}。', '现代版本的 Python 有一种非常直观的方式来定义异步代码。这使它看起来就像正常的""顺序""代码，并在适当的时候""等待""。  \n当有一个操作需要等待才能给出结果，且支持这个新的 Python 特性时，你可以编写如下代码：  \n```Python\nburgers = await get_burgers(2)\n```  \n这里的关键是 `await`。它告诉 Python 它必须等待 ⏸ `get_burgers(2)` 完成它的工作 🕙 ，然后将结果存储在 `burgers` 中。这样，Python 就会知道此时它可以去做其他事情 🔀 ⏯ （比如接收另一个请求）。  \n要使 `await` 工作，它必须位于支持这种异步机制的函数内。因此，只需使用 `async def` 声明它：  \n```Python hl_lines=""1""\nasync def get_burgers(number: int):\n# Do some asynchronous stuff to create the burgers\nreturn burgers\n```  \n...而不是 `def`:  \n```Python hl_lines=""2""\n# This is not asynchronous\ndef get_sequential_burgers(number: int):\n# Do some sequential stuff to create the burgers\nreturn burgers\n```  \n使用 `async def`，Python 就知道在该函数中，它将遇上 `await`，并且它可以""暂停"" ⏸ 执行该函数，直至执行其他操作 🔀 后回来。  \n当你想调用一个 `async def` 函数时，你必须""等待""它。因此，这不会起作用：  \n```Python\n# This won\'t work, because get_burgers was defined with: async def\nburgers = get_burgers(2)\n```  \n因此，如果你使用的库告诉你可以使用 `await` 调用它，则需要使用 `async def` 创建路径操作函数 ，如：  \n```Python hl_lines=""2-3""\n@app.get(\'/burgers\')\nasync def read_burgers():\nburgers = await get_burgers(2)\nreturn burgers\n```  \n### 更多技术细节  \n你可能已经注意到，`await` 只能在 `async def` 定义的函数内部使用。  \n但与此同时，必须""等待""通过 `async def` 定义的函数。因此，带 `async def` 的函数也只能在 `async def` 定义的函数内部调用。  \n那么，这关于先有鸡还是先有蛋的问题，如何调用第一个 `async` 函数？  \n如果你使用 FastAPI，你不必担心这一点，因为""第一个""函数将是你的路径操作函数，FastAPI 将知道如何做正确的事情。  \n但如果你想在没有 FastAPI 的情况下使用 `async` / `await`，则可以这样做。  \n### 编写自己的异步代码  \nStarlette （和 FastAPI） 是基于 AnyIO 实现的，这使得它们可以兼容 Python 的标准库 asyncio 和 Trio。  \n特别是，你可以直接使用 AnyIO 来处理高级的并发用例，这些用例需要在自己的代码中使用更高级的模式。  \n即使你没有使用 FastAPI，你也可以使用 AnyIO 编写自己的异步程序，使其拥有较高的兼容性并获得一些好处（例如， 结构化并发）。  \n我（指原作者 —— 译者注）基于 AnyIO 新建了一个库，作为一个轻量级的封装层，用来优化类型注解，同时提供了更好的自动补全、内联错误提示等功能。这个库还附带了一个友好的入门指南和教程，能帮助你理解并编写自己的异步代码：Asyncer。如果你有结合使用异步代码和常规（阻塞/同步）代码的需求，这个库会特别有用。  \n### 其他形式的异步代码  \n这种使用 `async` 和 `await` 的风格在语言中相对较新。  \n但它使处理异步代码变得容易很多。  \n这种相同的语法（或几乎相同）最近也包含在现代版本的 JavaScript 中（在浏览器和 NodeJS 中）。  \n但在此之前，处理异步代码非常复杂和困难。  \n在以前版本的 Python，你可以使用多线程或者 Gevent。但代码的理解、调试和思考都要复杂许多。  \n在以前版本的 NodeJS / 浏览器 JavaScript 中，你会使用""回调""，因此也可能导致“回调地狱”。']","根据上下文，你在路径操作中使用 `threading.Thread` 仍阻塞的原因是：  
1. **FastAPI 的异步机制**：`async def` 路径操作通过事件循环处理并发，而 `threading.Thread` 是同步阻塞操作，会破坏事件循环的非阻塞特性。  
2. **线程池限制**：即使 `def` 路径操作由线程池处理，手动创建线程仍可能受限于 GIL 或 I/O 阻塞，无法释放主线程。  
3. **正确做法**：应改用 `async def` + `await` 或专为异步设计的库（如 `anyio`/`asyncio`）处理 I/O 任务。  

（上下文未提及 `threading.Thread` 的具体兼容性，但明确强调同步阻塞操作会破坏异步并发模型。）",如果在 `async def` 定义的路由中执行耗时操作（即使是启动线程的开销），仍可能阻塞主事件循环（Event Loop）。FastAPI 的 `async def` 路由运行在单线程循环中。如果你需要进行阻塞性操作或利用多核 CPU，建议不要手动管理 `threading.Thread`，而是将路由定义为普通的 `def`（FastAPI 会自动将其放入外部线程池运行），或者使用 `fastapi.concurrency.run_in_threadpool` 显式将任务派发到线程池。,0.99999999995,0.4444444444444444,0.7832532516767347
我要做计算密集型任务，应该用 async def 还是普通的 def？这跟 Node.js 的处理方式一样吗？,"['<abbr title=""too long; didn\'t read(长文警告)"">TL;DR:</abbr>  \n如果你正在使用第三方库，它们会告诉你使用 `await` 关键字来调用它们，就像这样：  \n```Python\nresults = await some_library()\n```  \n然后，通过 `async def` 声明你的 *路径操作函数*：  \n```Python hl_lines=""2""\n@app.get(\'/\')\nasync def read_results():\nresults = await some_library()\nreturn results\n```  \n/// note  \n你只能在被 `async def` 创建的函数内使用 `await`  \n///  \n如果你正在使用一个第三方库和某些组件（比如：数据库、API、文件系统...）进行通信，第三方库又不支持使用 `await` （目前大多数数据库三方库都是这样），这种情况你可以像平常那样使用 `def` 声明一个路径操作函数，就像这样：  \n```Python hl_lines=""2""\n@app.get(\'/\')\ndef results():\nresults = some_library()\nreturn results\n```  \n如果你的应用程序不需要与其他任何东西通信而等待其响应，请使用 `async def`。  \n如果你不清楚，使用 `def` 就好.  \n注意：你可以根据需要在路径操作函数中混合使用 `def` 和 `async def`，并使用最适合你的方式去定义每个函数。FastAPI 将为他们做正确的事情。  \n无论如何，在上述任何情况下，FastAPI 仍将异步工作，速度也非常快。  \n但是，通过遵循上述步骤，它将能够进行一些性能优化。', '现代版本的 Python 有一种非常直观的方式来定义异步代码。这使它看起来就像正常的""顺序""代码，并在适当的时候""等待""。  \n当有一个操作需要等待才能给出结果，且支持这个新的 Python 特性时，你可以编写如下代码：  \n```Python\nburgers = await get_burgers(2)\n```  \n这里的关键是 `await`。它告诉 Python 它必须等待 ⏸ `get_burgers(2)` 完成它的工作 🕙 ，然后将结果存储在 `burgers` 中。这样，Python 就会知道此时它可以去做其他事情 🔀 ⏯ （比如接收另一个请求）。  \n要使 `await` 工作，它必须位于支持这种异步机制的函数内。因此，只需使用 `async def` 声明它：  \n```Python hl_lines=""1""\nasync def get_burgers(number: int):\n# Do some asynchronous stuff to create the burgers\nreturn burgers\n```  \n...而不是 `def`:  \n```Python hl_lines=""2""\n# This is not asynchronous\ndef get_sequential_burgers(number: int):\n# Do some sequential stuff to create the burgers\nreturn burgers\n```  \n使用 `async def`，Python 就知道在该函数中，它将遇上 `await`，并且它可以""暂停"" ⏸ 执行该函数，直至执行其他操作 🔀 后回来。  \n当你想调用一个 `async def` 函数时，你必须""等待""它。因此，这不会起作用：  \n```Python\n# This won\'t work, because get_burgers was defined with: async def\nburgers = get_burgers(2)\n```  \n因此，如果你使用的库告诉你可以使用 `await` 调用它，则需要使用 `async def` 创建路径操作函数 ，如：  \n```Python hl_lines=""2-3""\n@app.get(\'/burgers\')\nasync def read_burgers():\nburgers = await get_burgers(2)\nreturn burgers\n```  \n### 更多技术细节  \n你可能已经注意到，`await` 只能在 `async def` 定义的函数内部使用。  \n但与此同时，必须""等待""通过 `async def` 定义的函数。因此，带 `async def` 的函数也只能在 `async def` 定义的函数内部调用。  \n那么，这关于先有鸡还是先有蛋的问题，如何调用第一个 `async` 函数？  \n如果你使用 FastAPI，你不必担心这一点，因为""第一个""函数将是你的路径操作函数，FastAPI 将知道如何做正确的事情。  \n但如果你想在没有 FastAPI 的情况下使用 `async` / `await`，则可以这样做。  \n### 编写自己的异步代码  \nStarlette （和 FastAPI） 是基于 AnyIO 实现的，这使得它们可以兼容 Python 的标准库 asyncio 和 Trio。  \n特别是，你可以直接使用 AnyIO 来处理高级的并发用例，这些用例需要在自己的代码中使用更高级的模式。  \n即使你没有使用 FastAPI，你也可以使用 AnyIO 编写自己的异步程序，使其拥有较高的兼容性并获得一些好处（例如， 结构化并发）。  \n我（指原作者 —— 译者注）基于 AnyIO 新建了一个库，作为一个轻量级的封装层，用来优化类型注解，同时提供了更好的自动补全、内联错误提示等功能。这个库还附带了一个友好的入门指南和教程，能帮助你理解并编写自己的异步代码：Asyncer。如果你有结合使用异步代码和常规（阻塞/同步）代码的需求，这个库会特别有用。  \n### 其他形式的异步代码  \n这种使用 `async` 和 `await` 的风格在语言中相对较新。  \n但它使处理异步代码变得容易很多。  \n这种相同的语法（或几乎相同）最近也包含在现代版本的 JavaScript 中（在浏览器和 NodeJS 中）。  \n但在此之前，处理异步代码非常复杂和困难。  \n在以前版本的 Python，你可以使用多线程或者 Gevent。但代码的理解、调试和思考都要复杂许多。  \n在以前版本的 NodeJS / 浏览器 JavaScript 中，你会使用""回调""，因此也可能导致“回调地狱”。', '/// warning  \n你可以跳过这里。  \n这些都是 FastAPI 如何在内部工作的技术细节。  \n如果你有相当多的技术知识（协程、线程、阻塞等），并且对 FastAPI 如何处理 `async def` 与常规 `def` 感到好奇，请继续。  \n///  \n### 路径操作函数  \n当你使用 `def` 而不是 `async def` 来声明一个*路径操作函数*时，它运行在外部的线程池中并等待其结果，而不是直接调用（因为它会阻塞服务器）。  \n如果你使用过另一个不以上述方式工作的异步框架，并且你习惯于用普通的 `def` 定义普通的仅计算路径操作函数，以获得微小的性能增益（大约100纳秒），请注意，在 FastAPI 中，效果将完全相反。在这些情况下，最好使用 `async def`，除非路径操作函数内使用执行阻塞 <abbr title=""输入/输出：磁盘读写，网络通讯."">I/O</abbr> 的代码。  \n在这两种情况下，与你之前的框架相比，FastAPI 可能[仍然很快](index.md#_11){.internal-link target=_blank}。  \n### 依赖  \n这同样适用于[依赖](tutorial/dependencies/index.md){.internal-link target=_blank}。如果一个依赖是标准的 `def` 函数而不是 `async def`，它将被运行在外部线程池中。  \n### 子依赖  \n你可以拥有多个相互依赖的依赖以及[子依赖](tutorial/dependencies/sub-dependencies.md){.internal-link target=_blank} （作为函数的参数），它们中的一些可能是通过 `async def` 声明，也可能是通过 `def` 声明。它们仍然可以正常工作，这些通过 `def` 声明的函数将会在外部线程中调用（来自线程池），而不是""被等待""。  \n### 其他函数  \n你可直接调用通过 `def` 或 `async def` 创建的任何其他函数，FastAPI 不会影响你调用它们的方式。  \n这与 FastAPI 为你调用*路径操作函数*和依赖项的逻辑相反。  \n如果你的函数是通过 `def` 声明的，它将被直接调用（在代码中编写的地方），而不会在线程池中，如果这个函数通过 `async def` 声明，当在代码中调用时，你就应该使用 `await` 等待函数的结果。  \n再次提醒，这些是非常技术性的细节，如果你来搜索它可能对你有用。  \n否则，你最好应该遵守的指导原则赶时间吗？.', '# 并发 async / await  \n有关路径操作函数的 `async def` 语法以及异步代码、并发和并行的一些背景知识。']","根据上下文：  

1. **计算密集型任务建议使用普通 `def`**，因为 `async def` 更适合 I/O 密集型任务（如网络请求），而纯计算任务无需异步等待。  
2. **与 Node.js 不同**：Python 的 `async/await` 机制类似 Node.js，但计算密集型任务在两种语言中均建议避免阻塞事件循环（Python 用线程池处理 `def`，Node.js 常用工作线程）。  
3. 若任务不涉及 I/O 等待，直接使用 `def` 即可（FastAPI 会将其放入线程池执行）。",对于计算密集型（CPU-bound）任务，你应该使用普通的 `def` 定义路由，或者使用 `run_in_process`。因为 `async def` 运行在主事件循环上，计算密集型任务会长时间占用 CPU，导致整个服务无法响应其他请求（阻塞 Loop）。这与 Node.js 类似，Node.js 也是单线程事件循环，如果进行繁重计算也会阻塞整个进程，通常需要 Worker Threads 来解决。但在 FastAPI 中，简单地使用 `def` 就能利用线程池，这通常足以应对非极端的计算需求。,0.3333333333,0.5,0.8738592445597603
我要记录请求处理时间，FastAPI 的中间件和依赖注入都能做拦截，选哪个更好？,"['要创建中间件你可以在函数的顶部使用装饰器 `@app.middleware(""http"")`.  \n中间件参数接收如下参数:  \n* `request`.\n* 一个函数 `call_next` 它将接收 `request` 作为参数.\n* 这个函数将 `request` 传递给相应的 *路径操作*.\n* 然后它将返回由相应的*路径操作*生成的 `response`.\n* 然后你可以在返回 `response` 前进一步修改它.  \n```py\nimport time\n\nfrom fastapi import FastAPI, Request\n\napp = FastAPI()\n\n\n@app.middleware(""http"")\nasync def add_process_time_header(request: Request, call_next):\nstart_time = time.perf_counter()\nresponse = await call_next(request)\nprocess_time = time.perf_counter() - start_time\nresponse.headers[""X-Process-Time""] = str(process_time)\nreturn response\n\n```  \n/// tip  \n请记住可以 用\'X-\' 前缀添加专有自定义请求头.  \n但是如果你想让浏览器中的客户端看到你的自定义请求头, 你需要把它们加到 CORS 配置 ([CORS (Cross-Origin Resource Sharing)](cors.md){.internal-link target=_blank}) 的 `expose_headers` 参数中,在 Starlette\'s CORS docs文档中.  \n///  \n/// note | 技术细节  \n你也可以使用 `from starlette.requests import Request`.  \nFastAPI 为了开发者方便提供了该对象. 但其实它直接来自于 Starlette.  \n///  \n### 在 `response` 的前和后  \n在任何*路径操作*收到`request`前,可以添加要和请求一起运行的代码.  \n也可以在*响应*生成但是返回之前添加代码.  \n例如你可以添加自定义请求头 `X-Process-Time` 包含以秒为单位的接收请求和生成响应的时间:  \n> *[Ref: Code file `tutorial001_py39.py` is already included above]*', '# 中间件  \n你可以向 FastAPI 应用添加中间件.  \n""中间件""是一个函数,它在每个请求被特定的*路径操作*处理之前,以及在每个响应返回之前工作.  \n* 它接收你的应用程序的每一个请求.\n* 然后它可以对这个请求做一些事情或者执行任何需要的代码.\n* 然后它将请求传递给应用程序的其他部分 (通过某种*路径操作*).\n* 然后它获取应用程序生产的响应 (通过某种*路径操作*).\n* 它可以对该响应做些什么或者执行任何需要的代码.\n* 然后它返回这个 响应.  \n/// note | 技术细节  \n如果你使用了 `yield` 关键字依赖, 依赖中的退出代码将在执行中间件*后*执行.  \n如果有任何后台任务(稍后记录), 它们将在执行中间件*后*运行.  \n///', '# 依赖项  \nFastAPI 提供了简单易用，但功能强大的<abbr title=""也称为组件、资源、提供者、服务、可注入项"">依赖注入</abbr>系统。  \n这个依赖系统设计的简单易用，可以让开发人员轻松地把组件集成至 FastAPI。', 'FastAPI 为常见用例提供了一些中间件，下面介绍怎么使用这些中间件。  \n/// note | 技术细节  \n以下几个示例中也可以使用 `from starlette.middleware.something import SomethingMiddleware`。  \nFastAPI 在 `fastapi.middleware` 中提供的中间件只是为了方便开发者使用，但绝大多数可用的中间件都直接继承自 Starlette。  \n///']","根据上下文，对于记录请求处理时间，使用中间件（如示例中的 `@app.middleware(""http"")`）更合适，因为它直接在请求前后拦截并修改响应（如添加 `X-Process-Time` 头）。依赖注入更适合依赖管理（如数据库连接），而非全局拦截任务。上下文未提及依赖注入用于此场景的优势，因此推荐中间件。",如果目的是记录整个请求的处理时间（包括序列化、验证和网络传输），应该选择中间件（Middleware）（如 `BaseHTTPMiddleware`）。因为中间件作用于请求-响应的整个生命周期，能够捕获从请求到达服务器到响应发送回客户端的完整耗时。而依赖注入（Dependencies）通常在路由匹配和部分验证之后才执行，且无法轻易捕获响应发送后的时间点。,0.99999999995,0.75,0.8787867972067968
我有一个字段既可以是 int 也可以是 float，甚至有时候是 string，怎么定义 Schema 能让它通过校验？,"['Pydantic 的 `Field` 可以为模型属性声明更多校验和元数据。  \n传递 JSON Schema 元数据还可以使用更多关键字参数。', '除了普通的单一值类型（如 `str`、`int`、`float` 等）外，你还可以使用从 `str` 继承的更复杂的单一值类型。  \n要了解所有的可用选项，请查看关于 来自 Pydantic 的外部类型 的文档。你将在下一章节中看到一些示例。  \n例如，在 `Image` 模型中我们有一个 `url` 字段，我们可以把它声明为 Pydantic 的 `HttpUrl`，而不是 `str`：  \n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\nurl: HttpUrl\nname: str\n\n\nclass Item(BaseModel):\nname: str\ndescription: str | None = None\nprice: float\ntax: float | None = None\ntags: set[str] = set()\nimage: Image | None = None\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\nresults = {""item_id"": item_id, ""item"": item}\nreturn results\n\n```  \n该字符串将被检查是否为有效的 URL，并在 JSON Schema / OpenAPI 文档中进行记录。', '你也可以将请求体声明为使用某类型的键和其他类型值的 `dict`。  \n无需事先知道有效的字段/属性（在使用 Pydantic 模型的场景）名称是什么。  \n如果你想接收一些尚且未知的键，这将很有用。  \n其他有用的场景是当你想要接收其他类型的键时，例如 `int`。  \n这也是我们在接下来将看到的。  \n在下面的例子中，你将接受任意键为 `int` 类型并且值为 `float` 类型的 `dict`：  \n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.post(""/index-weights/"")\nasync def create_index_weights(weights: dict[int, float]):\nreturn weights\n\n```  \n/// tip  \n请记住 JSON 仅支持将 `str` 作为键。  \n但是 Pydantic 具有自动转换数据的功能。  \n这意味着，即使你的 API 客户端只能将字符串作为键发送，只要这些字符串内容仅包含整数，Pydantic 就会对其进行转换并校验。  \n然后你接收的名为 `weights` 的 `dict` 实际上将具有 `int` 类型的键和 `float` 类型的值。  \n///', '# 额外数据类型  \n到目前为止，您一直在使用常见的数据类型，如:  \n* `int`\n* `float`\n* `str`\n* `bool`  \n但是您也可以使用更复杂的数据类型。  \n您仍然会拥有现在已经看到的相同的特性:  \n* 很棒的编辑器支持。\n* 传入请求的数据转换。\n* 响应数据转换。\n* 数据验证。\n* 自动补全和文档。']","使用 `Union` 类型定义字段：`字段名: Union[int, float, str]`。Pydantic 会自动校验并转换数据为三者之一。","你可以使用 Python `typing` 模块中的 `Union` 类型。在 Pydantic 模型中，将字段定义为 `Union[int, float, str]`。Pydantic 会按照定义的顺序尝试进行类型校验和转换。如果一定要接收任意类型，可以使用 `Any`，但这会失去校验的意义。对于复杂的条件校验，还可以结合 Pydantic 的 `validator` 装饰器进行自定义逻辑判断。",0.0,0.75,0.6601608797720632
我想在服务器启动前预加载一个很大的机器学习模型到内存里，服务关闭时再释放掉，代码应该写在哪里？,"['让我们从一个示例用例开始，看看如何解决它。  \n假设你有几个机器学习的模型，你想要用它们来处理请求。  \n相同的模型在请求之间是共享的，因此并非每个请求或每个用户各自拥有一个模型。  \n假设加载模型可能需要相当长的时间，因为它必须从磁盘读取大量数据。因此你不希望每个请求都加载它。  \n你可以在模块/文件的顶部加载它，但这也意味着即使你只是在运行一个简单的自动化测试，它也会加载模型，这样测试将变慢，因为它必须在能够独立运行代码的其他部分之前等待模型加载完成。  \n这就是我们要解决的问题——在处理请求前加载模型，但只是在应用开始接收请求前，而不是代码执行时。', '# 生命周期事件  \n你可以定义在应用启动前执行的逻辑（代码）。这意味着在应用开始接收请求之前，这些代码只会被执行一次。  \n同样地，你可以定义在应用关闭时应执行的逻辑。在这种情况下，这段代码将在处理可能的多次请求后执行一次。  \n因为这段代码在应用开始接收请求之前执行，也会在处理可能的若干请求之后执行，它覆盖了整个应用程序的生命周期（""生命周期""这个词很重要😉）。  \n这对于设置你需要在整个应用中使用的资源非常有用，这些资源在请求之间共享，你可能需要在之后进行释放。例如，数据库连接池，或加载一个共享的机器学习模型。', '在很多情况下，您希望在启动应用程序之前执行一些步骤。  \n例如，您可能想要运行数据库迁移。  \n但在大多数情况下，您只想执行这些步骤一次。  \n因此，在启动应用程序之前，您将需要一个单个进程来执行这些前面的步骤。  \n而且您必须确保它是运行前面步骤的单个进程, *即使*之后您为应用程序本身启动多个进程（多个worker）。 如果这些步骤由多个进程运行，它们会通过在并行运行来重复工作，并且如果这些步骤像数据库迁移一样需要小心处理，它们可能会导致每个进程和其他进程发生冲突。  \n当然，也有一些情况，多次运行前面的步骤也没有问题，这样的话就好办多了。  \n/// tip  \n另外，请记住，根据您的设置，在某些情况下，您在开始应用程序之前可能甚至不需要任何先前的步骤。  \n在这种情况下，您就不必担心这些。 🤷  \n///  \n### 前面步骤策略的示例  \n这将在很大程度上取决于您部署系统的方式，并且可能与您启动程序、处理重启等的方式有关。  \n以下是一些可能的想法：  \n* Kubernetes 中的“Init Container”在应用程序容器之前运行\n* 一个 bash 脚本，运行前面的步骤，然后启动您的应用程序\n* 您仍然需要一种方法来启动/重新启动 bash 脚本、检测错误等。  \n/// tip  \n我将在以后的章节中为您提供使用容器执行此操作的更具体示例：[容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank}。  \n///', '你可以使用`FastAPI()`应用的`lifespan`参数和一个上下文管理器（稍后我将为你展示）来定义启动和关闭的逻辑。  \n让我们从一个例子开始，然后详细介绍。  \n我们使用`yield`创建了一个异步函数`lifespan()`像这样：  \n```Python hl_lines=""16  19""\n{!../../docs_src/events/tutorial003.py!}\n```  \n在这里，我们在 `yield` 之前将（虚拟的）模型函数放入机器学习模型的字典中，以此模拟加载模型的耗时启动操作。这段代码将在应用程序开始处理请求之前执行，即启动期间。  \n然后，在 `yield` 之后，我们卸载模型。这段代码将会在应用程序完成处理请求后执行，即在关闭之前。这可以释放诸如内存或 GPU 之类的资源。  \n/// tip | 提示  \n关闭事件只会在你停止应用时触发。  \n可能你需要启动一个新版本，或者你只是你厌倦了运行它。 🤷  \n///']","根据上下文，代码应写在 FastAPI 应用的生命周期事件中：  
1. 在 `lifespan` 异步函数的 `yield` 语句前加载模型（应用启动时执行）。  
2. 在 `yield` 语句后释放模型（应用关闭时执行）。  
3. 通过将 `lifespan` 参数传入 `FastAPI()` 实现资源管理。  

示例代码结构：  
```python
async def lifespan(app: FastAPI):
    # 启动时加载模型
    app.state.model = load_model()  
    yield  
    # 关闭时释放模型
    unload_model(app.state.model)
```",代码应该写在 Lifespan（生命周期）事件处理器中。FastAPI 推荐使用 `contextlib.asynccontextmanager` 装饰器创建一个异步上下文管理器，并将其传递给 `FastAPI(lifespan=...)` 参数。在该函数 `yield` 关键字之前的代码会在应用启动（Startup）时执行（适合加载模型），`yield` 之后的代码会在应用关闭（Shutdown）时执行（适合释放内存）。不建议再使用已废弃的 `@app.on_event`。,0.9166666666361111,0.75,0.6237499168837836
如果我想在这个接口上同时用 OAuth2 验证，又要校验一个 API Key header，怎么把这两个安全验证串起来？,"['# OAuth2 实现简单的 Password 和 Bearer 验证  \n本章添加上一章示例中欠缺的部分，实现完整的安全流。', ""OAuth2是一个规范，它定义了几种处理身份认证和授权的方法。  \n它是一个相当广泛的规范，涵盖了一些复杂的使用场景。  \n它包括了使用「第三方」进行身份认证的方法。  \n这就是所有带有「使用 Facebook，Google，X (Twitter)，GitHub 登录」的系统背后所使用的机制。  \n### OAuth 1  \n有一个 OAuth 1，它与 OAuth2 完全不同，并且更为复杂，因为它直接包含了有关如何加密通信的规范。  \n如今它已经不是很流行，没有被广泛使用了。  \nOAuth2 没有指定如何加密通信，它期望你为应用程序使用 HTTPS 进行通信。  \n/// tip  \n在有关部署的章节中，你将了解如何使用 Traefik 和 Let's Encrypt 免费设置 HTTPS。  \n///"", 'OpenAPI（以前称为 Swagger）是用于构建 API 的开放规范（现已成为 Linux Foundation 的一部分）。  \nFastAPI 基于 OpenAPI。  \n这就是使多个自动交互式文档界面，代码生成等成为可能的原因。  \nOpenAPI 有一种定义多个安全「方案」的方法。  \n通过使用它们，你可以利用所有这些基于标准的工具，包括这些交互式文档系统。  \nOpenAPI 定义了以下安全方案：  \n* `apiKey`：一个特定于应用程序的密钥，可以来自：\n* 查询参数。\n* 请求头。\n* cookie。\n* `http`：标准的 HTTP 身份认证系统，包括：\n* `bearer`: 一个值为 `Bearer` 加令牌字符串的 `Authorization` 请求头。这是从 OAuth2 继承的。\n* HTTP Basic 认证方式。\n* HTTP Digest，等等。\n* `oauth2`：所有的 OAuth2 处理安全性的方式（称为「流程」）。\n*以下几种流程适合构建 OAuth 2.0 身份认证的提供者（例如 Google，Facebook，X (Twitter)，GitHub 等）：\n* `implicit`\n* `clientCredentials`\n* `authorizationCode`\n* 但是有一个特定的「流程」可以完美地用于直接在同一应用程序中处理身份认证：\n* `password`：接下来的几章将介绍它的示例。\n* `openIdConnect`：提供了一种定义如何自动发现 OAuth2 身份认证数据的方法。\n* 此自动发现机制是 OpenID Connect 规范中定义的内容。  \n/// tip  \n集成其他身份认证/授权提供者（例如Google，Facebook，X (Twitter)，GitHub等）也是可能的，而且较为容易。  \n最复杂的问题是创建一个像这样的身份认证/授权提供程序，但是 FastAPI 为你提供了轻松完成任务的工具，同时为你解决了重活。  \n///', '本例使用 OAuth2 密码流。  \n这种方式适用于登录我们自己的应用，最好使用我们自己的前端。  \n因为我们能控制自己的前端应用，可以信任它接收 `username` 与 `password`。  \n但如果构建的是连接其它应用的 OAuth2 应用，比如具有与脸书、谷歌、GitHub 相同功能的第三方身份验证应用。那您就应该使用其它安全流。  \n最常用的是隐式流。  \n最安全的是代码流，但实现起来更复杂，而且需要更多步骤。因为它更复杂，很多第三方身份验证应用最终建议使用隐式流。  \n/// note | 笔记  \n每个身份验证应用都会采用不同方式会命名流，以便融合入自己的品牌。  \n但归根结底，它们使用的都是 OAuth2 标准。  \n///  \nFastAPI 的 `fastapi.security.oauth2` 里包含了所有 OAuth2 身份验证流工具。']",根据检索到的上下文，没有提供关于如何将 OAuth2 验证与 API Key header 同时使用的具体实现方法。上下文仅讨论了 OAuth2 的实现和 OpenAPI 支持的安全方案（如 apiKey 和 bearer），但未涉及两者的串联机制。因此，我无法从上下文中得到答案。,"你可以在路由操作函数（Path Operation）中同时声明多个依赖项。可以将它们作为参数分别注入，例如 `def route(token: str = Depends(oauth2_scheme), key: str = Depends(api_key_header))`。如果不需要在函数内部使用这些返回值，也可以将它们放入路由装饰器的 `dependencies` 参数列表中，例如 `@app.get('/items', dependencies=[Depends(oauth2_scheme), Depends(verify_api_key)])`，这样 FastAPI 会按顺序执行所有安全验证。",0.0,0.6,0.0
Uvicorn 的 workers 数量设置成多少合适？是不是越多越好？跟 CPU 核数有什么关系？,"['# 服务器工作进程（Workers） - 使用 Uvicorn 的多工作进程模式  \n让我们回顾一下之前的部署概念：  \n* 安全性 - HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 启动前的先前步骤  \n到目前为止，在文档中的所有教程中，您可能一直是在运行一个服务器程序，例如使用 `fastapi` 命令来启动 Uvicorn，而它默认运行的是单进程模式。  \n部署应用程序时，您可能希望进行一些进程复制，以利用多核 CPU 并能够处理更多请求。  \n正如您在上一章有关[部署概念](concepts.md){.internal-link target=_blank}中看到的，您可以使用多种策略。  \n在本章节中，我将向您展示如何使用 `fastapi` 命令或直接使用 `uvicorn` 命令以多工作进程模式运行 Uvicorn。  \n/// info  \n如果您正在使用容器，例如 Docker 或 Kubernetes，我将在下一章中告诉您更多相关信息：[容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank}。  \n比较特别的是，在 Kubernetes 环境中运行时，您通常不需要使用多个工作进程，而是每个容器运行一个 Uvicorn 进程。不过，我会在本章节的后续部分详细介绍这一点。  \n///', '您可以在使用 `fastapi` 或 `uvicorn` 命令时，通过 `--workers` CLI 选项启用多个工作进程（workers），以充分利用多核 CPU，以并行运行多个进程。  \n如果您要设置自己的部署系统，同时自己处理其他部署概念，则可以使用这些工具和想法。  \n请查看下一章，了解带有容器（例如 Docker 和 Kubernetes）的 FastAPI。 您将看到这些工具也有简单的方法来解决其他部署概念。 ✨', '您可以使用 `--workers` 命令行选项来启动多个工作进程：  \n//// tab | `fastapi`  \n如果您使用 `fastapi` 命令：  \n```console\n$ fastapi run --workers 4 main.py\n\nFastAPI   Starting production server 🚀\n\nSearching for package file structure from directories with\ninit.py files\nImporting from /home/user/code/awesomeapp\n\nmodule   🐍 main.py\n\ncode   Importing the FastAPI app object from the module with the\nfollowing code:\n\nfrom main import app\n\napp   Using import string: main:app\n\nserver   Server started at http://0.0.0.0:8000\nserver   Documentation at http://0.0.0.0:8000/docs\n\nLogs:\n\nINFO   Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to\nquit)\nINFO   Started parent process [27365]\nINFO   Started server process [27368]\nINFO   Started server process [27369]\nINFO   Started server process [27370]\nINFO   Started server process [27367]\nINFO   Waiting for application startup.\nINFO   Waiting for application startup.\nINFO   Waiting for application startup.\nINFO   Waiting for application startup.\nINFO   Application startup complete.\nINFO   Application startup complete.\nINFO   Application startup complete.\nINFO   Application startup complete.\n```  \n////  \n//// tab | `uvicorn`  \n如果您更想要直接使用 `uvicorn` 命令：  \n```console\n$ uvicorn main:app --host 0.0.0.0 --port 8080 --workers 4\nINFO:     Uvicorn running on http://0.0.0.0:8080 (Press CTRL+C to quit)\nINFO:     Started parent process [27365]\nINFO:     Started server process [27368]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [27369]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [27370]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [27367]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```  \n////  \n这里唯一的新选项是 `--workers` 告诉 Uvicorn 启动 4 个工作进程。  \n您还可以看到它显示了每个进程的 PID，父进程（这是进程管理器）的 PID 为`27365`，每个工作进程的 PID 为：`27368`、`27369`， `27370`和`27367`。', '对于 FastAPI 应用程序，使用像 Uvicorn 这样的服务器程序，在一个进程中运行一次就可以同时为多个客户端提供服务。  \n但在许多情况下，您会希望同时运行多个工作进程。  \n### 多进程 - Workers  \n如果您的客户端数量多于单个进程可以处理的数量（例如，如果虚拟机不是太大），并且服务器的 CPU 中有 多个核心，那么您可以让 多个进程 运行 同时处理同一个应用程序，并在它们之间分发所有请求。  \n当您运行同一 API 程序的多个进程时，它们通常称为 workers。  \n### 工作进程和端口  \n还记得文档 [About HTTPS](https.md){.internal-link target=_blank} 中只有一个进程可以侦听服务器中的端口和 IP 地址的一种组合吗？  \n现在仍然是对的。  \n因此，为了能够同时拥有多个进程，必须有一个单个进程侦听端口，然后以某种方式将通信传输到每个工作进程。  \n### 每个进程的内存  \n现在，当程序将内容加载到内存中时，例如，将机器学习模型加载到变量中，或者将大文件的内容加载到变量中，所有这些都会消耗服务器的一点内存 (RAM) 。  \n多个进程通常不共享任何内存。 这意味着每个正在运行的进程都有自己的东西、变量和内存。 如果您的代码消耗了大量内存，每个进程将消耗等量的内存。  \n### 服务器内存  \n例如，如果您的代码加载 1 GB 大小的机器学习模型，则当您使用 API 运行一个进程时，它将至少消耗 1 GB RAM。 如果您启动 4 个进程（4 个工作进程），每个进程将消耗 1 GB RAM。 因此，您的 API 总共将消耗 4 GB RAM。  \n如果您的远程服务器或虚拟机只有 3 GB RAM，尝试加载超过 4 GB RAM 将导致问题。 🚨  \n### 多进程 - 一个例子  \n在此示例中，有一个 Manager Process 启动并控制两个 Worker Processes。  \n该管理器进程可能是监听 IP 中的 端口 的进程。 它将所有通信传输到工作进程。  \n这些工作进程将是运行您的应用程序的进程，它们将执行主要计算以接收 请求 并返回 响应，并且它们将加载您放入 RAM 中的变量中的任何内容。  \n当然，除了您的应用程序之外，同一台机器可能还运行其他进程。  \n一个有趣的细节是，随着时间的推移，每个进程使用的 CPU 百分比可能会发生很大变化，但内存 (RAM) 通常会或多或少保持稳定。  \n如果您有一个每次执行相当数量的计算的 API，并且您有很多客户端，那么 CPU 利用率 可能也会保持稳定（而不是不断快速上升和下降）。  \n### 复制工具和策略示例  \n可以通过多种方法来实现这一目标，我将在接下来的章节中向您详细介绍具体策略，例如在谈论 Docker 和容器时。  \n要考虑的主要限制是必须有一个单个组件来处理公共IP中的端口。 然后它必须有一种方法将通信传输到复制的进程/worker。  \n以下是一些可能的组合和策略：  \n* Gunicorn 管理 Uvicorn workers\n* Gunicorn 将是监听 IP 和 端口 的 进程管理器，复制将通过 多个 Uvicorn 工作进程 进行\n* Uvicorn 管理 Uvicorn workers\n* 一个 Uvicorn 进程管理器 将监听 IP 和 端口，并且它将启动 多个 Uvicorn 工作进程\n* Kubernetes 和其他分布式 容器系统\n* Kubernetes 层中的某些东西将侦听 IP 和 端口。 复制将通过拥有多个容器，每个容器运行一个 Uvicorn 进程\n* 云服务 为您处理此问题\n* 云服务可能为您处理复制。 它可能会让您定义 要运行的进程，或要使用的 容器映像，在任何情况下，它很可能是 单个 Uvicorn 进程，并且云服务将负责复制它。  \n/// tip  \n如果这些关于 容器、Docker 或 Kubernetes 的内容还没有多大意义，请不要担心。  \n我将在以后的章节中向您详细介绍容器镜像、Docker、Kubernetes 等：[容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank}。  \n///']","根据上下文：  
1. **workers数量应与CPU核数匹配**，建议设置为`2 * CPU核数 + 1`，但需结合实际情况。  
2. **并非越多越好**：每个worker独立占用内存（如加载1GB模型时，4个worker需4GB内存），超出服务器内存会导致崩溃。  
3. **在Kubernetes等容器环境中**，通常单容器运行单进程，无需设置多worker。  

（注：上下文未明确给出具体计算公式，但强调了CPU核数、内存限制及容器环境的特殊性。）",Uvicorn 的 workers 数量并非越多越好。官方建议的经验值通常是 CPU 核心数（num_cores）或 CPU 核心数 + 1。因为 Python 的全局解释器锁（GIL）限制了单个进程只能利用一个 CPU 核心，过多的 Worker 只会增加上下文切换的开销并消耗更多内存。在生产环境中，通常配合 Gunicorn 作为进程管理器，通过 `-w` 参数设置 worker 数量，并指定 `-k uvicorn.workers.UvicornWorker` 类。,0.499999999975,0.8,0.6974115229495987
