user_input,retrieved_contexts,response,reference,context_precision,faithfulness,answer_relevancy
什么是 FastAPI？它的核心特性有哪些？,"['# FastAPI\n\nFastAPI 框架，高性能，易于学习，高效编码，生产可用\n\n文档： https://fastapi.tiangolo.com\n\n源码： https://github.com/fastapi/fastapi\n\nFastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 并基于标准的 Python 类型提示。\n\n关键特性:\n\n* 快速：可与 NodeJS 和 Go 并肩的极高性能（归功于 Starlette 和 Pydantic）。[最快的 Python web 框架之一](#_11)。\n\n* 高效编码：提高功能开发速度约 200％ 至 300％。*\n* 更少 bug：减少约 40％ 的人为（开发者）导致错误。*\n* 智能：极佳的编辑器支持。处处皆可<abbr title=""也被称为自动完成、智能感知"">自动补全</abbr>，减少调试时间。\n* 简单：设计的易于使用和学习，阅读文档的时间更短。\n* 简短：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。\n* 健壮：生产可用级别的代码。还有自动生成的交互式文档。\n* 标准化：基于（并完全兼容）API 的相关开放标准：OpenAPI (以前被称为 Swagger) 和 JSON Schema。\n\n* 根据对某个构建线上应用的内部开发团队所进行的测试估算得出。\n\n## Sponsors\n\n<!-- sponsors -->\n\n{% if sponsors %}\n{% for sponsor in sponsors.gold -%}\n\n{% endfor -%}\n{%- for sponsor in sponsors.silver -%}\n\n{% endfor %}\n{% endif %}\n\n<!-- /sponsors -->\nOther sponsors\n\n## 评价\n\n「_[...] 最近我一直在使用 FastAPI。[...] 实际上我正在计划将其用于我所在的微软团队的所有机器学习服务。其中一些服务正被集成进核心 Windows 产品和一些 Office 产品。_」\n\nKabir Khan - 微软 (ref)\n\n「_我们选择了 FastAPI 来创建用于获取预测结果的 REST 服务。[用于 Ludwig]_」\n\nPiero Molino，Yaroslav Dudin 和 Sai Sumanth Miryala - Uber (ref)\n\n「_Netflix 非常高兴地宣布，正式开源我们的危机管理编排框架：Dispatch！[使用 FastAPI 构建]_」\n\nKevin Glisson，Marc Vilanova，Forest Monsen - Netflix (ref)\n\n「_FastAPI 让我兴奋的欣喜若狂。它太棒了！_」\n\nBrian Okken - Python Bytes 播客主持人 (ref)\n\n「_老实说，你的作品看起来非常可靠和优美。在很多方面，这就是我想让 Hug 成为的样子 - 看到有人实现了它真的很鼓舞人心。_」\n\nTimothy Crosley - Hug 作者 (ref)\n\n「_如果你正打算学习一个现代框架用来构建 REST API，来看下 FastAPI [...] 它快速、易用且易于学习 [...]_」\n\n「_我们已经将 API 服务切换到了 FastAPI [...] 我认为你会喜欢它的 [...]_」\n\nInes Montani - Matthew Honnibal - Explosion AI 创始人 - spaCy 作者 (ref) - (ref)\n\n## Typer，命令行中的 FastAPI\n\n如果你正在开发一个在终端中运行的<abbr title=""Command Line Interface"">命令行</abbr>应用而不是 web API，不妨试下 Typer。\n\nTyper 是 FastAPI 的小同胞。它想要成为命令行中的 FastAPI。 ⌨️ 🚀\n\n## 依赖\n\nPython 及更高版本\n\nFastAPI 站在以下巨人的肩膀之上：\n\n* Starlette 负责 web 部分。\n* Pydantic 负责数据部分。\n\n## 安装\n\n```console\n$ pip install fastapi\n\n&gt; 100%\n```\n\n你还会需要一个 ASGI 服务器，生产环境可以使用 Uvicorn 或者 Hypercorn。\n\n```console\n$ pip install ""uvicorn[standard]""\n\n&gt; 100%\n```\n\n## 示例\n\n### 创建\n\n* 创建一个 `main.py` 文件并写入以下内容:\n\n```Python\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(""/"")\ndef read_root():\n    return {""Hello"": ""World""}\n\n@app.get(""/items/{item_id}"")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {""item_id"": item_id, ""q"": q}\n```\n\n<details markdown=""1"">\n<summary>或者使用 <code>async def</code>...</summary>\n\n如果你的代码里会出现 `async` / `await`，请使用 `async def`：\n\n```Python hl_lines=""9  14""\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(""/"")\nasync def read_root():\n    return {""Hello"": ""World""}\n\n@app.get(""/items/{item_id}"")\nasync def read_item(item_id: int, q: Union[str, None] = None):\n    return {""item_id"": item_id, ""q"": q}\n```\n\nNote:\n\n如果你不知道是否会用到，可以查看文档的 _""In a hurry?""_ 章节中 关于 `async` 和 `await` 的部分。\n\n</details>\n\n### 运行\n\n通过以下命令运行服务器：\n\n```console\n$ uvicorn main:app --reload\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [28720]\nINFO:     Started server process [28722]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```\n\n<details markdown=""1"">\n<summary>关于 <code>uvicorn main:app --reload</code> 命令......</summary>\n\n `uvicorn main:app` 命令含义如下:\n\n* `main`：`main.py` 文件（一个 Python ""模块""）。\n* `app`：在 `main.py` 文件中通过 `app = FastAPI()` 创建的对象。\n* `--reload`：让服务器在更新代码后重新启动。仅在开发时使用该选项。\n\n</details>\n\n### 检查\n\n使用浏览器访问 http://127.0.0.1:8000/items/5?q=somequery。\n\n你将会看到如下 JSON 响应：\n\n```JSON\n{""item_id"": 5, ""q"": ""somequery""}\n```\n\n你已经创建了一个具有以下功能的 API：\n\n* 通过 _路径_ `/` 和 `/items/{item_id}` 接受 HTTP 请求。\n* 以上 _路径_ 都接受 `GET` 操作（也被称为 HTTP _方法_）。\n* `/items/{item_id}` _路径_ 有一个 _路径参数_ `item_id` 并且应该为 `int` 类型。\n* `/items/{item_id}` _路径_ 有一个可选的 `str` 类型的 _查询参数_ `q`。\n\n### 交互式 API 文档\n\n现在访问 http://127.0.0.1:8000/docs。\n\n你会看到自动生成的交互式 API 文档（由 Swagger UI生成）：\n\n![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)\n\n### 可选的 API 文档\n\n访问 http://127.0.0.1:8000/redoc。\n\n你会看到另一个自动生成的文档（由 ReDoc 生成）：\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)\n\n## 示例升级\n\n现在修改 `main.py` 文件来从 `PUT` 请求中接收请求体。\n\n我们借助 Pydantic 来使用标准的 Python 类型声明请求体。\n\n```Python hl_lines=""4  9-12  25-27""\nfrom typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_offer: Union[bool, None] = None\n\n@app.get(""/"")\ndef read_root():\n    return {""Hello"": ""World""}\n\n@app.get(""/items/{item_id}"")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {""item_id"": item_id, ""q"": q}\n\n@app.put(""/items/{item_id}"")\ndef update_item(item_id: int, item: Item):\n    return {""item_name"": item.name, ""item_id"": item_id}\n```\n\n服务器将会自动重载（因为在上面的步骤中你向 `uvicorn` 命令添加了 `--reload` 选项）。\n\n### 交互式 API 文档升级\n\n访问 http://127.0.0.1:8000/docs。\n\n* 交互式 API 文档将会自动更新，并加入新的请求体：\n\n![Swagger UI](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)\n\n* 点击「Try it out」按钮，之后你可以填写参数并直接调用 API：\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-04-swagger-03.png)\n\n* 然后点击「Execute」按钮，用户界面将会和 API 进行通信，发送参数，获取结果并在屏幕上展示：\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-05-swagger-04.png)\n\n### 可选文档升级\n\n访问 http://127.0.0.1:8000/redoc。\n\n* 可选文档同样会体现新加入的请求参数和请求体：\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)\n\n### 总结\n\n总的来说，你就像声明函数的参数类型一样只声明了一次请求参数、请求体等的类型。\n\n你使用了标准的现代 Python 类型来完成声明。\n\n你不需要去学习新的语法、了解特定库的方法或类，等等。\n\n只需要使用标准的 Python 及更高版本。\n\n举个例子，比如声明 `int` 类型：\n\n```Python\nitem_id: int\n```\n\n或者一个更复杂的 `Item` 模型：\n\n```Python\nitem: Item\n```\n\n......在进行一次声明之后，你将获得：\n\n* 编辑器支持，包括：\n    * 自动补全\n    * 类型检查\n* 数据校验：\n    * 在校验失败时自动生成清晰的错误信息\n    * 对多层嵌套的 JSON 对象依然执行校验\n* <abbr title=""也被称为：序列化或解析"">转换</abbr> 来自网络请求的输入数据为 Python 数据类型。包括以下数据：\n    * JSON\n    * 路径参数\n    * 查询参数\n    * Cookies\n    * 请求头\n    * 表单\n    * 文件\n* <abbr title=""也被称为：序列化或解析"">转换</abbr> 输出的数据：转换 Python 数据类型为供网络传输的 JSON 数据：\n    * 转换 Python 基础类型 （`str`、 `int`、 `float`、 `bool`、 `list` 等）\n    * `datetime` 对象\n    * `UUID` 对象\n    * 数据库模型\n    * ......以及更多其他类型\n* 自动生成的交互式 API 文档，包括两种可选的用户界面：\n    * Swagger UI\n    * ReDoc\n\n回到前面的代码示例，FastAPI 将会：\n\n* 校验 `GET` 和 `PUT` 请求的路径中是否含有 `item_id`。\n* 校验 `GET` 和 `PUT` 请求中的 `item_id` 是否为 `int` 类型。\n    * 如果不是，客户端将会收到清晰有用的错误信息。\n* 检查 `GET` 请求中是否有命名为 `q` 的可选查询参数（比如 `http://127.0.0.1:8000/items/foo?q=somequery`）。\n    * 因为 `q` 被声明为 `= None`，所以它是可选的。\n    * 如果没有 `None` 它将会是必需的 (如 `PUT` 例子中的请求体)。\n* 对于访问 `/items/{item_id}` 的 `PUT` 请求，将请求体读取为 JSON 并：\n    * 检查是否有必需属性 `name` 并且值为 `str` 类型 。\n    * 检查是否有必需属性 `price` 并且值为 `float` 类型。\n    * 检查是否有可选属性 `is_offer`， 如果有的话值应该为 `bool` 类型。\n    * 以上过程对于多层嵌套的 JSON 对象同样也会执行\n* 自动对 JSON 进行转换或转换成 JSON。\n* 通过 OpenAPI 文档来记录所有内容，可被用于：\n    * 交互式文档系统\n    * 许多编程语言的客户端代码自动生成系统\n* 直接提供 2 种交互式文档 web 界面。\n\n虽然我们才刚刚开始，但其实你已经了解了这一切是如何工作的。\n\n尝试更改下面这行代码：\n\n```Python\n    return {""item_name"": item.name, ""item_id"": item_id}\n```\n\n......从：\n\n```Python\n        ... ""item_name"": item.name ...\n```\n\n......改为：\n\n```Python\n        ... ""item_price"": item.price ...\n```\n\n......注意观察编辑器是如何自动补全属性并且还知道它们的类型：\n\n![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)\n\n教程 - 用户指南 中有包含更多特性的更完整示例。\n\n剧透警告： 教程 - 用户指南中的内容有：\n\n* 对来自不同地方的参数进行声明，如：请求头、cookies、form 表单以及上传的文件。\n* 如何设置校验约束如 `maximum_length` 或者 `regex`。\n* 一个强大并易于使用的 <abbr title=""也被称为 components, resources, providers, services, injectables"">依赖注入</abbr> 系统。\n* 安全性和身份验证，包括通过 JWT 令牌和 HTTP 基本身份认证来支持 OAuth2。\n* 更进阶（但同样简单）的技巧来声明 多层嵌套 JSON 模型 （借助 Pydantic）。\n* 许多额外功能（归功于 Starlette）比如：\n    * WebSockets\n    * GraphQL\n    * 基于 HTTPX 和 `pytest` 的极其简单的测试\n    * CORS\n    * Cookie Sessions\n    * ......以及更多\n\n## 性能\n\n独立机构 TechEmpower 所作的基准测试结果显示，基于 Uvicorn 运行的 FastAPI 程序是 最快的 Python web 框架之一，仅次于 Starlette 和 Uvicorn 本身（FastAPI 内部使用了它们）。(*)\n\n想了解更多，请查阅 基准测试 章节。\n\n## 可选依赖\n\n用于 Pydantic：\n\n* email-validator - 用于 email 校验。\n\n用于 Starlette：\n\n* httpx - 使用 `TestClient` 时安装。\n* jinja2 - 使用默认模板配置时安装。\n* python-multipart - 需要通过 `request.form()` 对表单进行<abbr title=""将来自 HTTP 请求中的字符串转换为 Python 数据类型"">「解析」</abbr>时安装。\n* itsdangerous - 需要 `SessionMiddleware` 支持时安装。\n* pyyaml - 使用 Starlette 提供的 `SchemaGenerator` 时安装（有 FastAPI 你可能并不需要它）。\n* graphene - 需要 `GraphQLApp` 支持时安装。\n\n用于 FastAPI / Starlette：\n\n* uvicorn - 用于加载和运行你的应用程序的服务器。\n* orjson - 使用 `ORJSONResponse` 时安装。\n* ujson - 使用 `UJSONResponse` 时安装。\n\n你可以通过 `pip install ""fastapi[all]""` 命令来安装以上所有依赖。\n\n## 许可协议\n\n该项目遵循 MIT 许可协议。', '# 特性\n\n## FastAPI 特性\n\nFastAPI 提供了以下内容：\n\n### 基于开放标准\n\n* 用于创建 API 的 OpenAPI 包含了<abbr title=""也被叫做: endpoints, routes"">路径</abbr><abbr title=""也叫做HTTP方法, 例如 POST, GET, PUT, DELETE"">操作</abbr>，请求参数，请求体，安全性等的声明。\n* 使用 JSON Schema (因为 OpenAPI 本身就是基于 JSON Schema 的)自动生成数据模型文档。\n* 经过了缜密的研究后围绕这些标准而设计。并非狗尾续貂。\n* 这也允许了在很多语言中自动生成客户端代码。\n\n### 自动生成文档\n\n交互式 API 文档以及具探索性 web 界面。因为该框架是基于 OpenAPI，所以有很多可选项，FastAPI 默认自带两个交互式 API 文档。\n\n* Swagger UI，可交互式操作，能在浏览器中直接调用和测试你的 API  。\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)\n\n* 另外的 API 文档：ReDoc\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)\n\n### 更主流的 Python\n\n全部都基于标准的 Python 3.6 类型声明（感谢 Pydantic ）。没有新的语法需要学习。只需要标准的 Python 。\n\n如果你需要2分钟来学习如何使用 Python 类型（即使你不使用 FastAPI ），看看这个简短的教程：[Python Types](python-types.md){.internal-link target=_blank}。\n\n编写带有类型标注的标准 Python：\n\n```Python\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n# Declare a variable as a str\n# and get editor support inside the function\ndef main(user_id: str):\n    return user_id\n\n# A Pydantic model\nclass User(BaseModel):\n    id: int\n    name: str\n    joined: date\n```\n\n可以像这样来使用：\n\n```Python\nmy_user: User = User(id=3, name=""John Doe"", joined=""2018-07-19"")\n\nsecond_user_data = {\n    ""id"": 4,\n    ""name"": ""Mary"",\n    ""joined"": ""2018-11-30"",\n}\n\nmy_second_user: User = User(second_user_data)\n```\n\n/// info\n\n`second_user_data` 意思是:\n\n直接将`second_user_data`字典的键和值直接作为key-value参数传递，等同于：`User(id=4, name=""Mary"", joined=""2018-11-30"")`\n\n///\n\n### 编辑器支持\n\n整个框架都被设计得易于使用且直观，所有的决定都在开发之前就在多个编辑器上进行了测试，来确保最佳的开发体验。\n\n在最近的 Python 开发者调查中，我们能看到 被使用最多的功能是""自动补全""。\n\n整个 FastAPI 框架就是基于这一点的。任何地方都可以进行自动补全。\n\n你几乎不需要经常回来看文档。\n\n在这里，你的编辑器可能会这样帮助你：\n\n* Visual Studio Code 中:\n\n![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)\n\n* PyCharm 中:\n\n![editor support](https://fastapi.tiangolo.com/img/pycharm-completion.png)\n\n你将能进行代码补全，这是在之前你可能曾认为不可能的事。例如，在来自请求 JSON 体（可能是嵌套的）中的键 `price`。\n\n不会再输错键名，来回翻看文档，或者来回滚动寻找你最后使用的 `username` 或者 `user_name` 。\n\n### 简洁\n\n任何类型都有合理的默认值，任何和地方都有可选配置。所有的参数被微调，来满足你的需求，定义成你需要的 API。\n\n但是默认情况下，一切都能“顺利工作”。\n\n### 验证\n\n* 校验大部分（甚至所有？）的 Python 数据类型，包括：\n    * JSON 对象 (`dict`).\n    * JSON 数组 (`list`) 定义成员类型。\n    * 字符串 (`str`) 字段, 定义最小或最大长度。\n    * 数字 (`int`, `float`) 有最大值和最小值， 等等。\n\n* 校验外来类型， 比如:\n    * URL.\n    * Email.\n    * UUID.\n    * ...及其他.\n\n所有的校验都由完善且强大的 Pydantic 处理。\n\n### 安全性及身份验证\n\n集成了安全性和身份认证。杜绝数据库或者数据模型的渗透风险。\n\nOpenAPI 中定义的安全模式，包括：\n\n* HTTP 基本认证。\n* OAuth2 (也使用 JWT tokens)。在 [OAuth2 with JWT](tutorial/security/oauth2-jwt.md){.internal-link target=_blank}查看教程。\n* API 密钥，在:\n    * 请求头。\n    * 查询参数。\n    * Cookies, 等等。\n\n加上来自 Starlette（包括 session cookie）的所有安全特性。\n\n所有的这些都是可复用的工具和组件，可以轻松与你的系统，数据仓库，关系型以及 NoSQL 数据库等等集成。\n\n### 依赖注入\n\nFastAPI 有一个使用非常简单，但是非常强大的<abbr title=\'也叫做 ""components"", ""resources"", ""services"", ""providers""\'>依赖注入</abbr>系统。\n\n* 甚至依赖也可以有依赖，创建一个层级或者“图”依赖。\n* 所有自动化处理都由框架完成。\n* 所有的依赖关系都可以从请求中获取数据，并且增加了路径操作约束和自动文档生成。\n* 即使在依赖项中被定义的*路径操作* 也会自动验证。\n* 支持复杂的用户身份认证系统，数据库连接等等。\n* 不依赖数据库，前端等。 但是和它们集成很简单。\n\n### 无限制""插件""\n\n或者说，导入并使用你需要的代码，而不需要它们。\n\n任何集成都被设计得被易于使用（用依赖关系），你可以用和*路径操作*相同的结构和语法，在两行代码中为你的应用创建一个“插件”。\n\n### 测试\n\n* 100% <abbr title=""自动测试的代码量"">测试覆盖</abbr>。\n* 代码库100% <abbr title=""Python类型注解，有了这个你的编辑器和外部工具可以给你更好的支持"">类型注释</abbr>。\n* 用于生产应用。\n\n## Starlette 特性\n\nFastAPI 和 Starlette 完全兼容(并基于)。所以，你有的其他的 Starlette 代码也能正常工作。`FastAPI` 实际上是 `Starlette`的一个子类。所以，如果你已经知道或者使用 Starlette，大部分的功能会以相同的方式工作。\n\n通过 FastAPI 你可以获得所有 Starlette 的特性 ( FastAPI 就像加强版的 Starlette )：\n\n* 令人惊叹的性能。它是 Python 可用的最快的框架之一，和\xa0NodeJS 及\xa0Go 相当。\n* 支持 WebSocket 。\n* 支持 GraphQL 。\n* 后台任务处理。\n* Startup 和 shutdown 事件。\n* 测试客户端基于 HTTPX。\n* CORS, GZip, 静态文件, 流响应。\n* 支持 Session 和 Cookie 。\n* 100% 测试覆盖率。\n* 代码库 100% 类型注释。\n\n## Pydantic 特性\n\nFastAPI 和 Pydantic 完全兼容(并基于)。所以，你有的其他的 Pydantic 代码也能正常工作。\n\n兼容包括基于 Pydantic 的外部库， 例如用与数据库的 <abbr title=""对象关系映射"">ORM</abbr>s, <abbr title=""对象文档映射"">ODM</abbr>s。\n\n这也意味着在很多情况下，你可以将从请求中获得的相同对象直接传到数据库，因为所有的验证都是自动的。\n\n反之亦然，在很多情况下，你也可以将从数据库中获取的对象直接传到客户端。\n\n通过 FastAPI 你可以获得所有 Pydantic  (FastAPI 基于 Pydantic 做了所有的数据处理)：\n\n* 更简单：\n    * 没有新的模式定义 micro-language 需要学习。\n    * 如果你知道 Python types，你就知道如何使用 Pydantic。\n* 和你 <abbr title=""集成开发环境，和代码编辑器类似"">IDE</abbr>/<abbr title=""一个检查代码错误的程序"">linter</abbr>/brain 适配:\n    * 因为 pydantic 数据结构仅仅是你定义的类的实例；自动补全，linting，mypy 以及你的直觉应该可以和你验证的数据一起正常工作。\n* 验证复杂结构:\n    * 使用分层的 Pydantic 模型, Python `typing`的 `List` 和 `Dict` 等等。\n    * 验证器使我们能够简单清楚的将复杂的数据模式定义、检查并记录为 JSON Schema。\n    * 你可以拥有深度嵌套的 JSON 对象并对它们进行验证和注释。\n* 可扩展:\n    * Pydantic 允许定义自定义数据类型或者你可以用验证器装饰器对被装饰的模型上的方法扩展验证。\n* 100% 测试覆盖率。', '# 历史、设计、未来\n\n不久前，曾有\xa0FastAPI 用户问过：\n\n&gt; 这个项目有怎样的历史？好像它只用了几周就从默默无闻变得众所周知……\n\n在此，我们简单回顾一下 FastAPI 的历史。\n\n## 备选方案\n\n有那么几年，我曾领导数个开发团队为诸多复杂需求创建各种 API，这些需求包括机器学习、分布系统、异步任务、NoSQL 数据库等领域。\n\n作为工作的一部分，我需要调研很多备选方案、还要测试并且使用这些备选方案。\n\nFastAPI 其实只是延续了这些前辈的历史。\n\n正如[备选方案](alternatives.md){.internal-link target=_blank}一章所述：\n\n<blockquote markdown=""1"">\n没有大家之前所做的工作，FastAPI 就不会存在。\n\n以前创建的这些工具为它的出现提供了灵感。\n\n在那几年中，我一直回避创建新的框架。首先，我尝试使用各种框架、插件、工具解决 FastAPI 现在的功能。\n\n但到了一定程度之后，我别无选择，只能从之前的工具中汲取最优思路，并以尽量好的方式把这些思路整合在一起，使用之前甚至是不支持的语言特性（Python 3.6+ 的类型提示），从而创建一个能满足我所有需求的框架。\n\n</blockquote>\n\n## 调研\n\n通过使用之前所有的备选方案，我有机会从它们之中学到了很多东西，获取了很多想法，并以我和我的开发团队能想到的最好方式把这些思路整合成一体。\n\n例如，大家都清楚，在理想状态下，它应该基于标准的 Python 类型提示。\n\n而且，最好的方式是使用现有的标准。\n\n因此，甚至在开发 FastAPI 前，我就花了几个月的时间研究 OpenAPI、JSON Schema、OAuth2 等规范。深入理解它们之间的关系、重叠及区别之处。\n\n## 设计\n\n然后，我又花了一些时间从用户角度（使用 FastAPI 的开发者）设计了开发者 API。\n\n同时，我还在最流行的 Python 代码编辑器中测试了很多思路，包括 PyCharm、VS Code、基于 Jedi 的编辑器。\n\n根据最新 Python 开发者调研报告显示，这几种编辑器覆盖了约 80% 的用户。\n\n也就是说，FastAPI 针对差不多 80% 的 Python 开发者使用的编辑器进行了测试，而且其它大多数编辑器的工作方式也与之类似，因此，FastAPI 的优势几乎能在所有编辑器上体现。\n\n通过这种方式，我就能找到尽可能减少代码重复的最佳方式，进而实现处处都有自动补全、类型提示与错误检查等支持。\n\n所有这些都是为了给开发者提供最佳的开发体验。\n\n## 需求项\n\n经过测试多种备选方案，我最终决定使用  Pydantic，并充分利用它的优势。\n\n我甚至为它做了不少贡献，让它完美兼容了 JSON Schema，支持多种方式定义约束声明，并基于多个编辑器，改进了它对编辑器支持（类型检查、自动补全）。\n\n在开发期间，我还为 Starlette 做了不少贡献，这是另一个关键需求项。\n\n## 开发\n\n当我启动 FastAPI 开发的时候，绝大多数部件都已经就位，设计已经定义，需求项和工具也已经准备就绪，相关标准与规范的知识储备也非常清晰而新鲜。\n\n## 未来\n\n至此，FastAPI 及其理念已经为很多人所用。\n\n对于很多用例，它比以前很多备选方案都更适用。\n\n很多开发者和开发团队已经依赖 FastAPI 开发他们的项目（包括我和我的团队）。\n\n但，FastAPI 仍有很多改进的余地，也还需要添加更多的功能。\n\n总之，FastAPI 前景光明。\n\n在此，我们衷心感谢[您的帮助](help-fastapi.md){.internal-link target=_blank}。']",FastAPI 是一个用于构建 API 的现代、高性能 Python Web 框架，基于标准 Python 类型提示。其核心特性包括：极高性能（媲美 NodeJS 和 Go）、高效编码（开发速度提升 200%-300%）、智能编辑器自动补全支持，以及自动生成交互式文档（基于 OpenAPI 和 JSON Schema）。所有特性均通过 Starlette 和 Pydantic 实现。,FastAPI 是一个用于构建 API 的现代、高性能的 Python Web 框架，基于标准 Python 类型提示。核心特性包括：1. 高性能：可与 NodeJS 和 Go 并肩（归功于 Starlette 和 Pydantic）；2. 开发速度快：提高功能开发速度约 200% 至 300%；3. 减少 Bug：减少约 40% 的人为错误；4. 直观：强大的编辑器支持和自动补全；5. 简单：易于学习和使用；6. 代码短：最小化代码重复；7. 健壮：生产级代码，自动交互式文档；8. 标准：完全兼容 OpenAPI 和 JSON Schema。,0.9999999999666667,0.8,0.9864907155816955
FastAPI 与 Pydantic 是什么关系？为什么它依赖 Pydantic？,"['# 路径参数\n\nFastAPI 支持使用 Python 字符串格式化语法声明路径参数（变量）：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_item(item_id):\n    return {""item_id"": item_id}\n\n```\n\n\n这段代码把路径参数 `item_id` 的值传递给路径函数的参数 `item_id`。\n\n运行示例并访问 http://127.0.0.1:8000/items/foo，可获得如下响应：\n\n```JSON\n{""item_id"":""foo""}\n```\n\n## 声明路径参数的类型\n\n使用 Python 标准类型注解，声明路径操作函数中路径参数的类型。\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(""/items/{item_id}"")\nasync def read_item(item_id: int):\n    return {""item_id"": item_id}\n\n```\n\n\n本例把 `item_id` 的类型声明为 `int`。\n\n/// check | 检查\n\n类型声明将为函数提供错误检查、代码补全等编辑器支持。\n\n///\n\n## 数据<abbr title=""也称为：序列化、解析"">转换</abbr>\n\n运行示例并访问 http://127.0.0.1:8000/items/3，返回的响应如下：\n\n```JSON\n{""item_id"":3}\n```\n\n/// check | 检查\n\n注意，函数接收并返回的值是 `3`（ `int`），不是 `""3""`（`str`）。\n\nFastAPI 通过类型声明自动<abbr title=""将来自 HTTP 请求中的字符串转换为 Python 数据类型"">解析请求中的数据</abbr>。\n\n///\n\n## 数据校验\n\n通过浏览器访问 http://127.0.0.1:8000/items/foo，接收如下 HTTP 错误信息：\n\n```JSON\n{\n    ""detail"": [\n        {\n            ""loc"": [\n                ""path"",\n                ""item_id""\n            ],\n            ""msg"": ""value is not a valid integer"",\n            ""type"": ""type_error.integer""\n        }\n    ]\n}\n```\n\n这是因为路径参数 `item_id` 的值 （`""foo""`）的类型不是 `int`。\n\n值的类型不是 `int ` 而是浮点数（`float`）时也会显示同样的错误，比如： http://127.0.0.1:8000/items/4.2。\n\n/// check | 检查\n\nFastAPI 使用 Python 类型声明实现了数据校验。\n\n注意，上面的错误清晰地指出了未通过校验的具体原因。\n\n这在开发调试与 API 交互的代码时非常有用。\n\n///\n\n## 查看文档\n\n访问 http://127.0.0.1:8000/docs，查看自动生成的 API 文档：\n\n/// check | 检查\n\n还是使用 Python 类型声明，FastAPI 提供了（集成 Swagger UI 的）API 文档。\n\n注意，路径参数的类型是整数。\n\n///\n\n## 基于标准的好处，备选文档\n\nFastAPI 使用 OpenAPI 生成概图，所以能兼容很多工具。\n\n因此，FastAPI 还内置了 ReDoc 生成的备选 API 文档，可在此查看 http://127.0.0.1:8000/redoc：\n\n同样，还有很多兼容工具，包括多种语言的代码生成工具。\n\n## Pydantic\n\nFastAPI 充分地利用了 Pydantic 的优势，用它在后台校验数据。众所周知，Pydantic 擅长的就是数据校验。\n\n同样，`str`、`float`、`bool` 以及很多复合数据类型都可以使用类型声明。\n\n下一章介绍详细内容。\n\n## 顺序很重要\n\n有时，*路径操作*中的路径是写死的。\n\n比如要使用 `/users/me` 获取当前用户的数据。\n\n然后还要使用 `/users/{user_id}`，通过用户 ID 获取指定用户的数据。\n\n由于*路径操作*是按顺序依次运行的，因此，一定要在 `/users/{user_id}` 之前声明 `/users/me` ：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(""/users/me"")\nasync def read_user_me():\n    return {""user_id"": ""the current user""}\n\n\n@app.get(""/users/{user_id}"")\nasync def read_user(user_id: str):\n    return {""user_id"": user_id}\n\n```\n\n\n否则，`/users/{user_id}` 将匹配 `/users/me`，FastAPI 会认为正在接收值为 `""me""` 的 `user_id` 参数。\n\n## 预设值\n\n路径操作使用 Python 的 <abbr title=""Enumeration"">`Enum`</abbr> 类型接收预设的*路径参数*。\n\n### 创建 `Enum` 类\n\n导入 `Enum` 并创建继承自 `str` 和 `Enum` 的子类。\n\n通过从 `str` 继承，API 文档就能把值的类型定义为字符串，并且能正确渲染。\n\n然后，创建包含固定值的类属性，这些固定值是可用的有效值：\n\n\n```py\nfrom enum import Enum\n\nfrom fastapi import FastAPI\n\n\nclass ModelName(str, Enum):\n    alexnet = ""alexnet""\n    resnet = ""resnet""\n    lenet = ""lenet""\n\n\napp = FastAPI()\n\n\n@app.get(""/models/{model_name}"")\nasync def get_model(model_name: ModelName):\n    if model_name is ModelName.alexnet:\n        return {""model_name"": model_name, ""message"": ""Deep Learning FTW!""}\n\n    if model_name.value == ""lenet"":\n        return {""model_name"": model_name, ""message"": ""LeCNN all the images""}\n\n    return {""model_name"": model_name, ""message"": ""Have some residuals""}\n\n```\n\n\n/// info | 说明\n\nPython 3.4 及之后版本支持枚举（即 enums）。\n\n///\n\n/// tip | 提示\n\nAlexNet、ResNet、LeNet 是机器学习<abbr title=""技术上来说是深度学习模型架构"">模型</abbr>。\n\n///\n\n### 声明*路径参数*\n\n使用 Enum 类（`ModelName`）创建使用类型注解的*路径参数*：\n\n\n> *[Ref: Code file `tutorial005_py39.py` is already included above]*\n\n\n### 查看文档\n\n API 文档会显示预定义*路径参数*的可用值：\n\n### 使用 Python _枚举类型_\n\n*路径参数*的值是枚举的元素。\n\n#### 比较*枚举元素*\n\n枚举类 `ModelName` 中的*枚举元素*支持比较操作：\n\n\n> *[Ref: Code file `tutorial005_py39.py` is already included above]*\n\n\n#### 获取*枚举值*\n\n使用 `model_name.value` 或 `your_enum_member.value` 获取实际的值（本例中为字符串）：\n\n\n> *[Ref: Code file `tutorial005_py39.py` is already included above]*\n\n\n/// tip | 提示\n\n使用 `ModelName.lenet.value` 也能获取值 `""lenet""`。\n\n///\n\n#### 返回*枚举元素*\n\n即使嵌套在 JSON 请求体里（例如， `dict`），也可以从*路径操作*返回*枚举元素*。\n\n返回给客户端之前，要把枚举元素转换为对应的值（本例中为字符串）：\n\n\n> *[Ref: Code file `tutorial005_py39.py` is already included above]*\n\n\n客户端中的 JSON 响应如下：\n\n```JSON\n{\n  ""model_name"": ""alexnet"",\n  ""message"": ""Deep Learning FTW!""\n}\n```\n\n## 包含路径的路径参数\n\n假设*路径操作*的路径为 `/files/{file_path}`。\n\n但需要 `file_path` 中也包含*路径*，比如，`home/johndoe/myfile.txt`。\n\n此时，该文件的 URL 是这样的：`/files/home/johndoe/myfile.txt`。\n\n### OpenAPI 支持\n\nOpenAPI 不支持声明包含路径的*路径参数*，因为这会导致测试和定义更加困难。\n\n不过，仍可使用 Starlette 内置工具在 FastAPI 中实现这一功能。\n\n而且不影响文档正常运行，但是不会添加该参数包含路径的说明。\n\n### 路径转换器\n\n直接使用 Starlette 的选项声明包含*路径*的*路径参数*：\n\n```\n/files/{file_path:path}\n```\n\n本例中，参数名为 `file_path`，结尾部分的 `:path` 说明该参数应匹配*路径*。\n\n用法如下：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(""/files/{file_path:path}"")\nasync def read_file(file_path: str):\n    return {""file_path"": file_path}\n\n```\n\n\n/// tip | 提示\n\n注意，包含 `/home/johndoe/myfile.txt` 的路径参数要以斜杠（`/`）开头。\n\n本例中的 URL 是 `/files//home/johndoe/myfile.txt`。注意，`files` 和 `home` 之间要使用双斜杠（`//`）。\n\n///\n\n## 小结\n\n通过简短、直观的 Python 标准类型声明，FastAPI 可以获得：\n\n- 编辑器支持：错误检查，代码自动补全等\n- 数据<abbr title=""把来自 HTTP 请求中的字符串转换为 Python 数据类型"">解析</abbr>\n- 数据校验\n- API 注解和 API 文档\n\n只需要声明一次即可。\n\n这可能是除了性能以外，FastAPI 与其它框架相比的主要优势。', '# 特性\n\n## FastAPI 特性\n\nFastAPI 提供了以下内容：\n\n### 基于开放标准\n\n* 用于创建 API 的 OpenAPI 包含了<abbr title=""也被叫做: endpoints, routes"">路径</abbr><abbr title=""也叫做HTTP方法, 例如 POST, GET, PUT, DELETE"">操作</abbr>，请求参数，请求体，安全性等的声明。\n* 使用 JSON Schema (因为 OpenAPI 本身就是基于 JSON Schema 的)自动生成数据模型文档。\n* 经过了缜密的研究后围绕这些标准而设计。并非狗尾续貂。\n* 这也允许了在很多语言中自动生成客户端代码。\n\n### 自动生成文档\n\n交互式 API 文档以及具探索性 web 界面。因为该框架是基于 OpenAPI，所以有很多可选项，FastAPI 默认自带两个交互式 API 文档。\n\n* Swagger UI，可交互式操作，能在浏览器中直接调用和测试你的 API  。\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)\n\n* 另外的 API 文档：ReDoc\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)\n\n### 更主流的 Python\n\n全部都基于标准的 Python 3.6 类型声明（感谢 Pydantic ）。没有新的语法需要学习。只需要标准的 Python 。\n\n如果你需要2分钟来学习如何使用 Python 类型（即使你不使用 FastAPI ），看看这个简短的教程：[Python Types](python-types.md){.internal-link target=_blank}。\n\n编写带有类型标注的标准 Python：\n\n```Python\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n# Declare a variable as a str\n# and get editor support inside the function\ndef main(user_id: str):\n    return user_id\n\n# A Pydantic model\nclass User(BaseModel):\n    id: int\n    name: str\n    joined: date\n```\n\n可以像这样来使用：\n\n```Python\nmy_user: User = User(id=3, name=""John Doe"", joined=""2018-07-19"")\n\nsecond_user_data = {\n    ""id"": 4,\n    ""name"": ""Mary"",\n    ""joined"": ""2018-11-30"",\n}\n\nmy_second_user: User = User(second_user_data)\n```\n\n/// info\n\n`second_user_data` 意思是:\n\n直接将`second_user_data`字典的键和值直接作为key-value参数传递，等同于：`User(id=4, name=""Mary"", joined=""2018-11-30"")`\n\n///\n\n### 编辑器支持\n\n整个框架都被设计得易于使用且直观，所有的决定都在开发之前就在多个编辑器上进行了测试，来确保最佳的开发体验。\n\n在最近的 Python 开发者调查中，我们能看到 被使用最多的功能是""自动补全""。\n\n整个 FastAPI 框架就是基于这一点的。任何地方都可以进行自动补全。\n\n你几乎不需要经常回来看文档。\n\n在这里，你的编辑器可能会这样帮助你：\n\n* Visual Studio Code 中:\n\n![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)\n\n* PyCharm 中:\n\n![editor support](https://fastapi.tiangolo.com/img/pycharm-completion.png)\n\n你将能进行代码补全，这是在之前你可能曾认为不可能的事。例如，在来自请求 JSON 体（可能是嵌套的）中的键 `price`。\n\n不会再输错键名，来回翻看文档，或者来回滚动寻找你最后使用的 `username` 或者 `user_name` 。\n\n### 简洁\n\n任何类型都有合理的默认值，任何和地方都有可选配置。所有的参数被微调，来满足你的需求，定义成你需要的 API。\n\n但是默认情况下，一切都能“顺利工作”。\n\n### 验证\n\n* 校验大部分（甚至所有？）的 Python 数据类型，包括：\n    * JSON 对象 (`dict`).\n    * JSON 数组 (`list`) 定义成员类型。\n    * 字符串 (`str`) 字段, 定义最小或最大长度。\n    * 数字 (`int`, `float`) 有最大值和最小值， 等等。\n\n* 校验外来类型， 比如:\n    * URL.\n    * Email.\n    * UUID.\n    * ...及其他.\n\n所有的校验都由完善且强大的 Pydantic 处理。\n\n### 安全性及身份验证\n\n集成了安全性和身份认证。杜绝数据库或者数据模型的渗透风险。\n\nOpenAPI 中定义的安全模式，包括：\n\n* HTTP 基本认证。\n* OAuth2 (也使用 JWT tokens)。在 [OAuth2 with JWT](tutorial/security/oauth2-jwt.md){.internal-link target=_blank}查看教程。\n* API 密钥，在:\n    * 请求头。\n    * 查询参数。\n    * Cookies, 等等。\n\n加上来自 Starlette（包括 session cookie）的所有安全特性。\n\n所有的这些都是可复用的工具和组件，可以轻松与你的系统，数据仓库，关系型以及 NoSQL 数据库等等集成。\n\n### 依赖注入\n\nFastAPI 有一个使用非常简单，但是非常强大的<abbr title=\'也叫做 ""components"", ""resources"", ""services"", ""providers""\'>依赖注入</abbr>系统。\n\n* 甚至依赖也可以有依赖，创建一个层级或者“图”依赖。\n* 所有自动化处理都由框架完成。\n* 所有的依赖关系都可以从请求中获取数据，并且增加了路径操作约束和自动文档生成。\n* 即使在依赖项中被定义的*路径操作* 也会自动验证。\n* 支持复杂的用户身份认证系统，数据库连接等等。\n* 不依赖数据库，前端等。 但是和它们集成很简单。\n\n### 无限制""插件""\n\n或者说，导入并使用你需要的代码，而不需要它们。\n\n任何集成都被设计得被易于使用（用依赖关系），你可以用和*路径操作*相同的结构和语法，在两行代码中为你的应用创建一个“插件”。\n\n### 测试\n\n* 100% <abbr title=""自动测试的代码量"">测试覆盖</abbr>。\n* 代码库100% <abbr title=""Python类型注解，有了这个你的编辑器和外部工具可以给你更好的支持"">类型注释</abbr>。\n* 用于生产应用。\n\n## Starlette 特性\n\nFastAPI 和 Starlette 完全兼容(并基于)。所以，你有的其他的 Starlette 代码也能正常工作。`FastAPI` 实际上是 `Starlette`的一个子类。所以，如果你已经知道或者使用 Starlette，大部分的功能会以相同的方式工作。\n\n通过 FastAPI 你可以获得所有 Starlette 的特性 ( FastAPI 就像加强版的 Starlette )：\n\n* 令人惊叹的性能。它是 Python 可用的最快的框架之一，和\xa0NodeJS 及\xa0Go 相当。\n* 支持 WebSocket 。\n* 支持 GraphQL 。\n* 后台任务处理。\n* Startup 和 shutdown 事件。\n* 测试客户端基于 HTTPX。\n* CORS, GZip, 静态文件, 流响应。\n* 支持 Session 和 Cookie 。\n* 100% 测试覆盖率。\n* 代码库 100% 类型注释。\n\n## Pydantic 特性\n\nFastAPI 和 Pydantic 完全兼容(并基于)。所以，你有的其他的 Pydantic 代码也能正常工作。\n\n兼容包括基于 Pydantic 的外部库， 例如用与数据库的 <abbr title=""对象关系映射"">ORM</abbr>s, <abbr title=""对象文档映射"">ODM</abbr>s。\n\n这也意味着在很多情况下，你可以将从请求中获得的相同对象直接传到数据库，因为所有的验证都是自动的。\n\n反之亦然，在很多情况下，你也可以将从数据库中获取的对象直接传到客户端。\n\n通过 FastAPI 你可以获得所有 Pydantic  (FastAPI 基于 Pydantic 做了所有的数据处理)：\n\n* 更简单：\n    * 没有新的模式定义 micro-language 需要学习。\n    * 如果你知道 Python types，你就知道如何使用 Pydantic。\n* 和你 <abbr title=""集成开发环境，和代码编辑器类似"">IDE</abbr>/<abbr title=""一个检查代码错误的程序"">linter</abbr>/brain 适配:\n    * 因为 pydantic 数据结构仅仅是你定义的类的实例；自动补全，linting，mypy 以及你的直觉应该可以和你验证的数据一起正常工作。\n* 验证复杂结构:\n    * 使用分层的 Pydantic 模型, Python `typing`的 `List` 和 `Dict` 等等。\n    * 验证器使我们能够简单清楚的将复杂的数据模式定义、检查并记录为 JSON Schema。\n    * 你可以拥有深度嵌套的 JSON 对象并对它们进行验证和注释。\n* 可扩展:\n    * Pydantic 允许定义自定义数据类型或者你可以用验证器装饰器对被装饰的模型上的方法扩展验证。\n* 100% 测试覆盖率。', '# 请求体 - 嵌套模型\n\n使用 FastAPI，你可以定义、校验、记录文档并使用任意深度嵌套的模型（归功于Pydantic）。\n\n## List 字段\n\n你可以将一个属性定义为拥有子元素的类型。例如 Python `list`：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: list = []\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n这将使 `tags` 成为一个由元素组成的列表。不过它没有声明每个元素的类型。\n\n## 具有子类型的 List 字段\n\n但是 Python 有一种特定的方法来声明具有子类型的列表：\n\n### 从 typing 导入 `List`\n\n首先，从 Python 的标准库 `typing` 模块中导入 `List`：\n\n\n```py\nfrom typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Union[str, None] = None\n    price: float\n    tax: Union[float, None] = None\n    tags: list[str] = []\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n### 声明具有子类型的 List\n\n要声明具有子类型的类型，例如 `list`、`dict`、`tuple`：\n\n* 从 `typing` 模块导入它们\n* 使用方括号 `[` 和 `]` 将子类型作为「类型参数」传入\n\n```Python\nfrom typing import List\n\nmy_list: List[str]\n```\n\n这完全是用于类型声明的标准 Python 语法。\n\n对具有子类型的模型属性也使用相同的标准语法。\n\n因此，在我们的示例中，我们可以将 `tags` 明确地指定为一个「字符串列表」：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: list[str] = []\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n## Set 类型\n\n但是随后我们考虑了一下，意识到标签不应该重复，它们很大可能会是唯一的字符串。\n\nPython 具有一种特殊的数据类型来保存一组唯一的元素，即 `set`。\n\n然后我们可以导入 `Set` 并将 `tag` 声明为一个由 `str` 组成的 `set`：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n这样，即使你收到带有重复数据的请求，这些数据也会被转换为一组唯一项。\n\n而且，每当你输出该数据时，即使源数据有重复，它们也将作为一组唯一项输出。\n\n并且还会被相应地标注 / 记录文档。\n\n## 嵌套模型\n\nPydantic 模型的每个属性都具有类型。\n\n但是这个类型本身可以是另一个 Pydantic 模型。\n\n因此，你可以声明拥有特定属性名称、类型和校验的深度嵌套的 JSON 对象。\n\n上述这些都可以任意的嵌套。\n\n### 定义子模型\n\n例如，我们可以定义一个 `Image` 模型：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: str\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n    image: Image | None = None\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n### 将子模型用作类型\n\n然后我们可以将其用作一个属性的类型：\n\n\n> *[Ref: Code file `tutorial004_py310.py` is already included above]*\n\n\n这意味着 FastAPI 将期望类似于以下内容的请求体：\n\n```JSON\n{\n    ""name"": ""Foo"",\n    ""description"": ""The pretender"",\n    ""price"": 42.0,\n    ""tax"": 3.2,\n    ""tags"": [""rock"", ""metal"", ""bar""],\n    ""image"": {\n        ""url"": ""http://example.com/baz.jpg"",\n        ""name"": ""The Foo live""\n    }\n}\n```\n\n再一次，仅仅进行这样的声明，你将通过 FastAPI 获得：\n\n* 对被嵌入的模型也适用的编辑器支持（自动补全等）\n* 数据转换\n* 数据校验\n* 自动生成文档\n\n## 特殊的类型和校验\n\n除了普通的单一值类型（如 `str`、`int`、`float` 等）外，你还可以使用从 `str` 继承的更复杂的单一值类型。\n\n要了解所有的可用选项，请查看关于 来自 Pydantic 的外部类型 的文档。你将在下一章节中看到一些示例。\n\n例如，在 `Image` 模型中我们有一个 `url` 字段，我们可以把它声明为 Pydantic 的 `HttpUrl`，而不是 `str`：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n    image: Image | None = None\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n该字符串将被检查是否为有效的 URL，并在 JSON Schema / OpenAPI 文档中进行记录。\n\n## 带有一组子模型的属性\n\n你还可以将 Pydantic 模型用作 `list`、`set` 等的子类型：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n    images: list[Image] | None = None\n\n\n@app.put(""/items/{item_id}"")\nasync def update_item(item_id: int, item: Item):\n    results = {""item_id"": item_id, ""item"": item}\n    return results\n\n```\n\n\n这将期望（转换，校验，记录文档等）下面这样的 JSON 请求体：\n\n```JSON hl_lines=""11""\n{\n    ""name"": ""Foo"",\n    ""description"": ""The pretender"",\n    ""price"": 42.0,\n    ""tax"": 3.2,\n    ""tags"": [\n        ""rock"",\n        ""metal"",\n        ""bar""\n    ],\n    ""images"": [\n        {\n            ""url"": ""http://example.com/baz.jpg"",\n            ""name"": ""The Foo live""\n        },\n        {\n            ""url"": ""http://example.com/dave.jpg"",\n            ""name"": ""The Baz""\n        }\n    ]\n}\n```\n\n/// info\n\n请注意 `images` 键现在具有一组 image 对象是如何发生的。\n\n///\n\n## 深度嵌套模型\n\n你可以定义任意深度的嵌套模型：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n    tags: set[str] = set()\n    images: list[Image] | None = None\n\n\nclass Offer(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    items: list[Item]\n\n\n@app.post(""/offers/"")\nasync def create_offer(offer: Offer):\n    return offer\n\n```\n\n\n/// info\n\n请注意 `Offer` 拥有一组 `Item` 而反过来 `Item` 又是一个可选的 `Image` 列表是如何发生的。\n\n///\n\n## 纯列表请求体\n\n如果你期望的 JSON 请求体的最外层是一个 JSON `array`（即 Python `list`），则可以在路径操作函数的参数中声明此类型，就像声明 Pydantic 模型一样：\n\n```Python\nimages: List[Image]\n```\n\n例如：\n\n\n```py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\n@app.post(""/images/multiple/"")\nasync def create_multiple_images(images: list[Image]):\n    return images\n\n```\n\n\n## 无处不在的编辑器支持\n\n你可以随处获得编辑器支持。\n\n即使是列表中的元素：\n\n如果你直接使用 `dict` 而不是 Pydantic 模型，那你将无法获得这种编辑器支持。\n\n但是你根本不必担心这两者，传入的字典会自动被转换，你的输出也会自动被转换为 JSON。\n\n## 任意 `dict` 构成的请求体\n\n你也可以将请求体声明为使用某类型的键和其他类型值的 `dict`。\n\n无需事先知道有效的字段/属性（在使用 Pydantic 模型的场景）名称是什么。\n\n如果你想接收一些尚且未知的键，这将很有用。\n\n其他有用的场景是当你想要接收其他类型的键时，例如 `int`。\n\n这也是我们在接下来将看到的。\n\n在下面的例子中，你将接受任意键为 `int` 类型并且值为 `float` 类型的 `dict`：\n\n\n```py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.post(""/index-weights/"")\nasync def create_index_weights(weights: dict[int, float]):\n    return weights\n\n```\n\n\n/// tip\n\n请记住 JSON 仅支持将 `str` 作为键。\n\n但是 Pydantic 具有自动转换数据的功能。\n\n这意味着，即使你的 API 客户端只能将字符串作为键发送，只要这些字符串内容仅包含整数，Pydantic 就会对其进行转换并校验。\n\n然后你接收的名为 `weights` 的 `dict` 实际上将具有 `int` 类型的键和 `float` 类型的值。\n\n///\n\n## 总结\n\n使用 FastAPI 你可以拥有 Pydantic 模型提供的极高灵活性，同时保持代码的简单、简短和优雅。\n\n而且还具有下列好处：\n\n* 编辑器支持（处处皆可自动补全！）\n* 数据转换（也被称为解析/序列化）\n* 数据校验\n* 模式文档\n* 自动生成的文档', '# Python 类型提示简介\n\nPython 3.6+ 版本加入了对""类型提示""的支持。\n\n这些""类型提示""是一种新的语法（在 Python 3.6 版本加入）用来声明一个变量的<abbr title=""例如：str、int、float、bool"">类型</abbr>。\n\n通过声明变量的类型，编辑器和一些工具能给你提供更好的支持。\n\n这只是一个关于 Python 类型提示的快速入门 / 复习。它仅涵盖与 FastAPI 一起使用所需的最少部分...实际上只有很少一点。\n\n整个 FastAPI 都基于这些类型提示构建，它们带来了许多优点和好处。\n\n但即使你不会用到 FastAPI，了解一下类型提示也会让你从中受益。\n\n/// note\n\n如果你已经精通 Python，并且了解关于类型提示的一切知识，直接跳到下一章节吧。\n\n///\n\n## 动机\n\n让我们从一个简单的例子开始：\n\n\n```py\ndef get_full_name(first_name, last_name):\n    full_name = first_name.title() + "" "" + last_name.title()\n    return full_name\n\n\nprint(get_full_name(""john"", ""doe""))\n\n```\n\n\n运行这段程序将输出：\n\n```\nJohn Doe\n```\n\n这个函数做了下面这些事情：\n\n* 接收 `first_name` 和 `last_name` 参数。\n* 通过 `title()` 将每个参数的第一个字母转换为大写形式。\n* 中间用一个空格来<abbr title=""将它们按顺序放置组合成一个整体。"">拼接</abbr>它们。\n\n\n> *[Ref: Code file `tutorial001_py39.py` is already included above]*\n\n\n### 修改示例\n\n这是一个非常简单的程序。\n\n现在假设你将从头开始编写这段程序。\n\n在某一时刻，你开始定义函数，并且准备好了参数...。\n\n现在你需要调用一个""将第一个字母转换为大写形式的方法""。\n\n等等，那个方法是什么来着？`upper`？还是 `uppercase`？`first_uppercase`？`capitalize`？\n\n然后你尝试向程序员老手的朋友——编辑器自动补全寻求帮助。\n\n输入函数的第一个参数 `first_name`，输入点号（`.`）然后敲下 `Ctrl+Space` 来触发代码补全。\n\n但遗憾的是并没有起什么作用：\n\n### 添加类型\n\n让我们来修改上面例子的一行代码。\n\n我们将把下面这段代码中的函数参数从：\n\n```Python\n    first_name, last_name\n```\n\n改成：\n\n```Python\n    first_name: str, last_name: str\n```\n\n就是这样。\n\n这些就是""类型提示""：\n\n\n```py\ndef get_full_name(first_name: str, last_name: str):\n    full_name = first_name.title() + "" "" + last_name.title()\n    return full_name\n\n\nprint(get_full_name(""john"", ""doe""))\n\n```\n\n\n这和声明默认值是不同的，例如：\n\n```Python\n    first_name=""john"", last_name=""doe""\n```\n\n这两者不一样。\n\n我们用的是冒号（`:`），不是等号（`=`）。\n\n而且添加类型提示一般不会改变原来的运行结果。\n\n现在假设我们又一次正在创建这个函数，这次添加了类型提示。\n\n在同样的地方，通过 `Ctrl+Space` 触发自动补全，你会发现：\n\n这样，你可以滚动查看选项，直到你找到看起来眼熟的那个：\n\n## 更多动机\n\n下面是一个已经有类型提示的函数：\n\n\n```py\ndef get_name_with_age(name: str, age: int):\n    name_with_age = name + "" is this old: "" + age\n    return name_with_age\n\n```\n\n\n因为编辑器已经知道了这些变量的类型，所以不仅能对代码进行补全，还能检查其中的错误：\n\n现在你知道了必须先修复这个问题，通过 `str(age)` 把 `age` 转换成字符串：\n\n\n```py\ndef get_name_with_age(name: str, age: int):\n    name_with_age = name + "" is this old: "" + str(age)\n    return name_with_age\n\n```\n\n\n## 声明类型\n\n你刚刚看到的就是声明类型提示的主要场景。用于函数的参数。\n\n这也是你将在 FastAPI 中使用它们的主要场景。\n\n### 简单类型\n\n不只是 `str`，你能够声明所有的标准 Python 类型。\n\n比如以下类型：\n\n* `int`\n* `float`\n* `bool`\n* `bytes`\n\n\n```py\ndef get_items(item_a: str, item_b: int, item_c: float, item_d: bool, item_e: bytes):\n    return item_a, item_b, item_c, item_d, item_e\n\n```\n\n\n### 嵌套类型\n\n有些容器数据结构可以包含其他的值，比如 `dict`、`list`、`set` 和 `tuple`。它们内部的值也会拥有自己的类型。\n\n你可以使用 Python 的 `typing` 标准库来声明这些类型以及子类型。\n\n它专门用来支持这些类型提示。\n\n#### 列表\n\n例如，让我们来定义一个由 `str` 组成的 `list` 变量。\n\n从 `typing` 模块导入 `List`（注意是大写的 `L`）：\n\n\n```py\ndef process_items(items: list[str]):\n    for item in items:\n        print(item)\n\n```\n\n\n同样以冒号（`:`）来声明这个变量。\n\n输入 `List` 作为类型。\n\n由于列表是带有""子类型""的类型，所以我们把子类型放在方括号中：\n\n\n> *[Ref: Code file `tutorial006_py39.py` is already included above]*\n\n\n这表示：""变量 `items` 是一个 `list`，并且这个列表里的每一个元素都是 `str`""。\n\n这样，即使在处理列表中的元素时，你的编辑器也可以提供支持。\n\n没有类型，几乎是不可能实现下面这样：\n\n注意，变量 `item` 是列表 `items` 中的元素之一。\n\n而且，编辑器仍然知道它是一个 `str`，并为此提供了支持。\n\n#### 元组和集合\n\n声明 `tuple` 和 `set` 的方法也是一样的：\n\n\n```py\ndef process_items(items_t: tuple[int, int, str], items_s: set[bytes]):\n    return items_t, items_s\n\n```\n\n\n这表示：\n\n* 变量 `items_t` 是一个 `tuple`，其中的前两个元素都是 `int` 类型, 最后一个元素是 `str` 类型。\n* 变量 `items_s` 是一个 `set`，其中的每个元素都是 `bytes` 类型。\n\n#### 字典\n\n定义 `dict` 时，需要传入两个子类型，用逗号进行分隔。\n\n第一个子类型声明 `dict` 的所有键。\n\n第二个子类型声明 `dict` 的所有值：\n\n\n```py\ndef process_items(prices: dict[str, float]):\n    for item_name, item_price in prices.items():\n        print(item_name)\n        print(item_price)\n\n```\n\n\n这表示：\n\n* 变量 `prices` 是一个 `dict`：\n    * 这个 `dict` 的所有键为 `str` 类型（可以看作是字典内每个元素的名称）。\n    * 这个 `dict` 的所有值为 `float` 类型（可以看作是字典内每个元素的价格）。\n\n### 类作为类型\n\n你也可以将类声明为变量的类型。\n\n假设你有一个名为 `Person` 的类，拥有 name 属性：\n\n\n```py\nclass Person:\n    def __init__(self, name: str):\n        self.name = name\n\n\ndef get_person_name(one_person: Person):\n    return one_person.name\n\n```\n\n\n接下来，你可以将一个变量声明为 `Person` 类型：\n\n\n> *[Ref: Code file `tutorial010_py39.py` is already included above]*\n\n\n然后，你将再次获得所有的编辑器支持：\n\n## Pydantic 模型\n\nPydantic 是一个用来执行数据校验的 Python 库。\n\n你可以将数据的""结构""声明为具有属性的类。\n\n每个属性都拥有类型。\n\n接着你用一些值来创建这个类的实例，这些值会被校验，并被转换为适当的类型（在需要的情况下），返回一个包含所有数据的对象。\n\n然后，你将获得这个对象的所有编辑器支持。\n\n下面的例子来自 Pydantic 官方文档：\n\n//// tab | Python 3.10+\n\n```Python\n{!&gt; ../../docs_src/python_types/tutorial011_py310.py!}\n```\n\n////\n\n//// tab | Python 3.9+\n\n```Python\n{!&gt; ../../docs_src/python_types/tutorial011_py39.py!}\n```\n\n////\n\n//// tab | Python 3.8+\n\n```Python\n{!&gt; ../../docs_src/python_types/tutorial011.py!}\n```\n\n////\n\n/// info\n\n想进一步了解 Pydantic，请阅读其文档.\n\n///\n\n整个 FastAPI 建立在 Pydantic 的基础之上。\n\n实际上你将在 [教程 - 用户指南](tutorial/index.md){.internal-link target=_blank} 看到很多这种情况。\n\n## FastAPI 中的类型提示\n\nFastAPI 利用这些类型提示来做下面几件事。\n\n使用 FastAPI 时用类型提示声明参数可以获得：\n\n* 编辑器支持。\n* 类型检查。\n\n...并且 FastAPI 还会用这些类型声明来：\n\n* 定义参数要求：声明对请求路径参数、查询参数、请求头、请求体、依赖等的要求。\n* 转换数据：将来自请求的数据转换为需要的类型。\n* 校验数据： 对于每一个请求：\n    * 当数据校验失败时自动生成错误信息返回给客户端。\n* 使用 OpenAPI 记录 API：\n    * 然后用于自动生成交互式文档的用户界面。\n\n听上去有点抽象。不过不用担心。你将在 [教程 - 用户指南](tutorial/index.md){.internal-link target=_blank} 中看到所有的实战。\n\n最重要的是，通过使用标准的 Python 类型，只需要在一个地方声明（而不是添加更多的类、装饰器等），FastAPI 会为你完成很多的工作。\n\n/// info\n\n如果你已经阅读了所有教程，回过头来想了解有关类型的更多信息，来自 `mypy` 的""速查表""是不错的资源。\n\n///']","FastAPI 依赖 Pydantic 实现数据校验、自动类型转换和文档生成。  
上下文明确指出：FastAPI 在后台使用 Pydantic 进行数据校验（如路径参数类型检查），并利用其类型声明自动解析请求数据（如字符串转整数）。  
此外，Pydantic 支持 FastAPI 自动生成 OpenAPI 文档（如 Swagger UI）。",FastAPI 与 Pydantic 是深度集成的关系。FastAPI 使用 Pydantic 来进行数据的定义、校验、序列化（数据转换）和自动生成 OpenAPI Schema。它依赖 Pydantic 的原因在于：Pydantic 提供了强大的类型声明能力，使得 FastAPI 能够自动验证传入的请求数据是否符合预期格式，并将复杂的数据库对象或 Python 模型自动转换为 JSON 格式。此外，这种基于类型提示的定义方式直接驱动了 Swagger UI 的自动生成。,0.999999999975,1.0,0.7818932073125273
FastAPI 的依赖注入系统（Dependency Injection）是如何工作的？请举例说明 Depends 的用法。,"['# 依赖项\n\nFastAPI 提供了简单易用，但功能强大的<abbr title=""也称为组件、资源、提供者、服务、可注入项"">依赖注入</abbr>系统。\n\n这个依赖系统设计的简单易用，可以让开发人员轻松地把组件集成至 FastAPI。\n\n## 什么是「依赖注入」\n\n编程中的「依赖注入」是声明代码（本文中为*路径操作函数* ）运行所需的，或要使用的「依赖」的一种方式。\n\n然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n\n依赖注入常用于以下场景：\n\n* 共享业务逻辑（复用相同的代码逻辑）\n* 共享数据库连接\n* 实现安全、验证、角色权限\n* 等……\n\n上述场景均可以使用依赖注入，将代码重复最小化。\n\n## 第一步\n\n接下来，我们学习一个非常简单的例子，尽管它过于简单，不是很实用。\n\n但通过这个例子，您可以初步了解「依赖注入」的工作机制。\n\n### 创建依赖项\n\n首先，要关注的是依赖项。\n\n依赖项就是一个函数，且可以使用与*路径操作函数*相同的参数：\n\n\n```py\nfrom typing import Annotated, Union\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(\n    q: Union[str, None] = None, skip: int = 0, limit: int = 100\n):\n    return {""q"": q, ""skip"": skip, ""limit"": limit}\n\n\n@app.get(""/items/"")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n\n@app.get(""/users/"")\nasync def read_users(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n```\n\n\n大功告成。\n\n只用了2 行代码。\n\n依赖项函数的形式和结构与*路径操作函数*一样。\n\n因此，可以把依赖项当作没有「装饰器」（即，没有 `@app.get(""/some-path"")` ）的路径操作函数。\n\n依赖项可以返回各种内容。\n\n本例中的依赖项预期接收如下参数：\n\n* 类型为 `str` 的可选查询参数 `q`\n* 类型为 `int` 的可选查询参数 `skip`，默认值是 `0`\n* 类型为 `int` 的可选查询参数 `limit`，默认值是 `100`\n\n然后，依赖项函数返回包含这些值的 `dict`。\n\n### 导入 `Depends`\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n### 声明依赖项\n\n与在*路径操作函数*参数中使用 `Body`、`Query` 的方式相同，声明依赖项需要使用 `Depends` 和一个新的参数：\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n虽然，在路径操作函数的参数中使用 `Depends` 的方式与 `Body`、`Query` 相同，但 `Depends` 的工作方式略有不同。\n\n这里只能传给 Depends 一个参数。\n\n且该参数必须是可调用对象，比如函数。\n\n该函数接收的参数和*路径操作函数*的参数一样。\n\n/// tip | 提示\n\n下一章介绍，除了函数还有哪些「对象」可以用作依赖项。\n\n///\n\n接收到新的请求时，FastAPI 执行如下操作：\n\n* 用正确的参数调用依赖项函数（「可依赖项」）\n* 获取函数返回的结果\n* 把函数返回的结果赋值给*路径操作函数*的参数\n\n```mermaid\ngraph TB\n\ncommon_parameters([""common_parameters""])\nread_items[""/items/""]\nread_users[""/users/""]\n\ncommon_parameters --&gt; read_items\ncommon_parameters --&gt; read_users\n```\n\n这样，只编写一次代码，FastAPI 就可以为多个*路径操作*共享这段代码 。\n\n/// check | 检查\n\n注意，无需创建专门的类，并将之传递给 FastAPI 以进行「注册」或执行类似的操作。\n\n只要把它传递给 `Depends`，FastAPI 就知道该如何执行后续操作。\n\n///\n\n## 要不要使用 `async`？\n\nFastAPI 调用依赖项的方式与*路径操作函数*一样，因此，定义依赖项函数，也要应用与路径操作函数相同的规则。\n\n即，既可以使用异步的 `async def`，也可以使用普通的 `def` 定义依赖项。\n\n在普通的 `def` *路径操作函数*中，可以声明异步的 `async def` 依赖项；也可以在异步的 `async def` *路径操作函数*中声明普通的 `def` 依赖项。\n\n上述这些操作都是可行的，FastAPI 知道该怎么处理。\n\n/// note | 笔记\n\n如里不了解异步，请参阅[异步：*“着急了？”*](../../async.md){.internal-link target=_blank} 一章中 `async` 和 `await` 的内容。\n\n///\n\n## 与 OpenAPI 集成\n\n依赖项及子依赖项的所有请求声明、验证和需求都可以集成至同一个 OpenAPI 概图。\n\n所以，交互文档里也会显示依赖项的所有信息：\n\n## 简单用法\n\n观察一下就会发现，只要*路径* 和*操作*匹配，就可以使用声明的路径操作函数。然后，FastAPI 会用正确的参数调用函数，并提取请求中的数据。\n\n实际上，所有（或大多数）网络框架的工作方式都是这样的。\n\n开发人员永远都不需要直接调用这些函数，这些函数是由框架（在此为 FastAPI ）调用的。\n\n通过依赖注入系统，只要告诉 FastAPI *路径操作函数* 还要「依赖」其他在*路径操作函数*之前执行的内容，FastAPI 就会执行函数代码，并「注入」函数返回的结果。\n\n其他与「依赖注入」概念相同的术语为：\n\n* 资源（Resource）\n* 提供方（Provider）\n* 服务（Service）\n* 可注入（Injectable）\n* 组件（Component）\n\n## FastAPI 插件\n\n依赖注入系统支持构建集成和「插件」。但实际上，FastAPI 根本不需要创建「插件」，因为使用依赖项可以声明不限数量的、可用于*路径操作函数*的集成与交互。\n\n创建依赖项非常简单、直观，并且还支持导入 Python 包。毫不夸张地说，只要几行代码就可以把需要的 Python 包与 API 函数集成在一起。\n\n下一章将详细介绍在关系型数据库、NoSQL 数据库、安全等方面使用依赖项的例子。\n\n## FastAPI 兼容性\n\n依赖注入系统如此简洁的特性，让 FastAPI 可以与下列系统兼容：\n\n* 关系型数据库\n* NoSQL 数据库\n* 外部支持库\n* 外部 API\n* 认证和鉴权系统\n* API 使用监控系统\n* 响应数据注入系统\n* 等等……\n\n## 简单而强大\n\n虽然，层级式依赖注入系统的定义与使用十分简单，但它却非常强大。\n\n比如，可以定义依赖其他依赖项的依赖项。\n\n最后，依赖项层级树构建后，依赖注入系统会处理所有依赖项及其子依赖项，并为每一步操作提供（注入）结果。\n\n比如，下面有 4 个 API 路径操作（*端点*）：\n\n* `/items/public/`\n* `/items/private/`\n* `/users/{user_id}/activate`\n* `/items/pro/`\n\n开发人员可以使用依赖项及其子依赖项为这些路径操作添加不同的权限：\n\n```mermaid\ngraph TB\n\ncurrent_user([""current_user""])\nactive_user([""active_user""])\nadmin_user([""admin_user""])\npaying_user([""paying_user""])\n\npublic[""/items/public/""]\nprivate[""/items/private/""]\nactivate_user[""/users/{user_id}/activate""]\npro_items[""/items/pro/""]\n\ncurrent_user --&gt; active_user\nactive_user --&gt; admin_user\nactive_user --&gt; paying_user\n\ncurrent_user --&gt; public\nactive_user --&gt; private\nadmin_user --&gt; activate_user\npaying_user --&gt; pro_items\n```\n\n## 与 OpenAPI 集成\n\n在声明需求时，所有这些依赖项还会把参数、验证等功能添加至路径操作。\n\nFastAPI 负责把上述内容全部添加到 OpenAPI 概图，并显示在交互文档中。']","根据上下文：  
1. FastAPI的依赖注入系统通过`Depends()`声明路径操作函数所需的依赖项，依赖项是接收请求参数的普通函数。  
2. 例如，`common_parameters`函数封装查询参数处理逻辑，通过`commons: Annotated[dict, Depends(common_parameters)]`注入多个路由复用。  
3. 请求时FastAPI自动执行依赖函数，将其返回值注入目标路由参数，实现代码复用（如校验、数据库连接等）。","FastAPI 的依赖注入（DI）系统允许你声明路由函数运行前需要执行的逻辑。FastAPI 负责在运行路由前解析这些依赖，并将其结果注入给函数。用法举例：定义一个函数 `common_params(q: str = None, skip: int = 0)`，然后在路由中使用 `params: dict = Depends(common_params)`。当请求到达时，FastAPI 会先调用 `common_params`，处理 URL 参数，再将返回的字典传递给路由。这有助于代码复用、共享数据库连接和实现安全验证。",0.9999999999,1.0,0.8040173634556347
在 FastAPI 中，async def 和普通 def 定义路由的处理逻辑有什么区别？什么时候该用哪种？,"['# 并发 async / await\n\n有关路径操作函数的 `async def` 语法以及异步代码、并发和并行的一些背景知识。\n\n## 赶时间吗？\n\n<abbr title=""too long; didn\'t read(长文警告)"">TL;DR:</abbr>\n\n如果你正在使用第三方库，它们会告诉你使用 `await` 关键字来调用它们，就像这样：\n\n```Python\nresults = await some_library()\n```\n\n然后，通过 `async def` 声明你的 *路径操作函数*：\n\n```Python hl_lines=""2""\n@app.get(\'/\')\nasync def read_results():\n    results = await some_library()\n    return results\n```\n\n/// note\n\n你只能在被 `async def` 创建的函数内使用 `await`\n\n///\n\n如果你正在使用一个第三方库和某些组件（比如：数据库、API、文件系统...）进行通信，第三方库又不支持使用 `await` （目前大多数数据库三方库都是这样），这种情况你可以像平常那样使用 `def` 声明一个路径操作函数，就像这样：\n\n```Python hl_lines=""2""\n@app.get(\'/\')\ndef results():\n    results = some_library()\n    return results\n```\n\n如果你的应用程序不需要与其他任何东西通信而等待其响应，请使用 `async def`。\n\n如果你不清楚，使用 `def` 就好.\n\n注意：你可以根据需要在路径操作函数中混合使用 `def` 和 `async def`，并使用最适合你的方式去定义每个函数。FastAPI 将为他们做正确的事情。\n\n无论如何，在上述任何情况下，FastAPI 仍将异步工作，速度也非常快。\n\n但是，通过遵循上述步骤，它将能够进行一些性能优化。\n\n## 技术细节\n\nPython 的现代版本支持通过一种叫""协程""——使用 `async` 和 `await` 语法的东西来写”异步代码“。\n\n让我们在下面的部分中逐一介绍：\n\n* 异步代码\n* `async` 和 `await`\n* 协程\n\n## 异步代码\n\n异步代码仅仅意味着编程语言 💬 有办法告诉计算机/程序 🤖 在代码中的某个点，它 🤖 将不得不等待在某些地方完成一些事情。让我们假设一些事情被称为 ""慢文件""📝.\n\n所以，在等待""慢文件""📝完成的这段时间，计算机可以做一些其他工作。\n\n然后计算机/程序 🤖 每次有机会都会回来，因为它又在等待，或者它 🤖 完成了当前所有的工作。而且它 🤖 将查看它等待的所有任务中是否有已经完成的，做它必须做的任何事情。\n\n接下来，它 🤖 完成第一个任务（比如是我们的""慢文件""📝) 并继续与之相关的一切。\n\n这个""等待其他事情""通常指的是一些相对较慢（与处理器和 RAM 存储器的速度相比）的 <abbr title=""Input and Output"">I/O</abbr> 操作，比如说：\n\n* 通过网络发送来自客户端的数据\n* 客户端接收来自网络中的数据\n* 磁盘中要由系统读取并提供给程序的文件的内容\n* 程序提供给系统的要写入磁盘的内容\n* 一个 API 的远程调用\n* 一个数据库操作，直到完成\n* 一个数据库查询，直到返回结果\n* 等等.\n\n这个执行的时间大多是在等待 <abbr title=""Input and Output"">I/O</abbr> 操作，因此它们被叫做 ""I/O 密集型"" 操作。\n\n它被称为""异步""的原因是因为计算机/程序不必与慢任务""同步""，去等待任务完成的确切时刻，而在此期间不做任何事情直到能够获取任务结果才继续工作。\n\n相反，作为一个""异步""系统，一旦完成，任务就可以排队等待一段时间（几微秒），等待计算机程序完成它要做的任何事情，然后回来获取结果并继续处理它们。\n\n对于""同步""（与""异步""相反），他们通常也使用""顺序""一词，因为计算机程序在切换到另一个任务之前是按顺序执行所有步骤，即使这些步骤涉及到等待。\n\n### 并发与汉堡\n\n上述异步代码的思想有时也被称为“并发”，它不同于“并行”。\n\n并发和并行都与“不同的事情或多或少同时发生”有关。\n\n但是并发和并行之间的细节是完全不同的。\n\n要了解差异，请想象以下关于汉堡的故事：\n\n### 并发汉堡\n\n你和你的恋人一起去快餐店，你排队在后面，收银员从你前面的人接单。😍\n\n然后轮到你了，你为你的恋人和你选了两个非常豪华的汉堡。🍔🍔\n\n收银员对厨房里的厨师说了一些话，让他们知道他们必须为你准备汉堡（尽管他们目前正在为之前的顾客准备汉堡）。\n\n你付钱了。 💸\n\n收银员给你轮到的号码。\n\n当你在等待的时候，你和你的恋人一起去挑选一张桌子，然后你们坐下来聊了很长时间（因为汉堡很豪华，需要一些时间来准备）。\n\n当你和你的恋人坐在桌子旁，等待汉堡的时候，你可以用这段时间来欣赏你的恋人是多么的棒、可爱和聪明✨😍✨。\n\n在等待中和你的恋人交谈时，你会不时地查看柜台上显示的号码，看看是否已经轮到你了。\n\n然后在某个时刻，终于轮到你了。你去柜台拿汉堡然后回到桌子上。\n\n你们享用了汉堡，整个过程都很开心。✨\n\n/// info\n\n漂亮的插画来自 Ketrina Thompson. 🎨\n\n///\n\n在那个故事里，假设你是计算机程序 🤖 。\n\n当你在排队时，你只是闲着😴， 轮到你前不做任何事情（仅排队）。但排队很快，因为收银员只接订单（不准备订单），所以这一切都还好。\n\n然后，当轮到你时，需要你做一些实际性的工作，比如查看菜单，决定你想要什么，让你的恋人选择，支付，检查你是否提供了正确的账单或卡，检查你的收费是否正确，检查订单是否有正确的项目，等等。\n\n此时，即使你仍然没有汉堡，你和收银员的工作也""暂停""了⏸， 因为你必须等待一段时间 🕙 让你的汉堡做好。\n\n但是，当你离开柜台并坐在桌子旁，在轮到你的号码前的这段时间，你可以将焦点切换到 🔀 你的恋人上，并做一些""工作""⏯ 🤓。你可以做一些非常""有成效""的事情，比如和你的恋人调情😍.\n\n之后，收银员 💁 把号码显示在显示屏上，并说到 ""汉堡做好了""，而当显示的号码是你的号码时，你不会立刻疯狂地跳起来。因为你知道没有人会偷你的汉堡，因为你有你的号码，而其他人又有他们自己的号码。\n\n所以你要等待你的恋人完成故事（完成当前的工作⏯ /正在做的事🤓)， 轻轻微笑，说你要吃汉堡⏸.\n\n然后你去柜台🔀， 到现在初始任务已经完成⏯， 拿起汉堡，说声谢谢，然后把它们送到桌上。这就完成了与计数器交互的步骤/任务⏹. 这反过来又产生了一项新任务，即""吃汉堡""🔀 ⏯， 上一个""拿汉堡""的任务已经结束了⏹.\n\n### 并行汉堡\n\n现在让我们假设不是""并发汉堡""，而是""并行汉堡""。\n\n你和你的恋人一起去吃并行快餐。\n\n你站在队伍中，同时是厨师的几个收银员（比方说8个）从前面的人那里接单。\n\n你之前的每个人都在等待他们的汉堡准备好后才离开柜台，因为8名收银员都会在下一份订单前马上准备好汉堡。\n\n然后，终于轮到你了，你为你的恋人和你订购了两个非常精美的汉堡。\n\n你付钱了 💸。\n\n收银员去厨房。\n\n你站在柜台前 🕙等待着，这样就不会有人在你之前抢走你的汉堡，因为没有轮流的号码。\n\n当你和你的恋人忙于不让任何人出现在你面前，并且在他们到来的时候拿走你的汉堡时，你无法关注到你的恋人。😞\n\n这是""同步""的工作，你被迫与服务员/厨师 👨\u200d🍳""同步""。你在此必须等待 🕙 ，在收银员/厨师 👨\u200d🍳 完成汉堡并将它们交给你的确切时间到达之前一直等待，否则其他人可能会拿走它们。\n\n你经过长时间的等待 🕙 ，收银员/厨师 👨\u200d🍳终于带着汉堡回到了柜台。\n\n你拿着汉堡，和你的情人一起上桌。\n\n你们仅仅是吃了它们，就结束了。⏹\n\n没有太多的交谈或调情，因为大部分时间 🕙 都在柜台前等待😞。\n\n/// info\n\n漂亮的插画来自 Ketrina Thompson. 🎨\n\n///\n\n在这个并行汉堡的场景中，你是一个计算机程序 🤖 且有两个处理器（你和你的恋人），都在等待 🕙 ，并投入他们的注意力 ⏯ 在柜台上等待了很长一段时间。\n\n这家快餐店有 8 个处理器（收银员/厨师）。而并发汉堡店可能只有 2 个（一个收银员和一个厨师）。\n\n但最终的体验仍然不是最好的。😞\n\n这将是与汉堡的类似故事。🍔\n\n一种更""贴近生活""的例子，想象一家银行。\n\n直到最近，大多数银行都有多个出纳员 👨\u200d💼👨\u200d💼👨\u200d💼👨\u200d💼 还有一条长长排队队伍🕙🕙🕙🕙🕙🕙🕙🕙。\n\n所有收银员都是一个接一个的在客户面前做完所有的工作👨\u200d💼⏯.\n\n你必须经过 🕙 较长时间排队，否则你就没机会了。\n\n你可不会想带你的恋人 😍 和你一起去银行办事🏦.\n\n### 汉堡结论\n\n在""你与恋人一起吃汉堡""的这个场景中，因为有很多人在等待🕙， 使用并发系统更有意义⏸🔀⏯.\n\n大多数 Web 应用都是这样的。\n\n你的服务器正在等待很多很多用户通过他们不太好的网络发送来的请求。\n\n然后再次等待 🕙 响应回来。\n\n这个""等待"" 🕙 是以微秒为单位测量的，但总的来说，最后还是等待很久。\n\n这就是为什么使用异步对于 Web API 很有意义的原因 ⏸🔀⏯。\n\n这种异步机制正是 NodeJS 受到欢迎的原因（尽管 NodeJS 不是并行的），以及 Go 作为编程语言的优势所在。\n\n这与 FastAPI 的性能水平相同。\n\n你可以同时拥有并行性和异步性，你可以获得比大多数经过测试的 NodeJS 框架更高的性能，并且与 Go 不相上下， Go 是一种更接近于 C 的编译语言（全部归功于 Starlette）。\n\n### 并发比并行好吗？\n\n不！这不是故事的本意。\n\n并发不同于并行。而是在需要大量等待的特定场景下效果更好。因此，在 Web 应用程序开发中，它通常比并行要好得多，但这并不意味着全部。\n\n因此，为了平衡这一点，想象一下下面的短篇故事：\n\n&gt; 你必须打扫一个又大又脏的房子。\n\n*是的，这就是完整的故事。*\n\n在任何地方， 都不需要等待 🕙 ，只需要在房子的多个地方做着很多工作。\n\n你可以像汉堡的例子那样轮流执行，先是客厅，然后是厨房，但因为你不需要等待 🕙 ，对于任何事情都是清洁，清洁，还是清洁，轮流不会影响任何事情。\n\n无论是否轮流执行（并发），都需要相同的时间来完成，而你也会完成相同的工作量。\n\n但在这种情况下，如果你能带上 8 名前收银员/厨师，现在是清洁工一起清扫，他们中的每一个人（加上你）都能占据房子的一个区域来清扫，你就可以在额外的帮助下并行的更快地完成所有工作。\n\n在这个场景中，每个清洁工（包括你）都将是一个处理器，完成这个工作的一部分。\n\n由于大多数执行时间是由实际工作（而不是等待）占用的，并且计算机中的工作是由 <abbr title=""Central Processing Unit"">CPU</abbr> 完成的，所以他们称这些问题为""CPU 密集型""。\n\nCPU 密集型操作的常见示例是需要复杂的数学处理。\n\n例如：\n\n* 音频或图像处理；\n* 计算机视觉: 一幅图像由数百万像素组成，每个像素有3种颜色值，处理通常需要同时对这些像素进行计算；\n* 机器学习: 它通常需要大量的""矩阵""和""向量""乘法。想象一个包含数字的巨大电子表格，并同时将所有数字相乘；\n* 深度学习: 这是机器学习的一个子领域，同样适用。只是没有一个数字的电子表格可以相乘，而是一个庞大的数字集合，在很多情况下，你需要使用一个特殊的处理器来构建和使用这些模型。\n\n### 并发 + 并行: Web + 机器学习\n\n使用 FastAPI，你可以利用 Web 开发中常见的并发机制的优势（NodeJS 的主要吸引力）。\n\n并且，你也可以利用并行和多进程（让多个进程并行运行）的优点来处理与机器学习系统中类似的 CPU 密集型 工作。\n\n这一点，再加上 Python 是数据科学、机器学习（尤其是深度学习）的主要语言这一简单事实，使得 FastAPI 与数据科学/机器学习 Web API 和应用程序（以及其他许多应用程序）非常匹配。\n\n了解如何在生产环境中实现这种并行性，可查看此文 [Deployment](deployment/index.md){.internal-link target=_blank}。\n\n## `async` 和 `await`\n\n现代版本的 Python 有一种非常直观的方式来定义异步代码。这使它看起来就像正常的""顺序""代码，并在适当的时候""等待""。\n\n当有一个操作需要等待才能给出结果，且支持这个新的 Python 特性时，你可以编写如下代码：\n\n```Python\nburgers = await get_burgers(2)\n```\n\n这里的关键是 `await`。它告诉 Python 它必须等待 ⏸ `get_burgers(2)` 完成它的工作 🕙 ，然后将结果存储在 `burgers` 中。这样，Python 就会知道此时它可以去做其他事情 🔀 ⏯ （比如接收另一个请求）。\n\n要使 `await` 工作，它必须位于支持这种异步机制的函数内。因此，只需使用 `async def` 声明它：\n\n```Python hl_lines=""1""\nasync def get_burgers(number: int):\n    # Do some asynchronous stuff to create the burgers\n    return burgers\n```\n\n...而不是 `def`:\n\n```Python hl_lines=""2""\n# This is not asynchronous\ndef get_sequential_burgers(number: int):\n    # Do some sequential stuff to create the burgers\n    return burgers\n```\n\n使用 `async def`，Python 就知道在该函数中，它将遇上 `await`，并且它可以""暂停"" ⏸ 执行该函数，直至执行其他操作 🔀 后回来。\n\n当你想调用一个 `async def` 函数时，你必须""等待""它。因此，这不会起作用：\n\n```Python\n# This won\'t work, because get_burgers was defined with: async def\nburgers = get_burgers(2)\n```\n\n因此，如果你使用的库告诉你可以使用 `await` 调用它，则需要使用 `async def` 创建路径操作函数 ，如：\n\n```Python hl_lines=""2-3""\n@app.get(\'/burgers\')\nasync def read_burgers():\n    burgers = await get_burgers(2)\n    return burgers\n```\n\n### 更多技术细节\n\n你可能已经注意到，`await` 只能在 `async def` 定义的函数内部使用。\n\n但与此同时，必须""等待""通过 `async def` 定义的函数。因此，带 `async def` 的函数也只能在 `async def` 定义的函数内部调用。\n\n那么，这关于先有鸡还是先有蛋的问题，如何调用第一个 `async` 函数？\n\n如果你使用 FastAPI，你不必担心这一点，因为""第一个""函数将是你的路径操作函数，FastAPI 将知道如何做正确的事情。\n\n但如果你想在没有 FastAPI 的情况下使用 `async` / `await`，则可以这样做。\n\n### 编写自己的异步代码\n\nStarlette （和 FastAPI） 是基于 AnyIO 实现的，这使得它们可以兼容 Python 的标准库 asyncio 和 Trio。\n\n特别是，你可以直接使用 AnyIO 来处理高级的并发用例，这些用例需要在自己的代码中使用更高级的模式。\n\n即使你没有使用 FastAPI，你也可以使用 AnyIO 编写自己的异步程序，使其拥有较高的兼容性并获得一些好处（例如， 结构化并发）。\n\n我（指原作者 —— 译者注）基于 AnyIO 新建了一个库，作为一个轻量级的封装层，用来优化类型注解，同时提供了更好的自动补全、内联错误提示等功能。这个库还附带了一个友好的入门指南和教程，能帮助你理解并编写自己的异步代码：Asyncer。如果你有结合使用异步代码和常规（阻塞/同步）代码的需求，这个库会特别有用。\n\n### 其他形式的异步代码\n\n这种使用 `async` 和 `await` 的风格在语言中相对较新。\n\n但它使处理异步代码变得容易很多。\n\n这种相同的语法（或几乎相同）最近也包含在现代版本的 JavaScript 中（在浏览器和 NodeJS 中）。\n\n但在此之前，处理异步代码非常复杂和困难。\n\n在以前版本的 Python，你可以使用多线程或者 Gevent。但代码的理解、调试和思考都要复杂许多。\n\n在以前版本的 NodeJS / 浏览器 JavaScript 中，你会使用""回调""，因此也可能导致“回调地狱”。\n\n## 协程\n\n协程只是 `async def` 函数返回的一个非常奇特的东西的称呼。Python 知道它有点像一个函数，它可以启动，也会在某个时刻结束，而且它可能会在内部暂停 ⏸ ，只要内部有一个 `await`。\n\n通过使用 `async` 和 `await` 的异步代码的所有功能大多数被概括为""协程""。它可以与 Go 的主要关键特性 ""Goroutines"" 相媲美。\n\n## 结论\n\n让我们再来回顾下上文所说的：\n\n&gt; Python 的现代版本可以通过使用 `async` 和 `await` 语法创建协程，并用于支持异步代码。\n\n现在应该能明白其含义了。✨\n\n所有这些使得 FastAPI（通过 Starlette）如此强大，也是它拥有如此令人印象深刻的性能的原因。\n\n## 非常技术性的细节\n\n/// warning\n\n你可以跳过这里。\n\n这些都是 FastAPI 如何在内部工作的技术细节。\n\n如果你有相当多的技术知识（协程、线程、阻塞等），并且对 FastAPI 如何处理 `async def` 与常规 `def` 感到好奇，请继续。\n\n///\n\n### 路径操作函数\n\n当你使用 `def` 而不是 `async def` 来声明一个*路径操作函数*时，它运行在外部的线程池中并等待其结果，而不是直接调用（因为它会阻塞服务器）。\n\n如果你使用过另一个不以上述方式工作的异步框架，并且你习惯于用普通的 `def` 定义普通的仅计算路径操作函数，以获得微小的性能增益（大约100纳秒），请注意，在 FastAPI 中，效果将完全相反。在这些情况下，最好使用 `async def`，除非路径操作函数内使用执行阻塞 <abbr title=""输入/输出：磁盘读写，网络通讯."">I/O</abbr> 的代码。\n\n在这两种情况下，与你之前的框架相比，FastAPI 可能[仍然很快](index.md#_11){.internal-link target=_blank}。\n\n### 依赖\n\n这同样适用于[依赖](tutorial/dependencies/index.md){.internal-link target=_blank}。如果一个依赖是标准的 `def` 函数而不是 `async def`，它将被运行在外部线程池中。\n\n### 子依赖\n\n你可以拥有多个相互依赖的依赖以及[子依赖](tutorial/dependencies/sub-dependencies.md){.internal-link target=_blank} （作为函数的参数），它们中的一些可能是通过 `async def` 声明，也可能是通过 `def` 声明。它们仍然可以正常工作，这些通过 `def` 声明的函数将会在外部线程中调用（来自线程池），而不是""被等待""。\n\n### 其他函数\n\n你可直接调用通过 `def` 或 `async def` 创建的任何其他函数，FastAPI 不会影响你调用它们的方式。\n\n这与 FastAPI 为你调用*路径操作函数*和依赖项的逻辑相反。\n\n如果你的函数是通过 `def` 声明的，它将被直接调用（在代码中编写的地方），而不会在线程池中，如果这个函数通过 `async def` 声明，当在代码中调用时，你就应该使用 `await` 等待函数的结果。\n\n再次提醒，这些是非常技术性的细节，如果你来搜索它可能对你有用。\n\n否则，你最好应该遵守的指导原则赶时间吗？.', '# 依赖项\n\nFastAPI 提供了简单易用，但功能强大的<abbr title=""也称为组件、资源、提供者、服务、可注入项"">依赖注入</abbr>系统。\n\n这个依赖系统设计的简单易用，可以让开发人员轻松地把组件集成至 FastAPI。\n\n## 什么是「依赖注入」\n\n编程中的「依赖注入」是声明代码（本文中为*路径操作函数* ）运行所需的，或要使用的「依赖」的一种方式。\n\n然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n\n依赖注入常用于以下场景：\n\n* 共享业务逻辑（复用相同的代码逻辑）\n* 共享数据库连接\n* 实现安全、验证、角色权限\n* 等……\n\n上述场景均可以使用依赖注入，将代码重复最小化。\n\n## 第一步\n\n接下来，我们学习一个非常简单的例子，尽管它过于简单，不是很实用。\n\n但通过这个例子，您可以初步了解「依赖注入」的工作机制。\n\n### 创建依赖项\n\n首先，要关注的是依赖项。\n\n依赖项就是一个函数，且可以使用与*路径操作函数*相同的参数：\n\n\n```py\nfrom typing import Annotated, Union\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(\n    q: Union[str, None] = None, skip: int = 0, limit: int = 100\n):\n    return {""q"": q, ""skip"": skip, ""limit"": limit}\n\n\n@app.get(""/items/"")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n\n@app.get(""/users/"")\nasync def read_users(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n```\n\n\n大功告成。\n\n只用了2 行代码。\n\n依赖项函数的形式和结构与*路径操作函数*一样。\n\n因此，可以把依赖项当作没有「装饰器」（即，没有 `@app.get(""/some-path"")` ）的路径操作函数。\n\n依赖项可以返回各种内容。\n\n本例中的依赖项预期接收如下参数：\n\n* 类型为 `str` 的可选查询参数 `q`\n* 类型为 `int` 的可选查询参数 `skip`，默认值是 `0`\n* 类型为 `int` 的可选查询参数 `limit`，默认值是 `100`\n\n然后，依赖项函数返回包含这些值的 `dict`。\n\n### 导入 `Depends`\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n### 声明依赖项\n\n与在*路径操作函数*参数中使用 `Body`、`Query` 的方式相同，声明依赖项需要使用 `Depends` 和一个新的参数：\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n虽然，在路径操作函数的参数中使用 `Depends` 的方式与 `Body`、`Query` 相同，但 `Depends` 的工作方式略有不同。\n\n这里只能传给 Depends 一个参数。\n\n且该参数必须是可调用对象，比如函数。\n\n该函数接收的参数和*路径操作函数*的参数一样。\n\n/// tip | 提示\n\n下一章介绍，除了函数还有哪些「对象」可以用作依赖项。\n\n///\n\n接收到新的请求时，FastAPI 执行如下操作：\n\n* 用正确的参数调用依赖项函数（「可依赖项」）\n* 获取函数返回的结果\n* 把函数返回的结果赋值给*路径操作函数*的参数\n\n```mermaid\ngraph TB\n\ncommon_parameters([""common_parameters""])\nread_items[""/items/""]\nread_users[""/users/""]\n\ncommon_parameters --&gt; read_items\ncommon_parameters --&gt; read_users\n```\n\n这样，只编写一次代码，FastAPI 就可以为多个*路径操作*共享这段代码 。\n\n/// check | 检查\n\n注意，无需创建专门的类，并将之传递给 FastAPI 以进行「注册」或执行类似的操作。\n\n只要把它传递给 `Depends`，FastAPI 就知道该如何执行后续操作。\n\n///\n\n## 要不要使用 `async`？\n\nFastAPI 调用依赖项的方式与*路径操作函数*一样，因此，定义依赖项函数，也要应用与路径操作函数相同的规则。\n\n即，既可以使用异步的 `async def`，也可以使用普通的 `def` 定义依赖项。\n\n在普通的 `def` *路径操作函数*中，可以声明异步的 `async def` 依赖项；也可以在异步的 `async def` *路径操作函数*中声明普通的 `def` 依赖项。\n\n上述这些操作都是可行的，FastAPI 知道该怎么处理。\n\n/// note | 笔记\n\n如里不了解异步，请参阅[异步：*“着急了？”*](../../async.md){.internal-link target=_blank} 一章中 `async` 和 `await` 的内容。\n\n///\n\n## 与 OpenAPI 集成\n\n依赖项及子依赖项的所有请求声明、验证和需求都可以集成至同一个 OpenAPI 概图。\n\n所以，交互文档里也会显示依赖项的所有信息：\n\n## 简单用法\n\n观察一下就会发现，只要*路径* 和*操作*匹配，就可以使用声明的路径操作函数。然后，FastAPI 会用正确的参数调用函数，并提取请求中的数据。\n\n实际上，所有（或大多数）网络框架的工作方式都是这样的。\n\n开发人员永远都不需要直接调用这些函数，这些函数是由框架（在此为 FastAPI ）调用的。\n\n通过依赖注入系统，只要告诉 FastAPI *路径操作函数* 还要「依赖」其他在*路径操作函数*之前执行的内容，FastAPI 就会执行函数代码，并「注入」函数返回的结果。\n\n其他与「依赖注入」概念相同的术语为：\n\n* 资源（Resource）\n* 提供方（Provider）\n* 服务（Service）\n* 可注入（Injectable）\n* 组件（Component）\n\n## FastAPI 插件\n\n依赖注入系统支持构建集成和「插件」。但实际上，FastAPI 根本不需要创建「插件」，因为使用依赖项可以声明不限数量的、可用于*路径操作函数*的集成与交互。\n\n创建依赖项非常简单、直观，并且还支持导入 Python 包。毫不夸张地说，只要几行代码就可以把需要的 Python 包与 API 函数集成在一起。\n\n下一章将详细介绍在关系型数据库、NoSQL 数据库、安全等方面使用依赖项的例子。\n\n## FastAPI 兼容性\n\n依赖注入系统如此简洁的特性，让 FastAPI 可以与下列系统兼容：\n\n* 关系型数据库\n* NoSQL 数据库\n* 外部支持库\n* 外部 API\n* 认证和鉴权系统\n* API 使用监控系统\n* 响应数据注入系统\n* 等等……\n\n## 简单而强大\n\n虽然，层级式依赖注入系统的定义与使用十分简单，但它却非常强大。\n\n比如，可以定义依赖其他依赖项的依赖项。\n\n最后，依赖项层级树构建后，依赖注入系统会处理所有依赖项及其子依赖项，并为每一步操作提供（注入）结果。\n\n比如，下面有 4 个 API 路径操作（*端点*）：\n\n* `/items/public/`\n* `/items/private/`\n* `/users/{user_id}/activate`\n* `/items/pro/`\n\n开发人员可以使用依赖项及其子依赖项为这些路径操作添加不同的权限：\n\n```mermaid\ngraph TB\n\ncurrent_user([""current_user""])\nactive_user([""active_user""])\nadmin_user([""admin_user""])\npaying_user([""paying_user""])\n\npublic[""/items/public/""]\nprivate[""/items/private/""]\nactivate_user[""/users/{user_id}/activate""]\npro_items[""/items/pro/""]\n\ncurrent_user --&gt; active_user\nactive_user --&gt; admin_user\nactive_user --&gt; paying_user\n\ncurrent_user --&gt; public\nactive_user --&gt; private\nadmin_user --&gt; activate_user\npaying_user --&gt; pro_items\n```\n\n## 与 OpenAPI 集成\n\n在声明需求时，所有这些依赖项还会把参数、验证等功能添加至路径操作。\n\nFastAPI 负责把上述内容全部添加到 OpenAPI 概图，并显示在交互文档中。']",在 FastAPI 中，`async def`用于异步处理I/O密集型操作（如网络请求、数据库查询），需配合`await`调用支持异步的库；普通`def`适用于同步操作或调用不支持`await`的同步库。若操作涉及等待外部响应（如API调用、文件读写）则用`async def`，否则用`def`。不确定时优先使用`def`。, 在 FastAPI 中，如果你使用 async def 定义路由，FastAPI 会直接在主线程的异步事件循环中调用它；如果你使用普通 def 定义路由，FastAPI 会在一个独立的外部线程池中运行它，以防止阻塞主事件循环。使用建议：如果你使用的第三方库支持 await（如异步数据库驱动），请使用 async def；如果你必须使用同步/阻塞的 IO 操作（如 requests 库或同步数据库连接），请使用普通 def。误在 async def 中调用阻塞代码会直接拖慢整个应用的并发能力。,0.9999999999,0.7777777777777778,0.8494604082612515
FastAPI 官方推荐的 OAuth2 密码流（Password flow）实现步骤是什么？,"['# 安全 - 第一步\n\n假设后端 API 在某个域。\n\n前端在另一个域，或（移动应用中）在同一个域的不同路径下。\n\n并且，前端要使用后端的 username 与 password 验证用户身份。\n\n固然，FastAPI 支持 OAuth2 身份验证。\n\n但为了节省开发者的时间，不要只为了查找很少的内容，不得不阅读冗长的规范文档。\n\n我们建议使用 FastAPI 的安全工具。\n\n## 概览\n\n首先，看看下面的代码是怎么运行的，然后再回过头来了解其背后的原理。\n\n## 创建 `main.py`\n\n把下面的示例代码复制到 `main.py`：\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2PasswordBearer\n\napp = FastAPI()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=""token"")\n\n\n@app.get(""/items/"")\nasync def read_items(token: Annotated[str, Depends(oauth2_scheme)]):\n    return {""token"": token}\n\n```\n\n\n## 运行\n\n/// info | 说明\n\n先安装 `python-multipart`。\n\n安装命令： `pip install python-multipart`。\n\n这是因为 OAuth2 使用表单数据发送 `username` 与 `password`。\n\n///\n\n用下面的命令运行该示例：\n\n```console\n$ uvicorn main:app --reload\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n## 查看文档\n\n打开 API 文档： http://127.0.0.1:8000/docs。\n\n界面如下图所示：\n\n/// check | Authorize 按钮！\n\n页面右上角出现了一个「Authorize」按钮。\n\n*路径操作*的右上角也出现了一个可以点击的小锁图标。\n\n///\n\n点击 Authorize 按钮，弹出授权表单，输入 `username` 与 `password` 及其它可选字段：\n\n/// note | 笔记\n\n目前，在表单中输入内容不会有任何反应，后文会介绍相关内容。\n\n///\n\n虽然此文档不是给前端最终用户使用的，但这个自动工具非常实用，可在文档中与所有 API 交互。\n\n前端团队（可能就是开发者本人）可以使用本工具。\n\n第三方应用与系统也可以调用本工具。\n\n开发者也可以用它来调试、检查、测试应用。\n\n## 密码流\n\n现在，我们回过头来介绍这段代码的原理。\n\n`Password` 流是 OAuth2 定义的，用于处理安全与身份验证的方式（流）。\n\nOAuth2 的设计目标是为了让后端或 API 独立于服务器验证用户身份。\n\n但在本例中，FastAPI 应用会处理 API 与身份验证。\n\n下面，我们来看一下简化的运行流程：\n\n- 用户在前端输入 `username` 与`password`，并点击回车\n- （用户浏览器中运行的）前端把 `username` 与`password` 发送至 API 中指定的 URL（使用 `tokenUrl=""token""` 声明）\n- API 检查 `username` 与`password`，并用令牌（`Token`） 响应（暂未实现此功能）：\n  - 令牌只是用于验证用户的字符串\n  - 一般来说，令牌会在一段时间后过期\n    - 过时后，用户要再次登录\n    - 这样一来，就算令牌被人窃取，风险也较低。因为它与永久密钥不同，在绝大多数情况下不会长期有效\n- 前端临时将令牌存储在某个位置\n- 用户点击前端，前往前端应用的其它部件\n- 前端需要从 API 中提取更多数据：\n    - 为指定的端点（Endpoint）进行身份验证\n    - 因此，用 API 验证身份时，要发送值为 `Bearer` + 令牌的请求头 `Authorization`\n    - 假如令牌为 `foobar`，`Authorization` 请求头就是： `Bearer foobar`\n\n## FastAPI 的 `OAuth2PasswordBearer`\n\nFastAPI 提供了不同抽象级别的安全工具。\n\n本例使用 OAuth2 的 Password 流以及 Bearer 令牌（`Token`）。为此要使用 `OAuth2PasswordBearer` 类。\n\n/// info | 说明\n\n`Bearer` 令牌不是唯一的选择。\n\n但它是最适合这个用例的方案。\n\n甚至可以说，它是适用于绝大多数用例的最佳方案，除非您是 OAuth2 的专家，知道为什么其它方案更合适。\n\n本例中，FastAPI 还提供了构建工具。\n\n///\n\n创建 `OAuth2PasswordBearer` 的类实例时，要传递 `tokenUrl` 参数。该参数包含客户端（用户浏览器中运行的前端） 的 URL，用于发送 `username` 与 `password`，并获取令牌。\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n/// tip | 提示\n\n在此，`tokenUrl=""token""` 指向的是暂未创建的相对 URL `token`。这个相对 URL 相当于 `./token`。\n\n因为使用的是相对 URL，如果 API 位于 `https://example.com/`，则指向 `https://example.com/token`。但如果 API 位于 `https://example.com/api/v1/`，它指向的就是`https://example.com/api/v1/token`。\n\n使用相对 URL 非常重要，可以确保应用在遇到[使用代理](../../advanced/behind-a-proxy.md){.internal-link target=_blank}这样的高级用例时，也能正常运行。\n\n///\n\n该参数不会创建端点或*路径操作*，但会声明客户端用来获取令牌的 URL `/token` 。此信息用于 OpenAPI 及 API 文档。\n\n接下来，学习如何创建实际的路径操作。\n\n/// info | 说明\n\n严苛的 Pythonista 可能不喜欢用 `tokenUrl` 这种命名风格代替 `token_url`。\n\n这种命名方式是因为要使用与 OpenAPI 规范中相同的名字。以便在深入校验安全方案时，能通过复制粘贴查找更多相关信息。\n\n///\n\n`oauth2_scheme` 变量是 `OAuth2PasswordBearer` 的实例，也是可调用项。\n\n以如下方式调用：\n\n```Python\noauth2_scheme(some, parameters)\n```\n\n因此，`Depends` 可以调用 `oauth2_scheme` 变量。\n\n### 使用\n\n接下来，使用 `Depends` 把 `oauth2_scheme` 传入依赖项。\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n该依赖项使用字符串（`str`）接收*路径操作函数*的参数 `token` 。\n\nFastAPI 使用依赖项在 OpenAPI 概图（及 API 文档）中定义安全方案。\n\n/// info | 技术细节\n\nFastAPI 使用（在依赖项中声明的）类 `OAuth2PasswordBearer` 在 OpenAPI 中定义安全方案，这是因为它继承自 `fastapi.security.oauth2.OAuth2`，而该类又是继承自`fastapi.security.base.SecurityBase`。\n\n所有与 OpenAPI（及 API 文档）集成的安全工具都继承自 `SecurityBase`， 这就是为什么 FastAPI 能把它们集成至 OpenAPI 的原因。\n\n///\n\n## 实现的操作\n\nFastAPI 校验请求中的 `Authorization` 请求头，核对请求头的值是不是由 `Bearer ` ＋ 令牌组成， 并返回令牌字符串（`str`）。\n\n如果没有找到 `Authorization` 请求头，或请求头的值不是 `Bearer ` ＋ 令牌。FastAPI 直接返回 401 错误状态码（`UNAUTHORIZED`）。\n\n开发者不需要检查错误信息，查看令牌是否存在，只要该函数能够执行，函数中就会包含令牌字符串。\n\n正如下图所示，API 文档已经包含了这项功能：\n\n目前，暂时还没有实现验证令牌是否有效的功能，不过后文很快就会介绍的。\n\n## 小结\n\n看到了吧，只要多写三四行代码，就可以添加基础的安全表单。', '# OAuth2 作用域\n\nFastAPI 无缝集成 OAuth2 作用域（`Scopes`），可以直接使用。\n\n作用域是更精密的权限系统，遵循 OAuth2 标准，与 OpenAPI 应用（和 API 自动文档）集成。\n\nOAuth2 也是脸书、谷歌、GitHub、微软、推特等第三方身份验证应用使用的机制。这些身份验证应用在用户登录应用时使用 OAuth2 提供指定权限。\n\n脸书、谷歌、GitHub、微软、推特就是 OAuth2 作用域登录。\n\n本章介绍如何在 FastAPI 应用中使用 OAuth2 作用域管理验证与授权。\n\n/// warning | 警告\n\n本章内容较难，刚接触 FastAPI 的新手可以跳过。\n\nOAuth2 作用域不是必需的，没有它，您也可以处理身份验证与授权。\n\n但 OAuth2 作用域与 API（通过 OpenAPI）及 API 文档集成地更好。\n\n不管怎么说，FastAPI 支持在代码中使用作用域或其它安全/授权需求项。\n\n很多情况下，OAuth2 作用域就像一把牛刀。\n\n但如果您确定要使用作用域，或对它有兴趣，请继续阅读。\n\n///\n\n## OAuth2 作用域与 OpenAPI\n\nOAuth2 规范的作用域是由空格分割的字符串组成的列表。\n\n这些字符串支持任何格式，但不能包含空格。\n\n作用域表示的是权限。\n\nOpenAPI 中（例如 API 文档）可以定义安全方案。\n\n这些安全方案在使用 OAuth2 时，还可以声明和使用作用域。\n\n作用域只是（不带空格的）字符串。\n\n常用于声明特定安全权限，例如：\n\n* 常见用例为，`users:read` 或 `users:write`\n* 脸书和 Instagram 使用 `instagram_basic`\n* 谷歌使用 `https://www.googleapis.com/auth/drive`\n\n/// info | 说明\n\nOAuth2 中，作用域只是声明特定权限的字符串。\n\n是否使用冒号 `:` 等符号，或是不是 URL 并不重要。\n\n这些细节只是特定的实现方式。\n\n对 OAuth2 来说，它们都只是字符串而已。\n\n///\n\n## 全局纵览\n\n首先，快速浏览一下以下代码与用户指南中 [OAuth2 实现密码哈希与 Bearer  JWT 令牌验证](../../tutorial/security/oauth2-jwt.md){.internal-link target=_blank}一章中代码的区别。以下代码使用 OAuth2 作用域：\n\n\n```py\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Annotated, Union\n\nimport jwt\nfrom fastapi import Depends, FastAPI, HTTPException, Security, status\nfrom fastapi.security import (\n    OAuth2PasswordBearer,\n    OAuth2PasswordRequestForm,\n    SecurityScopes,\n)\nfrom jwt.exceptions import InvalidTokenError\nfrom pwdlib import PasswordHash\nfrom pydantic import BaseModel, ValidationError\n\n# to get a string like this run:\n# openssl rand -hex 32\nSECRET_KEY = ""09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7""\nALGORITHM = ""HS256""\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n\nfake_users_db = {\n    ""johndoe"": {\n        ""username"": ""johndoe"",\n        ""full_name"": ""John Doe"",\n        ""email"": ""johndoe@example.com"",\n        ""hashed_password"": ""$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc"",\n        ""disabled"": False,\n    },\n    ""alice"": {\n        ""username"": ""alice"",\n        ""full_name"": ""Alice Chains"",\n        ""email"": ""alicechains@example.com"",\n        ""hashed_password"": ""$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE"",\n        ""disabled"": True,\n    },\n}\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: Union[str, None] = None\n    scopes: list[str] = []\n\n\nclass User(BaseModel):\n    username: str\n    email: Union[str, None] = None\n    full_name: Union[str, None] = None\n    disabled: Union[bool, None] = None\n\n\nclass UserInDB(User):\n    hashed_password: str\n\n\npassword_hash = PasswordHash.recommended()\n\noauth2_scheme = OAuth2PasswordBearer(\n    tokenUrl=""token"",\n    scopes={""me"": ""Read information about the current user."", ""items"": ""Read items.""},\n)\n\napp = FastAPI()\n\n\ndef verify_password(plain_password, hashed_password):\n    return password_hash.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password):\n    return password_hash.hash(password)\n\n\ndef get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)\n\n\ndef authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user\n\n\ndef create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(timezone.utc) + expires_delta\n    else:\n        expire = datetime.now(timezone.utc) + timedelta(minutes=15)\n    to_encode.update({""exp"": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\nasync def get_current_user(\n    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]\n):\n    if security_scopes.scopes:\n        authenticate_value = f\'Bearer scope=""{security_scopes.scope_str}""\'\n    else:\n        authenticate_value = ""Bearer""\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=""Could not validate credentials"",\n        headers={""WWW-Authenticate"": authenticate_value},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username = payload.get(""sub"")\n        if username is None:\n            raise credentials_exception\n        scope: str = payload.get(""scope"", """")\n        token_scopes = scope.split("" "")\n        token_data = TokenData(scopes=token_scopes, username=username)\n    except (InvalidTokenError, ValidationError):\n        raise credentials_exception\n    user = get_user(fake_users_db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    for scope in security_scopes.scopes:\n        if scope not in token_data.scopes:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=""Not enough permissions"",\n                headers={""WWW-Authenticate"": authenticate_value},\n            )\n    return user\n\n\nasync def get_current_active_user(\n    current_user: Annotated[User, Security(get_current_user, scopes=[""me""])],\n):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=""Inactive user"")\n    return current_user\n\n\n@app.post(""/token"")\nasync def login_for_access_token(\n    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],\n) -> Token:\n    user = authenticate_user(fake_users_db, form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(status_code=400, detail=""Incorrect username or password"")\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={""sub"": user.username, ""scope"": "" "".join(form_data.scopes)},\n        expires_delta=access_token_expires,\n    )\n    return Token(access_token=access_token, token_type=""bearer"")\n\n\n@app.get(""/users/me/"", response_model=User)\nasync def read_users_me(\n    current_user: Annotated[User, Depends(get_current_active_user)],\n):\n    return current_user\n\n\n@app.get(""/users/me/items/"")\nasync def read_own_items(\n    current_user: Annotated[User, Security(get_current_active_user, scopes=[""items""])],\n):\n    return [{""item_id"": ""Foo"", ""owner"": current_user.username}]\n\n\n@app.get(""/status/"")\nasync def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):\n    return {""status"": ""ok""}\n\n```\n\n\n下面，我们逐步说明修改的代码内容。\n\n## OAuth2 安全方案\n\n第一个修改的地方是，使用两个作用域 `me` 和 `items ` 声明 OAuth2 安全方案。\n\n`scopes` 参数接收字典，键是作用域、值是作用域的描述：\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n因为声明了作用域，所以登录或授权时会在 API 文档中显示。\n\n此处，选择给予访问权限的作用域： `me` 和 `items`。\n\n这也是使用脸书、谷歌、GitHub 登录时的授权机制。\n\n## JWT 令牌作用域\n\n现在，修改令牌*路径操作*，返回请求的作用域。\n\n此处仍然使用 `OAuth2PasswordRequestForm`。它包含类型为字符串列表的 `scopes` 属性，且`scopes` 属性中包含要在请求里接收的每个作用域。\n\n这样，返回的 JWT 令牌中就包含了作用域。\n\n/// danger | 危险\n\n为了简明起见，本例把接收的作用域直接添加到了令牌里。\n\n但在您的应用中，为了安全，应该只把作用域添加到确实需要作用域的用户，或预定义的用户。\n\n///\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 在*路径操作*与依赖项中声明作用域\n\n接下来，为*路径操作*  `/users/me/items/` 声明作用域 `items`。\n\n为此，要从 `fastapi` 中导入并使用 `Security` 。\n\n`Security` 声明依赖项的方式和 `Depends` 一样，但 `Security` 还能接收作用域（字符串）列表类型的参数 `scopes`。\n\n此处使用与 `Depends` 相同的方式，把依赖项函数 `get_current_active_user` 传递给 `Security`。\n\n同时，还传递了作用域列表，本例中只传递了一个作用域：`items`（此处支持传递更多作用域）。\n\n依赖项函数 `get_current_active_user` 还能声明子依赖项，不仅可以使用 `Depends`，也可以使用 `Security`。声明子依赖项函数（`get_current_user`）及更多作用域。\n\n本例要求使用作用域 `me`（还可以使用更多作用域）。\n\n/// note | 笔记\n\n不必在不同位置添加不同的作用域。\n\n本例使用的这种方式只是为了展示 FastAPI 如何处理在不同层级声明的作用域。\n\n///\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n/// info | 技术细节\n\n`Security` 实际上是 `Depends` 的子类，而且只比 `Depends` 多一个参数。\n\n但使用 `Security` 代替 `Depends`，FastAPI 可以声明安全作用域，并在内部使用这些作用域，同时，使用 OpenAPI 存档 API。\n\n但实际上，从 `fastapi` 导入的 `Query`、`Path`、`Depends`、`Security` 等对象，只是返回特殊类的函数。\n\n///\n\n## 使用 `SecurityScopes`\n\n修改依赖项 `get_current_user`。\n\n这是上面的依赖项使用的依赖项。\n\n这里使用的也是之前创建的 OAuth2 方案，并把它声明为依赖项：`oauth2_scheme`。\n\n该依赖项函数本身不需要作用域，因此，可以使用 `Depends` 和 `oauth2_scheme`。不需要指定安全作用域时，不必使用 `Security`。\n\n此处还声明了从 `fastapi.security` 导入的 `SecurityScopes` 类型的特殊参数。\n\n`SecuriScopes` 类与 `Request` 类似（`Request` 用于直接提取请求对象）。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 使用 `scopes`\n\n参数 `security_scopes` 的类型是 `SecurityScopes`。\n\n它的属性 `scopes`  是作用域列表，所有依赖项都把它作为子依赖项。也就是说所有依赖……这听起来有些绕，后文会有解释。\n\n（类 `SecurityScopes` 的）`security_scopes` 对象还提供了单字符串类型的属性 `scope_str`，该属性是（要在本例中使用的）用空格分割的作用域。\n\n此处还创建了后续代码中要复用（`raise`）的 `HTTPException` 。\n\n该异常包含了作用域所需的（如有），以空格分割的字符串（使用 `scope_str`）。该字符串要放到包含作用域的 `WWW-Authenticate` 请求头中（这也是规范的要求）。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 校验 `username` 与数据形状\n\n我们可以校验是否获取了 `username`，并抽取作用域。\n\n然后，使用 Pydantic 模型校验数据（捕获 `ValidationError` 异常），如果读取 JWT 令牌或使用 Pydantic 模型验证数据时出错，就会触发之前创建的 `HTTPException` 异常。\n\n对此，要使用新的属性 `scopes` 更新 Pydantic 模型 `TokenData`。\n\n使用 Pydantic 验证数据可以确保数据中含有由作用域组成的字符串列表，以及 `username` 字符串等内容。\n\n反之，如果使用字典或其它数据结构，就有可能在后面某些位置破坏应用，形成安全隐患。\n\n还可以使用用户名验证用户，如果没有用户，也会触发之前创建的异常。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 校验 `scopes`\n\n接下来，校验所有依赖项和依赖要素（包括*路径操作*）所需的作用域。这些作用域包含在令牌的 `scopes` 里，如果不在其中就会触发 `HTTPException` 异常。\n\n为此，要使用包含所有作用域字符串列表的 `security_scopes.scopes`， 。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 依赖项树与作用域\n\n再次查看这个依赖项树与作用域。\n\n`get_current_active_user` 依赖项包含子依赖项 `get_current_user`，并在 `get_current_active_user`中声明了作用域 `""me""` 包含所需作用域列表 ，在 `security_scopes.scopes` 中传递给 `get_current_user`。\n\n*路径操作*自身也声明了作用域，`""items""`，这也是 `security_scopes.scopes` 列表传递给 `get_current_user` 的。\n\n依赖项与作用域的层级架构如下：\n\n* *路径操作* `read_own_items` 包含：\n    * 依赖项所需的作用域 `[""items""]`：\n    * `get_current_active_user`:\n        *  依赖项函数 `get_current_active_user` 包含：\n            * 所需的作用域 `""me""` 包含依赖项：\n            * `get_current_user`:\n                * 依赖项函数 `get_current_user` 包含：\n                    * 没有作用域需求其自身\n                    * 依赖项使用 `oauth2_scheme`\n                    * `security_scopes` 参数的类型是 `SecurityScopes`：\n                        * `security_scopes` 参数的属性 `scopes` 是包含上述声明的所有作用域的列表，因此：\n                            * `security_scopes.scopes` 包含用于*路径操作*的 `[""me"", ""items""]`\n                            * `security_scopes.scopes` 包含*路径操作* `read_users_me` 的 `[""me""]`，因为它在依赖项里被声明\n                            * `security_scopes.scopes` 包含用于*路径操作* `read_system_status` 的 `[]`（空列表），并且它的依赖项 `get_current_user` 也没有声明任何 `scope`\n\n/// tip | 提示\n\n此处重要且神奇的事情是，`get_current_user` 检查每个*路径操作*时可以使用不同的 `scopes` 列表。\n\n所有这些都依赖于在每个*路径操作*和指定*路径操作*的依赖树中的每个依赖项。\n\n///\n\n## `SecurityScopes` 的更多细节\n\n您可以任何位置或多个位置使用 `SecurityScopes`，不一定非得在根依赖项中使用。\n\n它总是在当前 `Security` 依赖项中和所有依赖因子对于特定 *路径操作*和特定依赖树中安全作用域\n\n因为 `SecurityScopes` 包含所有由依赖项声明的作用域，可以在核心依赖函数中用它验证所需作用域的令牌，然后再在不同的*路径操作*中声明不同作用域需求。\n\n它们会为每个*路径操作*进行单独检查。\n\n## 查看文档\n\n打开 API 文档，进行身份验证，并指定要授权的作用域。\n\n没有选择任何作用域，也可以进行身份验证，但访问 `/uses/me` 或 `/users/me/items` 时，会显示没有足够的权限。但仍可以访问 `/status/`。\n\n如果选择了作用域 `me`，但没有选择作用域 `items`，则可以访问 `/users/me/`，但不能访问 `/users/me/items`。\n\n这就是通过用户提供的令牌使用第三方应用访问这些*路径操作*时会发生的情况，具体怎样取决于用户授予第三方应用的权限。\n\n## 关于第三方集成\n\n本例使用 OAuth2 密码流。\n\n这种方式适用于登录我们自己的应用，最好使用我们自己的前端。\n\n因为我们能控制自己的前端应用，可以信任它接收 `username` 与 `password`。\n\n但如果构建的是连接其它应用的 OAuth2 应用，比如具有与脸书、谷歌、GitHub 相同功能的第三方身份验证应用。那您就应该使用其它安全流。\n\n最常用的是隐式流。\n\n最安全的是代码流，但实现起来更复杂，而且需要更多步骤。因为它更复杂，很多第三方身份验证应用最终建议使用隐式流。\n\n/// note | 笔记\n\n每个身份验证应用都会采用不同方式会命名流，以便融合入自己的品牌。\n\n但归根结底，它们使用的都是 OAuth2 标准。\n\n///\n\nFastAPI 的 `fastapi.security.oauth2` 里包含了所有 OAuth2 身份验证流工具。\n\n## 装饰器 `dependencies` 中的 `Security`\n\n同样，您可以在装饰器的 `dependencies` 参数中定义 `Depends` 列表，（详见[路径操作装饰器依赖项](../../tutorial/dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank})），也可以把 `scopes` 与 `Security` 一起使用。']","根据上下文，FastAPI官方推荐的OAuth2密码流实现步骤如下：
1. 创建 `OAuth2PasswordBearer` 实例，指定 `tokenUrl` 参数（如 `tokenUrl=""token""`），用于声明客户端获取令牌的URL。
2. 在路径操作中使用 `Depends(oauth2_scheme)` 依赖项，自动校验请求头中的Bearer令牌格式。
3. 实现 `/token` 端点，接收表单数据（`username`和`password`），验证用户身份后生成并返回访问令牌。

（具体代码实现需参考上下文中完整的安全工具和令牌生成逻辑。）",FastAPI 官方推荐的实现步骤如下：1. 创建一个 OAuth2PasswordBearer 实例，并指定 tokenUrl（获取 Token 的端点）；2. 定义一个 Pydantic 模型作为 Token 的响应格式（包含 access_token 和 token_type）；3. 编写一个登录路由，接收 OAuth2PasswordRequestForm，验证用户名密码后生成并返回 JWT；4. 创建一个 get_current_user 依赖项，通过 Depends(oauth2_scheme) 获取 Token，解码并验证用户身份；5. 在需要授权的路径操作中使用该依赖项。,0.99999999995,1.0,0.886210412824767
如何使用 Security 处理具有不同权限作用域（Scopes）的依赖项？,"['# OAuth2 作用域\n\nFastAPI 无缝集成 OAuth2 作用域（`Scopes`），可以直接使用。\n\n作用域是更精密的权限系统，遵循 OAuth2 标准，与 OpenAPI 应用（和 API 自动文档）集成。\n\nOAuth2 也是脸书、谷歌、GitHub、微软、推特等第三方身份验证应用使用的机制。这些身份验证应用在用户登录应用时使用 OAuth2 提供指定权限。\n\n脸书、谷歌、GitHub、微软、推特就是 OAuth2 作用域登录。\n\n本章介绍如何在 FastAPI 应用中使用 OAuth2 作用域管理验证与授权。\n\n/// warning | 警告\n\n本章内容较难，刚接触 FastAPI 的新手可以跳过。\n\nOAuth2 作用域不是必需的，没有它，您也可以处理身份验证与授权。\n\n但 OAuth2 作用域与 API（通过 OpenAPI）及 API 文档集成地更好。\n\n不管怎么说，FastAPI 支持在代码中使用作用域或其它安全/授权需求项。\n\n很多情况下，OAuth2 作用域就像一把牛刀。\n\n但如果您确定要使用作用域，或对它有兴趣，请继续阅读。\n\n///\n\n## OAuth2 作用域与 OpenAPI\n\nOAuth2 规范的作用域是由空格分割的字符串组成的列表。\n\n这些字符串支持任何格式，但不能包含空格。\n\n作用域表示的是权限。\n\nOpenAPI 中（例如 API 文档）可以定义安全方案。\n\n这些安全方案在使用 OAuth2 时，还可以声明和使用作用域。\n\n作用域只是（不带空格的）字符串。\n\n常用于声明特定安全权限，例如：\n\n* 常见用例为，`users:read` 或 `users:write`\n* 脸书和 Instagram 使用 `instagram_basic`\n* 谷歌使用 `https://www.googleapis.com/auth/drive`\n\n/// info | 说明\n\nOAuth2 中，作用域只是声明特定权限的字符串。\n\n是否使用冒号 `:` 等符号，或是不是 URL 并不重要。\n\n这些细节只是特定的实现方式。\n\n对 OAuth2 来说，它们都只是字符串而已。\n\n///\n\n## 全局纵览\n\n首先，快速浏览一下以下代码与用户指南中 [OAuth2 实现密码哈希与 Bearer  JWT 令牌验证](../../tutorial/security/oauth2-jwt.md){.internal-link target=_blank}一章中代码的区别。以下代码使用 OAuth2 作用域：\n\n\n```py\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Annotated, Union\n\nimport jwt\nfrom fastapi import Depends, FastAPI, HTTPException, Security, status\nfrom fastapi.security import (\n    OAuth2PasswordBearer,\n    OAuth2PasswordRequestForm,\n    SecurityScopes,\n)\nfrom jwt.exceptions import InvalidTokenError\nfrom pwdlib import PasswordHash\nfrom pydantic import BaseModel, ValidationError\n\n# to get a string like this run:\n# openssl rand -hex 32\nSECRET_KEY = ""09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7""\nALGORITHM = ""HS256""\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n\nfake_users_db = {\n    ""johndoe"": {\n        ""username"": ""johndoe"",\n        ""full_name"": ""John Doe"",\n        ""email"": ""johndoe@example.com"",\n        ""hashed_password"": ""$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc"",\n        ""disabled"": False,\n    },\n    ""alice"": {\n        ""username"": ""alice"",\n        ""full_name"": ""Alice Chains"",\n        ""email"": ""alicechains@example.com"",\n        ""hashed_password"": ""$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE"",\n        ""disabled"": True,\n    },\n}\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: Union[str, None] = None\n    scopes: list[str] = []\n\n\nclass User(BaseModel):\n    username: str\n    email: Union[str, None] = None\n    full_name: Union[str, None] = None\n    disabled: Union[bool, None] = None\n\n\nclass UserInDB(User):\n    hashed_password: str\n\n\npassword_hash = PasswordHash.recommended()\n\noauth2_scheme = OAuth2PasswordBearer(\n    tokenUrl=""token"",\n    scopes={""me"": ""Read information about the current user."", ""items"": ""Read items.""},\n)\n\napp = FastAPI()\n\n\ndef verify_password(plain_password, hashed_password):\n    return password_hash.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password):\n    return password_hash.hash(password)\n\n\ndef get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)\n\n\ndef authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user\n\n\ndef create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(timezone.utc) + expires_delta\n    else:\n        expire = datetime.now(timezone.utc) + timedelta(minutes=15)\n    to_encode.update({""exp"": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\nasync def get_current_user(\n    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]\n):\n    if security_scopes.scopes:\n        authenticate_value = f\'Bearer scope=""{security_scopes.scope_str}""\'\n    else:\n        authenticate_value = ""Bearer""\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=""Could not validate credentials"",\n        headers={""WWW-Authenticate"": authenticate_value},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username = payload.get(""sub"")\n        if username is None:\n            raise credentials_exception\n        scope: str = payload.get(""scope"", """")\n        token_scopes = scope.split("" "")\n        token_data = TokenData(scopes=token_scopes, username=username)\n    except (InvalidTokenError, ValidationError):\n        raise credentials_exception\n    user = get_user(fake_users_db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    for scope in security_scopes.scopes:\n        if scope not in token_data.scopes:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=""Not enough permissions"",\n                headers={""WWW-Authenticate"": authenticate_value},\n            )\n    return user\n\n\nasync def get_current_active_user(\n    current_user: Annotated[User, Security(get_current_user, scopes=[""me""])],\n):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=""Inactive user"")\n    return current_user\n\n\n@app.post(""/token"")\nasync def login_for_access_token(\n    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],\n) -> Token:\n    user = authenticate_user(fake_users_db, form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(status_code=400, detail=""Incorrect username or password"")\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={""sub"": user.username, ""scope"": "" "".join(form_data.scopes)},\n        expires_delta=access_token_expires,\n    )\n    return Token(access_token=access_token, token_type=""bearer"")\n\n\n@app.get(""/users/me/"", response_model=User)\nasync def read_users_me(\n    current_user: Annotated[User, Depends(get_current_active_user)],\n):\n    return current_user\n\n\n@app.get(""/users/me/items/"")\nasync def read_own_items(\n    current_user: Annotated[User, Security(get_current_active_user, scopes=[""items""])],\n):\n    return [{""item_id"": ""Foo"", ""owner"": current_user.username}]\n\n\n@app.get(""/status/"")\nasync def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):\n    return {""status"": ""ok""}\n\n```\n\n\n下面，我们逐步说明修改的代码内容。\n\n## OAuth2 安全方案\n\n第一个修改的地方是，使用两个作用域 `me` 和 `items ` 声明 OAuth2 安全方案。\n\n`scopes` 参数接收字典，键是作用域、值是作用域的描述：\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n因为声明了作用域，所以登录或授权时会在 API 文档中显示。\n\n此处，选择给予访问权限的作用域： `me` 和 `items`。\n\n这也是使用脸书、谷歌、GitHub 登录时的授权机制。\n\n## JWT 令牌作用域\n\n现在，修改令牌*路径操作*，返回请求的作用域。\n\n此处仍然使用 `OAuth2PasswordRequestForm`。它包含类型为字符串列表的 `scopes` 属性，且`scopes` 属性中包含要在请求里接收的每个作用域。\n\n这样，返回的 JWT 令牌中就包含了作用域。\n\n/// danger | 危险\n\n为了简明起见，本例把接收的作用域直接添加到了令牌里。\n\n但在您的应用中，为了安全，应该只把作用域添加到确实需要作用域的用户，或预定义的用户。\n\n///\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 在*路径操作*与依赖项中声明作用域\n\n接下来，为*路径操作*  `/users/me/items/` 声明作用域 `items`。\n\n为此，要从 `fastapi` 中导入并使用 `Security` 。\n\n`Security` 声明依赖项的方式和 `Depends` 一样，但 `Security` 还能接收作用域（字符串）列表类型的参数 `scopes`。\n\n此处使用与 `Depends` 相同的方式，把依赖项函数 `get_current_active_user` 传递给 `Security`。\n\n同时，还传递了作用域列表，本例中只传递了一个作用域：`items`（此处支持传递更多作用域）。\n\n依赖项函数 `get_current_active_user` 还能声明子依赖项，不仅可以使用 `Depends`，也可以使用 `Security`。声明子依赖项函数（`get_current_user`）及更多作用域。\n\n本例要求使用作用域 `me`（还可以使用更多作用域）。\n\n/// note | 笔记\n\n不必在不同位置添加不同的作用域。\n\n本例使用的这种方式只是为了展示 FastAPI 如何处理在不同层级声明的作用域。\n\n///\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n/// info | 技术细节\n\n`Security` 实际上是 `Depends` 的子类，而且只比 `Depends` 多一个参数。\n\n但使用 `Security` 代替 `Depends`，FastAPI 可以声明安全作用域，并在内部使用这些作用域，同时，使用 OpenAPI 存档 API。\n\n但实际上，从 `fastapi` 导入的 `Query`、`Path`、`Depends`、`Security` 等对象，只是返回特殊类的函数。\n\n///\n\n## 使用 `SecurityScopes`\n\n修改依赖项 `get_current_user`。\n\n这是上面的依赖项使用的依赖项。\n\n这里使用的也是之前创建的 OAuth2 方案，并把它声明为依赖项：`oauth2_scheme`。\n\n该依赖项函数本身不需要作用域，因此，可以使用 `Depends` 和 `oauth2_scheme`。不需要指定安全作用域时，不必使用 `Security`。\n\n此处还声明了从 `fastapi.security` 导入的 `SecurityScopes` 类型的特殊参数。\n\n`SecuriScopes` 类与 `Request` 类似（`Request` 用于直接提取请求对象）。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 使用 `scopes`\n\n参数 `security_scopes` 的类型是 `SecurityScopes`。\n\n它的属性 `scopes`  是作用域列表，所有依赖项都把它作为子依赖项。也就是说所有依赖……这听起来有些绕，后文会有解释。\n\n（类 `SecurityScopes` 的）`security_scopes` 对象还提供了单字符串类型的属性 `scope_str`，该属性是（要在本例中使用的）用空格分割的作用域。\n\n此处还创建了后续代码中要复用（`raise`）的 `HTTPException` 。\n\n该异常包含了作用域所需的（如有），以空格分割的字符串（使用 `scope_str`）。该字符串要放到包含作用域的 `WWW-Authenticate` 请求头中（这也是规范的要求）。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 校验 `username` 与数据形状\n\n我们可以校验是否获取了 `username`，并抽取作用域。\n\n然后，使用 Pydantic 模型校验数据（捕获 `ValidationError` 异常），如果读取 JWT 令牌或使用 Pydantic 模型验证数据时出错，就会触发之前创建的 `HTTPException` 异常。\n\n对此，要使用新的属性 `scopes` 更新 Pydantic 模型 `TokenData`。\n\n使用 Pydantic 验证数据可以确保数据中含有由作用域组成的字符串列表，以及 `username` 字符串等内容。\n\n反之，如果使用字典或其它数据结构，就有可能在后面某些位置破坏应用，形成安全隐患。\n\n还可以使用用户名验证用户，如果没有用户，也会触发之前创建的异常。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 校验 `scopes`\n\n接下来，校验所有依赖项和依赖要素（包括*路径操作*）所需的作用域。这些作用域包含在令牌的 `scopes` 里，如果不在其中就会触发 `HTTPException` 异常。\n\n为此，要使用包含所有作用域字符串列表的 `security_scopes.scopes`， 。\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n## 依赖项树与作用域\n\n再次查看这个依赖项树与作用域。\n\n`get_current_active_user` 依赖项包含子依赖项 `get_current_user`，并在 `get_current_active_user`中声明了作用域 `""me""` 包含所需作用域列表 ，在 `security_scopes.scopes` 中传递给 `get_current_user`。\n\n*路径操作*自身也声明了作用域，`""items""`，这也是 `security_scopes.scopes` 列表传递给 `get_current_user` 的。\n\n依赖项与作用域的层级架构如下：\n\n* *路径操作* `read_own_items` 包含：\n    * 依赖项所需的作用域 `[""items""]`：\n    * `get_current_active_user`:\n        *  依赖项函数 `get_current_active_user` 包含：\n            * 所需的作用域 `""me""` 包含依赖项：\n            * `get_current_user`:\n                * 依赖项函数 `get_current_user` 包含：\n                    * 没有作用域需求其自身\n                    * 依赖项使用 `oauth2_scheme`\n                    * `security_scopes` 参数的类型是 `SecurityScopes`：\n                        * `security_scopes` 参数的属性 `scopes` 是包含上述声明的所有作用域的列表，因此：\n                            * `security_scopes.scopes` 包含用于*路径操作*的 `[""me"", ""items""]`\n                            * `security_scopes.scopes` 包含*路径操作* `read_users_me` 的 `[""me""]`，因为它在依赖项里被声明\n                            * `security_scopes.scopes` 包含用于*路径操作* `read_system_status` 的 `[]`（空列表），并且它的依赖项 `get_current_user` 也没有声明任何 `scope`\n\n/// tip | 提示\n\n此处重要且神奇的事情是，`get_current_user` 检查每个*路径操作*时可以使用不同的 `scopes` 列表。\n\n所有这些都依赖于在每个*路径操作*和指定*路径操作*的依赖树中的每个依赖项。\n\n///\n\n## `SecurityScopes` 的更多细节\n\n您可以任何位置或多个位置使用 `SecurityScopes`，不一定非得在根依赖项中使用。\n\n它总是在当前 `Security` 依赖项中和所有依赖因子对于特定 *路径操作*和特定依赖树中安全作用域\n\n因为 `SecurityScopes` 包含所有由依赖项声明的作用域，可以在核心依赖函数中用它验证所需作用域的令牌，然后再在不同的*路径操作*中声明不同作用域需求。\n\n它们会为每个*路径操作*进行单独检查。\n\n## 查看文档\n\n打开 API 文档，进行身份验证，并指定要授权的作用域。\n\n没有选择任何作用域，也可以进行身份验证，但访问 `/uses/me` 或 `/users/me/items` 时，会显示没有足够的权限。但仍可以访问 `/status/`。\n\n如果选择了作用域 `me`，但没有选择作用域 `items`，则可以访问 `/users/me/`，但不能访问 `/users/me/items`。\n\n这就是通过用户提供的令牌使用第三方应用访问这些*路径操作*时会发生的情况，具体怎样取决于用户授予第三方应用的权限。\n\n## 关于第三方集成\n\n本例使用 OAuth2 密码流。\n\n这种方式适用于登录我们自己的应用，最好使用我们自己的前端。\n\n因为我们能控制自己的前端应用，可以信任它接收 `username` 与 `password`。\n\n但如果构建的是连接其它应用的 OAuth2 应用，比如具有与脸书、谷歌、GitHub 相同功能的第三方身份验证应用。那您就应该使用其它安全流。\n\n最常用的是隐式流。\n\n最安全的是代码流，但实现起来更复杂，而且需要更多步骤。因为它更复杂，很多第三方身份验证应用最终建议使用隐式流。\n\n/// note | 笔记\n\n每个身份验证应用都会采用不同方式会命名流，以便融合入自己的品牌。\n\n但归根结底，它们使用的都是 OAuth2 标准。\n\n///\n\nFastAPI 的 `fastapi.security.oauth2` 里包含了所有 OAuth2 身份验证流工具。\n\n## 装饰器 `dependencies` 中的 `Security`\n\n同样，您可以在装饰器的 `dependencies` 参数中定义 `Depends` 列表，（详见[路径操作装饰器依赖项](../../tutorial/dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank})），也可以把 `scopes` 与 `Security` 一起使用。']","在FastAPI中处理不同权限作用域（Scopes）的步骤如下：  
1. **声明作用域**：使用 `OAuth2PasswordBearer` 的 `scopes` 参数定义作用域字典（如 `{""me"": ""用户信息"", ""items"": ""项目权限""}`）。  
2. **校验令牌**：在依赖项中通过 `SecurityScopes` 获取当前路径操作所需的作用域列表，并验证JWT令牌中的 `scope` 字段是否包含这些权限。  
3. **权限控制**：在路径操作中使用 `Security`（而非 `Depends`）注入依赖项，并通过 `scopes` 参数声明所需作用域（如 `Security(dependency, scopes=[""items""])`）。  

具体实现参考上下文中的 `get_current_user` 函数和路径操作装饰器示例。","处理 Scopes 时，FastAPI 使用 Security 类。1. 在 OAuth2PasswordBearer 中定义 scopes 映射（key 为作用域名称，value 为描述）；2. 在依赖项函数中使用 Security(oauth2_scheme, scopes=['items:read'])，这表示该依赖项需要特定的权限；3. 依赖项可以通过 SecurityScopes 对象获取当前路由请求的所有 scopes，并将其与 JWT token 中解码出的 scopes 进行比对，如果不匹配则抛出 401 或 403 异常。",0.9999999999,0.9230769230769231,0.6184860495515554
FastAPI 相比于 Flask 和 Django，在性能和开发体验上的核心优势是什么？,"['# FastAPI\n\nFastAPI 框架，高性能，易于学习，高效编码，生产可用\n\n文档： https://fastapi.tiangolo.com\n\n源码： https://github.com/fastapi/fastapi\n\nFastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 并基于标准的 Python 类型提示。\n\n关键特性:\n\n* 快速：可与 NodeJS 和 Go 并肩的极高性能（归功于 Starlette 和 Pydantic）。[最快的 Python web 框架之一](#_11)。\n\n* 高效编码：提高功能开发速度约 200％ 至 300％。*\n* 更少 bug：减少约 40％ 的人为（开发者）导致错误。*\n* 智能：极佳的编辑器支持。处处皆可<abbr title=""也被称为自动完成、智能感知"">自动补全</abbr>，减少调试时间。\n* 简单：设计的易于使用和学习，阅读文档的时间更短。\n* 简短：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。\n* 健壮：生产可用级别的代码。还有自动生成的交互式文档。\n* 标准化：基于（并完全兼容）API 的相关开放标准：OpenAPI (以前被称为 Swagger) 和 JSON Schema。\n\n* 根据对某个构建线上应用的内部开发团队所进行的测试估算得出。\n\n## Sponsors\n\n<!-- sponsors -->\n\n{% if sponsors %}\n{% for sponsor in sponsors.gold -%}\n\n{% endfor -%}\n{%- for sponsor in sponsors.silver -%}\n\n{% endfor %}\n{% endif %}\n\n<!-- /sponsors -->\nOther sponsors\n\n## 评价\n\n「_[...] 最近我一直在使用 FastAPI。[...] 实际上我正在计划将其用于我所在的微软团队的所有机器学习服务。其中一些服务正被集成进核心 Windows 产品和一些 Office 产品。_」\n\nKabir Khan - 微软 (ref)\n\n「_我们选择了 FastAPI 来创建用于获取预测结果的 REST 服务。[用于 Ludwig]_」\n\nPiero Molino，Yaroslav Dudin 和 Sai Sumanth Miryala - Uber (ref)\n\n「_Netflix 非常高兴地宣布，正式开源我们的危机管理编排框架：Dispatch！[使用 FastAPI 构建]_」\n\nKevin Glisson，Marc Vilanova，Forest Monsen - Netflix (ref)\n\n「_FastAPI 让我兴奋的欣喜若狂。它太棒了！_」\n\nBrian Okken - Python Bytes 播客主持人 (ref)\n\n「_老实说，你的作品看起来非常可靠和优美。在很多方面，这就是我想让 Hug 成为的样子 - 看到有人实现了它真的很鼓舞人心。_」\n\nTimothy Crosley - Hug 作者 (ref)\n\n「_如果你正打算学习一个现代框架用来构建 REST API，来看下 FastAPI [...] 它快速、易用且易于学习 [...]_」\n\n「_我们已经将 API 服务切换到了 FastAPI [...] 我认为你会喜欢它的 [...]_」\n\nInes Montani - Matthew Honnibal - Explosion AI 创始人 - spaCy 作者 (ref) - (ref)\n\n## Typer，命令行中的 FastAPI\n\n如果你正在开发一个在终端中运行的<abbr title=""Command Line Interface"">命令行</abbr>应用而不是 web API，不妨试下 Typer。\n\nTyper 是 FastAPI 的小同胞。它想要成为命令行中的 FastAPI。 ⌨️ 🚀\n\n## 依赖\n\nPython 及更高版本\n\nFastAPI 站在以下巨人的肩膀之上：\n\n* Starlette 负责 web 部分。\n* Pydantic 负责数据部分。\n\n## 安装\n\n```console\n$ pip install fastapi\n\n&gt; 100%\n```\n\n你还会需要一个 ASGI 服务器，生产环境可以使用 Uvicorn 或者 Hypercorn。\n\n```console\n$ pip install ""uvicorn[standard]""\n\n&gt; 100%\n```\n\n## 示例\n\n### 创建\n\n* 创建一个 `main.py` 文件并写入以下内容:\n\n```Python\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(""/"")\ndef read_root():\n    return {""Hello"": ""World""}\n\n@app.get(""/items/{item_id}"")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {""item_id"": item_id, ""q"": q}\n```\n\n<details markdown=""1"">\n<summary>或者使用 <code>async def</code>...</summary>\n\n如果你的代码里会出现 `async` / `await`，请使用 `async def`：\n\n```Python hl_lines=""9  14""\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(""/"")\nasync def read_root():\n    return {""Hello"": ""World""}\n\n@app.get(""/items/{item_id}"")\nasync def read_item(item_id: int, q: Union[str, None] = None):\n    return {""item_id"": item_id, ""q"": q}\n```\n\nNote:\n\n如果你不知道是否会用到，可以查看文档的 _""In a hurry?""_ 章节中 关于 `async` 和 `await` 的部分。\n\n</details>\n\n### 运行\n\n通过以下命令运行服务器：\n\n```console\n$ uvicorn main:app --reload\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [28720]\nINFO:     Started server process [28722]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```\n\n<details markdown=""1"">\n<summary>关于 <code>uvicorn main:app --reload</code> 命令......</summary>\n\n `uvicorn main:app` 命令含义如下:\n\n* `main`：`main.py` 文件（一个 Python ""模块""）。\n* `app`：在 `main.py` 文件中通过 `app = FastAPI()` 创建的对象。\n* `--reload`：让服务器在更新代码后重新启动。仅在开发时使用该选项。\n\n</details>\n\n### 检查\n\n使用浏览器访问 http://127.0.0.1:8000/items/5?q=somequery。\n\n你将会看到如下 JSON 响应：\n\n```JSON\n{""item_id"": 5, ""q"": ""somequery""}\n```\n\n你已经创建了一个具有以下功能的 API：\n\n* 通过 _路径_ `/` 和 `/items/{item_id}` 接受 HTTP 请求。\n* 以上 _路径_ 都接受 `GET` 操作（也被称为 HTTP _方法_）。\n* `/items/{item_id}` _路径_ 有一个 _路径参数_ `item_id` 并且应该为 `int` 类型。\n* `/items/{item_id}` _路径_ 有一个可选的 `str` 类型的 _查询参数_ `q`。\n\n### 交互式 API 文档\n\n现在访问 http://127.0.0.1:8000/docs。\n\n你会看到自动生成的交互式 API 文档（由 Swagger UI生成）：\n\n![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)\n\n### 可选的 API 文档\n\n访问 http://127.0.0.1:8000/redoc。\n\n你会看到另一个自动生成的文档（由 ReDoc 生成）：\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)\n\n## 示例升级\n\n现在修改 `main.py` 文件来从 `PUT` 请求中接收请求体。\n\n我们借助 Pydantic 来使用标准的 Python 类型声明请求体。\n\n```Python hl_lines=""4  9-12  25-27""\nfrom typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_offer: Union[bool, None] = None\n\n@app.get(""/"")\ndef read_root():\n    return {""Hello"": ""World""}\n\n@app.get(""/items/{item_id}"")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {""item_id"": item_id, ""q"": q}\n\n@app.put(""/items/{item_id}"")\ndef update_item(item_id: int, item: Item):\n    return {""item_name"": item.name, ""item_id"": item_id}\n```\n\n服务器将会自动重载（因为在上面的步骤中你向 `uvicorn` 命令添加了 `--reload` 选项）。\n\n### 交互式 API 文档升级\n\n访问 http://127.0.0.1:8000/docs。\n\n* 交互式 API 文档将会自动更新，并加入新的请求体：\n\n![Swagger UI](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)\n\n* 点击「Try it out」按钮，之后你可以填写参数并直接调用 API：\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-04-swagger-03.png)\n\n* 然后点击「Execute」按钮，用户界面将会和 API 进行通信，发送参数，获取结果并在屏幕上展示：\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-05-swagger-04.png)\n\n### 可选文档升级\n\n访问 http://127.0.0.1:8000/redoc。\n\n* 可选文档同样会体现新加入的请求参数和请求体：\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)\n\n### 总结\n\n总的来说，你就像声明函数的参数类型一样只声明了一次请求参数、请求体等的类型。\n\n你使用了标准的现代 Python 类型来完成声明。\n\n你不需要去学习新的语法、了解特定库的方法或类，等等。\n\n只需要使用标准的 Python 及更高版本。\n\n举个例子，比如声明 `int` 类型：\n\n```Python\nitem_id: int\n```\n\n或者一个更复杂的 `Item` 模型：\n\n```Python\nitem: Item\n```\n\n......在进行一次声明之后，你将获得：\n\n* 编辑器支持，包括：\n    * 自动补全\n    * 类型检查\n* 数据校验：\n    * 在校验失败时自动生成清晰的错误信息\n    * 对多层嵌套的 JSON 对象依然执行校验\n* <abbr title=""也被称为：序列化或解析"">转换</abbr> 来自网络请求的输入数据为 Python 数据类型。包括以下数据：\n    * JSON\n    * 路径参数\n    * 查询参数\n    * Cookies\n    * 请求头\n    * 表单\n    * 文件\n* <abbr title=""也被称为：序列化或解析"">转换</abbr> 输出的数据：转换 Python 数据类型为供网络传输的 JSON 数据：\n    * 转换 Python 基础类型 （`str`、 `int`、 `float`、 `bool`、 `list` 等）\n    * `datetime` 对象\n    * `UUID` 对象\n    * 数据库模型\n    * ......以及更多其他类型\n* 自动生成的交互式 API 文档，包括两种可选的用户界面：\n    * Swagger UI\n    * ReDoc\n\n回到前面的代码示例，FastAPI 将会：\n\n* 校验 `GET` 和 `PUT` 请求的路径中是否含有 `item_id`。\n* 校验 `GET` 和 `PUT` 请求中的 `item_id` 是否为 `int` 类型。\n    * 如果不是，客户端将会收到清晰有用的错误信息。\n* 检查 `GET` 请求中是否有命名为 `q` 的可选查询参数（比如 `http://127.0.0.1:8000/items/foo?q=somequery`）。\n    * 因为 `q` 被声明为 `= None`，所以它是可选的。\n    * 如果没有 `None` 它将会是必需的 (如 `PUT` 例子中的请求体)。\n* 对于访问 `/items/{item_id}` 的 `PUT` 请求，将请求体读取为 JSON 并：\n    * 检查是否有必需属性 `name` 并且值为 `str` 类型 。\n    * 检查是否有必需属性 `price` 并且值为 `float` 类型。\n    * 检查是否有可选属性 `is_offer`， 如果有的话值应该为 `bool` 类型。\n    * 以上过程对于多层嵌套的 JSON 对象同样也会执行\n* 自动对 JSON 进行转换或转换成 JSON。\n* 通过 OpenAPI 文档来记录所有内容，可被用于：\n    * 交互式文档系统\n    * 许多编程语言的客户端代码自动生成系统\n* 直接提供 2 种交互式文档 web 界面。\n\n虽然我们才刚刚开始，但其实你已经了解了这一切是如何工作的。\n\n尝试更改下面这行代码：\n\n```Python\n    return {""item_name"": item.name, ""item_id"": item_id}\n```\n\n......从：\n\n```Python\n        ... ""item_name"": item.name ...\n```\n\n......改为：\n\n```Python\n        ... ""item_price"": item.price ...\n```\n\n......注意观察编辑器是如何自动补全属性并且还知道它们的类型：\n\n![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)\n\n教程 - 用户指南 中有包含更多特性的更完整示例。\n\n剧透警告： 教程 - 用户指南中的内容有：\n\n* 对来自不同地方的参数进行声明，如：请求头、cookies、form 表单以及上传的文件。\n* 如何设置校验约束如 `maximum_length` 或者 `regex`。\n* 一个强大并易于使用的 <abbr title=""也被称为 components, resources, providers, services, injectables"">依赖注入</abbr> 系统。\n* 安全性和身份验证，包括通过 JWT 令牌和 HTTP 基本身份认证来支持 OAuth2。\n* 更进阶（但同样简单）的技巧来声明 多层嵌套 JSON 模型 （借助 Pydantic）。\n* 许多额外功能（归功于 Starlette）比如：\n    * WebSockets\n    * GraphQL\n    * 基于 HTTPX 和 `pytest` 的极其简单的测试\n    * CORS\n    * Cookie Sessions\n    * ......以及更多\n\n## 性能\n\n独立机构 TechEmpower 所作的基准测试结果显示，基于 Uvicorn 运行的 FastAPI 程序是 最快的 Python web 框架之一，仅次于 Starlette 和 Uvicorn 本身（FastAPI 内部使用了它们）。(*)\n\n想了解更多，请查阅 基准测试 章节。\n\n## 可选依赖\n\n用于 Pydantic：\n\n* email-validator - 用于 email 校验。\n\n用于 Starlette：\n\n* httpx - 使用 `TestClient` 时安装。\n* jinja2 - 使用默认模板配置时安装。\n* python-multipart - 需要通过 `request.form()` 对表单进行<abbr title=""将来自 HTTP 请求中的字符串转换为 Python 数据类型"">「解析」</abbr>时安装。\n* itsdangerous - 需要 `SessionMiddleware` 支持时安装。\n* pyyaml - 使用 Starlette 提供的 `SchemaGenerator` 时安装（有 FastAPI 你可能并不需要它）。\n* graphene - 需要 `GraphQLApp` 支持时安装。\n\n用于 FastAPI / Starlette：\n\n* uvicorn - 用于加载和运行你的应用程序的服务器。\n* orjson - 使用 `ORJSONResponse` 时安装。\n* ujson - 使用 `UJSONResponse` 时安装。\n\n你可以通过 `pip install ""fastapi[all]""` 命令来安装以上所有依赖。\n\n## 许可协议\n\n该项目遵循 MIT 许可协议。', '# 特性\n\n## FastAPI 特性\n\nFastAPI 提供了以下内容：\n\n### 基于开放标准\n\n* 用于创建 API 的 OpenAPI 包含了<abbr title=""也被叫做: endpoints, routes"">路径</abbr><abbr title=""也叫做HTTP方法, 例如 POST, GET, PUT, DELETE"">操作</abbr>，请求参数，请求体，安全性等的声明。\n* 使用 JSON Schema (因为 OpenAPI 本身就是基于 JSON Schema 的)自动生成数据模型文档。\n* 经过了缜密的研究后围绕这些标准而设计。并非狗尾续貂。\n* 这也允许了在很多语言中自动生成客户端代码。\n\n### 自动生成文档\n\n交互式 API 文档以及具探索性 web 界面。因为该框架是基于 OpenAPI，所以有很多可选项，FastAPI 默认自带两个交互式 API 文档。\n\n* Swagger UI，可交互式操作，能在浏览器中直接调用和测试你的 API  。\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)\n\n* 另外的 API 文档：ReDoc\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)\n\n### 更主流的 Python\n\n全部都基于标准的 Python 3.6 类型声明（感谢 Pydantic ）。没有新的语法需要学习。只需要标准的 Python 。\n\n如果你需要2分钟来学习如何使用 Python 类型（即使你不使用 FastAPI ），看看这个简短的教程：[Python Types](python-types.md){.internal-link target=_blank}。\n\n编写带有类型标注的标准 Python：\n\n```Python\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n# Declare a variable as a str\n# and get editor support inside the function\ndef main(user_id: str):\n    return user_id\n\n# A Pydantic model\nclass User(BaseModel):\n    id: int\n    name: str\n    joined: date\n```\n\n可以像这样来使用：\n\n```Python\nmy_user: User = User(id=3, name=""John Doe"", joined=""2018-07-19"")\n\nsecond_user_data = {\n    ""id"": 4,\n    ""name"": ""Mary"",\n    ""joined"": ""2018-11-30"",\n}\n\nmy_second_user: User = User(second_user_data)\n```\n\n/// info\n\n`second_user_data` 意思是:\n\n直接将`second_user_data`字典的键和值直接作为key-value参数传递，等同于：`User(id=4, name=""Mary"", joined=""2018-11-30"")`\n\n///\n\n### 编辑器支持\n\n整个框架都被设计得易于使用且直观，所有的决定都在开发之前就在多个编辑器上进行了测试，来确保最佳的开发体验。\n\n在最近的 Python 开发者调查中，我们能看到 被使用最多的功能是""自动补全""。\n\n整个 FastAPI 框架就是基于这一点的。任何地方都可以进行自动补全。\n\n你几乎不需要经常回来看文档。\n\n在这里，你的编辑器可能会这样帮助你：\n\n* Visual Studio Code 中:\n\n![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)\n\n* PyCharm 中:\n\n![editor support](https://fastapi.tiangolo.com/img/pycharm-completion.png)\n\n你将能进行代码补全，这是在之前你可能曾认为不可能的事。例如，在来自请求 JSON 体（可能是嵌套的）中的键 `price`。\n\n不会再输错键名，来回翻看文档，或者来回滚动寻找你最后使用的 `username` 或者 `user_name` 。\n\n### 简洁\n\n任何类型都有合理的默认值，任何和地方都有可选配置。所有的参数被微调，来满足你的需求，定义成你需要的 API。\n\n但是默认情况下，一切都能“顺利工作”。\n\n### 验证\n\n* 校验大部分（甚至所有？）的 Python 数据类型，包括：\n    * JSON 对象 (`dict`).\n    * JSON 数组 (`list`) 定义成员类型。\n    * 字符串 (`str`) 字段, 定义最小或最大长度。\n    * 数字 (`int`, `float`) 有最大值和最小值， 等等。\n\n* 校验外来类型， 比如:\n    * URL.\n    * Email.\n    * UUID.\n    * ...及其他.\n\n所有的校验都由完善且强大的 Pydantic 处理。\n\n### 安全性及身份验证\n\n集成了安全性和身份认证。杜绝数据库或者数据模型的渗透风险。\n\nOpenAPI 中定义的安全模式，包括：\n\n* HTTP 基本认证。\n* OAuth2 (也使用 JWT tokens)。在 [OAuth2 with JWT](tutorial/security/oauth2-jwt.md){.internal-link target=_blank}查看教程。\n* API 密钥，在:\n    * 请求头。\n    * 查询参数。\n    * Cookies, 等等。\n\n加上来自 Starlette（包括 session cookie）的所有安全特性。\n\n所有的这些都是可复用的工具和组件，可以轻松与你的系统，数据仓库，关系型以及 NoSQL 数据库等等集成。\n\n### 依赖注入\n\nFastAPI 有一个使用非常简单，但是非常强大的<abbr title=\'也叫做 ""components"", ""resources"", ""services"", ""providers""\'>依赖注入</abbr>系统。\n\n* 甚至依赖也可以有依赖，创建一个层级或者“图”依赖。\n* 所有自动化处理都由框架完成。\n* 所有的依赖关系都可以从请求中获取数据，并且增加了路径操作约束和自动文档生成。\n* 即使在依赖项中被定义的*路径操作* 也会自动验证。\n* 支持复杂的用户身份认证系统，数据库连接等等。\n* 不依赖数据库，前端等。 但是和它们集成很简单。\n\n### 无限制""插件""\n\n或者说，导入并使用你需要的代码，而不需要它们。\n\n任何集成都被设计得被易于使用（用依赖关系），你可以用和*路径操作*相同的结构和语法，在两行代码中为你的应用创建一个“插件”。\n\n### 测试\n\n* 100% <abbr title=""自动测试的代码量"">测试覆盖</abbr>。\n* 代码库100% <abbr title=""Python类型注解，有了这个你的编辑器和外部工具可以给你更好的支持"">类型注释</abbr>。\n* 用于生产应用。\n\n## Starlette 特性\n\nFastAPI 和 Starlette 完全兼容(并基于)。所以，你有的其他的 Starlette 代码也能正常工作。`FastAPI` 实际上是 `Starlette`的一个子类。所以，如果你已经知道或者使用 Starlette，大部分的功能会以相同的方式工作。\n\n通过 FastAPI 你可以获得所有 Starlette 的特性 ( FastAPI 就像加强版的 Starlette )：\n\n* 令人惊叹的性能。它是 Python 可用的最快的框架之一，和\xa0NodeJS 及\xa0Go 相当。\n* 支持 WebSocket 。\n* 支持 GraphQL 。\n* 后台任务处理。\n* Startup 和 shutdown 事件。\n* 测试客户端基于 HTTPX。\n* CORS, GZip, 静态文件, 流响应。\n* 支持 Session 和 Cookie 。\n* 100% 测试覆盖率。\n* 代码库 100% 类型注释。\n\n## Pydantic 特性\n\nFastAPI 和 Pydantic 完全兼容(并基于)。所以，你有的其他的 Pydantic 代码也能正常工作。\n\n兼容包括基于 Pydantic 的外部库， 例如用与数据库的 <abbr title=""对象关系映射"">ORM</abbr>s, <abbr title=""对象文档映射"">ODM</abbr>s。\n\n这也意味着在很多情况下，你可以将从请求中获得的相同对象直接传到数据库，因为所有的验证都是自动的。\n\n反之亦然，在很多情况下，你也可以将从数据库中获取的对象直接传到客户端。\n\n通过 FastAPI 你可以获得所有 Pydantic  (FastAPI 基于 Pydantic 做了所有的数据处理)：\n\n* 更简单：\n    * 没有新的模式定义 micro-language 需要学习。\n    * 如果你知道 Python types，你就知道如何使用 Pydantic。\n* 和你 <abbr title=""集成开发环境，和代码编辑器类似"">IDE</abbr>/<abbr title=""一个检查代码错误的程序"">linter</abbr>/brain 适配:\n    * 因为 pydantic 数据结构仅仅是你定义的类的实例；自动补全，linting，mypy 以及你的直觉应该可以和你验证的数据一起正常工作。\n* 验证复杂结构:\n    * 使用分层的 Pydantic 模型, Python `typing`的 `List` 和 `Dict` 等等。\n    * 验证器使我们能够简单清楚的将复杂的数据模式定义、检查并记录为 JSON Schema。\n    * 你可以拥有深度嵌套的 JSON 对象并对它们进行验证和注释。\n* 可扩展:\n    * Pydantic 允许定义自定义数据类型或者你可以用验证器装饰器对被装饰的模型上的方法扩展验证。\n* 100% 测试覆盖率。', '# 基准测试\n\n第三方机构 TechEmpower 的基准测试表明在 Uvicorn 下运行的 FastAPI 应用程序是 可用的最快的 Python 框架之一，仅次于 Starlette 和 Uvicorn 本身 (由 FastAPI 内部使用）。(*)\n\n但是在查看基准得分和对比时，请注意以下几点。\n\n## 基准测试和速度\n\n当你查看基准测试时，几个不同类型的工具被等效地做比较是很常见的情况。\n\n具体来说，是将 Uvicorn，Starlette 和 FastAPI 一起比较（在许多其它工具中）。\n\n该工具解决的问题最简单，它将获得更好的性能。而且大多数基准测试并未测试该工具提供的其他功能。\n\n层次结构如下：\n\n* Uvicorn：ASGI服务器\n    * Starlette：（使用 Uvicorn）网络微框架\n        * FastAPI：（使用 Starlette） 具有多个附加功能的API微框架，用于构建API，进行数据验证等。\n\n* Uvicorn:\n    * 具有最佳性能，因为除了服务器本身外，它没有太多额外的代码。\n    * 您不会直接在 Uvicorn 中编写应用程序。这意味着您的代码至少必须包含 Starlette（或 FastAPI）提供的代码。如果您这样做了（即直接在 Uvicorn 中编写应用程序），最终的应用程序会和使用了框架并且最小化了应用代码和 bug 的情况具有相同的性能损耗。\n    * 如果要对比与 Uvicorn 对标的服务器，请将其与 Daphne，Hypercorn，uWSGI等应用服务器进行比较。\n* Starlette:\n    * 在 Uvicorn 后使用 Starlette，性能会略有下降。实际上，Starlette 使用 Uvicorn运行。因此，由于必须执行更多的代码，它只会比 Uvicorn 更慢。\n    * 但它为您提供了构建简单的网络程序的工具，并具有基于路径的路由等功能。\n    * 如果想对比与 Starlette 对标的开发框架，请将其与 Sanic，Flask，Django 等网络框架（或微框架）进行比较。\n* FastAPI:\n    * 与 Starlette 使用 Uvicorn 一样，由于 FastAPI 使用 Starlette，因此 FastAPI 不能比 Starlette 更快。\n    * FastAPI 在 Starlette 基础上提供了更多功能。例如在开发 API 时，所需的数据验证和序列化功能。FastAPI 可以帮助您自动生成 API文档，（文档在应用程序启动时自动生成，所以不会增加应用程序运行时的开销）。\n    * 如果您不使用 FastAPI 而直接使用 Starlette（或诸如 Sanic，Flask，Responder 等其它工具），您则要自己实现所有的数据验证和序列化。那么最终您的应用程序会和使用 FastAPI 构建的程序有相同的开销。一般这种数据验证和序列化的操作在您应用程序的代码中会占很大比重。\n    * 因此，通过使用 FastAPI 意味着您可以节省开发时间，减少编码错误，用更少的编码实现其功能，并且相比不使用 FastAPI 您很大可能会获得相同或更好的性能（因为那样您必须在代码中实现所有相同的功能）。\n    * 如果您想对比与 FastAPI 对标的开发框架，请与能够提供数据验证，序列化和带有自动文档生成的网络应用程序框架（或工具集）进行对比，例如具有集成自动数据验证，序列化和自动化文档的 Flask-apispec，NestJS，Molten 等。']","根据上下文，FastAPI的核心优势如下：  
1. **性能**：采用异步架构（基于Starlette和Pydantic），是**最快的Python框架之一**，性能接近NodeJS和Go。  
2. **开发效率**：基于Python类型提示的**自动数据验证、序列化及交互式文档生成**，提升开发速度200%-300%，减少40%人为错误。  
3. **开发体验**：**深度编辑器支持**（自动补全、类型检查），简化API构建与测试流程。",核心优势：1. 性能：基于 ASGI 标准（Starlette），原生支持异步并发，QPS 远超基于 WSGI 的 Flask 和 Django；2. 开发效率：自动生成交互式文档（Swagger/ReDoc），省去手动写 API 文档的时间；3. 类型安全：强制使用类型提示，IDE 自动补全极佳，大幅减少运行时错误；4. 自动校验：内置 Pydantic 校验，无需像 Flask 那样手动解析 JSON 或像 Django 那样写复杂的 Form/Serializer。,0.9999999999666667,1.0,0.8612664469649104
为什么在生产环境中通常建议使用 Gunicorn 配合 Uvicorn 工作，而不是直接运行 Uvicorn？,"['# 容器中的 FastAPI - Docker\n\n部署 FastAPI 应用程序时，常见的方法是构建 Linux 容器镜像。 通常使用 Docker 完成。 然后，你可以通过几种可能的方式之一部署该容器镜像。\n\n使用 Linux 容器有几个优点，包括安全性、可复制性、简单性等。\n\n/// tip\n\n赶时间并且已经知道这些东西了？ 跳转到下面的 [`Dockerfile` 👇](#fastapi-docker_1)。\n\n///\n\n<details>\n<summary>Dockerfile Preview 👀</summary>\n\n```Dockerfile\nFROM python:3.9\n\nWORKDIR /code\n\nCOPY ./requirements.txt /code/requirements.txt\n\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\nCOPY ./app /code/app\n\nCMD [""uvicorn"", ""app.main:app"", ""--host"", ""0.0.0.0"", ""--port"", ""80""]\n\n# If running behind a proxy like Nginx or Traefik add --proxy-headers\n# CMD [""uvicorn"", ""app.main:app"", ""--host"", ""0.0.0.0"", ""--port"", ""80"", ""--proxy-headers""]\n```\n\n</details>\n\n## 什么是容器\n\n容器（主要是 Linux 容器）是一种非常轻量级的打包应用程序的方式，其包括所有依赖项和必要的文件，同时它们可以和同一系统中的其他容器（或者其他应用程序/组件）相互隔离。\n\nLinux 容器使用宿主机（如物理服务器、虚拟机、云服务器等）的Linux 内核运行。 这意味着它们非常轻量（与模拟整个操作系统的完整虚拟机相比）。\n\n通过这样的方式，容器消耗很少的资源，与直接运行进程相当（虚拟机会消耗更多）。\n\n容器的进程（通常只有一个）、文件系统和网络都运行在隔离的环境，这简化了部署、安全、开发等。\n\n## 什么是容器镜像\n\n容器是从容器镜像运行的。\n\n容器镜像是容器中文件、环境变量和默认命令/程序的静态版本。 静态这里的意思是容器镜像还没有运行，只是打包的文件和元数据。\n\n与存储静态内容的“容器镜像”相反，“容器”通常指正在运行的实例，即正在执行的。\n\n当容器启动并运行时（从容器镜像启动），它可以创建或更改文件、环境变量等。这些更改将仅存在于该容器中，而不会持久化到底层的容器镜像中（不会保存到磁盘）。\n\n容器镜像相当于程序和文件，例如 `python`命令 和某些文件 如`main.py`。\n\n而容器本身（与容器镜像相反）是镜像的实际运行实例，相当于进程。 事实上，容器仅在有进程运行时才运行（通常它只是一个单独的进程）。 当容器中没有进程运行时，容器就会停止。\n\n## 容器镜像\n\nDocker 一直是创建和管理容器镜像和容器的主要工具之一。\n\n还有一个公共 Docker Hub ，其中包含预制的 官方容器镜像, 适用于许多工具、环境、数据库和应用程序。\n\n例如，有一个官方的 Python 镜像。\n\n还有许多其他镜像用于不同的需要（例如数据库），例如：\n\n* PostgreSQL\n* MySQL\n* MongoDB\n* Redis, etc.\n\n通过使用预制的容器镜像，可以非常轻松地组合并使用不同的工具。 例如，尝试一个新的数据库。 在大多数情况下，你可以使用官方镜像，只需为其配置环境变量即可。\n\n这样，在许多情况下，你可以了解容器和 Docker，并通过许多不同的工具和组件重复使用这些知识。\n\n因此，你可以运行带有不同内容的多个容器，例如数据库、Python 应用程序、带有 React 前端应用程序的 Web 服务器，并通过内部网络将它们连接在一起。\n\n所有容器管理系统（如 Docker 或 Kubernetes）都集成了这些网络功能。\n\n## 容器和进程\n\n容器镜像通常在其元数据中包含启动容器时应运行的默认程序或命令以及要传递给该程序的参数。 与在命令行中的情况非常相似。\n\n当 容器 启动时，它将运行该命令/程序（尽管你可以覆盖它并使其运行不同的命令/程序）。\n\n只要主进程（命令或程序）在运行，容器就在运行。\n\n容器通常有一个单个进程，但也可以从主进程启动子进程，这样你就可以在同一个容器中拥有多个进程。\n\n但是，如果没有至少一个正在运行的进程，就不可能有一个正在运行的容器。 如果主进程停止，容器也会停止。\n\n## 为 FastAPI 构建 Docker 镜像\n\n好吧，让我们现在构建一些东西！ 🚀\n\n我将向你展示如何基于 官方 Python 镜像 从头开始 为 FastAPI 构建 Docker 镜像。\n\n这是你在大多数情况下想要做的，例如：\n\n* 使用 Kubernetes 或类似工具\n* 在 Raspberry Pi 上运行时\n* 使用可为你运行容器镜像的云服务等。\n\n### 依赖项\n\n你通常会在某个文件中包含应用程序的依赖项。\n\n具体做法取决于你安装这些依赖时所使用的工具。\n\n最常见的方法是创建一个`requirements.txt`文件，其中每行包含一个包名称和它的版本。\n\n你当然也可以使用在[关于 FastAPI 版本](versions.md){.internal-link target=_blank} 中讲到的方法来设置版本范围。\n\n例如，你的`requirements.txt`可能如下所示：\n\n```\nfastapi&gt;=0.68.0,&lt;0.69.0\npydantic&gt;=1.8.0,&lt;2.0.0\nuvicorn&gt;=0.15.0,&lt;0.16.0\n```\n\n你通常会使用`pip`安装这些依赖项：\n\n```console\n$ pip install -r requirements.txt\n&gt; 100%\nSuccessfully installed fastapi pydantic uvicorn\n```\n\n/// info\n\n还有其他文件格式和工具来定义和安装依赖项。\n\n 我将在下面的部分中向你展示一个使用 Poetry 的示例。 👇\n\n///\n\n### 创建 FastAPI 代码\n\n* 创建`app`目录并进入。\n* 创建一个空文件`init.py`。\n* 创建一个 `main.py` 文件：\n\n```Python\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(""/"")\ndef read_root():\n    return {""Hello"": ""World""}\n\n@app.get(""/items/{item_id}"")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {""item_id"": item_id, ""q"": q}\n```\n\n### Dockerfile\n\n现在在相同的project目录创建一个名为`Dockerfile`的文件:\n\n```{ .dockerfile .annotate }\n# (1)\nFROM python:3.9\n\n# (2)\nWORKDIR /code\n\n# (3)\nCOPY ./requirements.txt /code/requirements.txt\n\n# (4)\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\n# (5)\nCOPY ./app /code/app\n\n# (6)\nCMD [""uvicorn"", ""app.main:app"", ""--host"", ""0.0.0.0"", ""--port"", ""80""]\n```\n\n1. 从官方Python基础镜像开始。\n\n2. 将当前工作目录设置为`/code`。\n\n     这是我们放置`requirements.txt`文件和`app`目录的位置。\n\n3. 将符合要求的文件复制到`/code`目录中。\n\n     首先仅复制requirements.txt文件，而不复制其余代码。\n\n     由于此文件不经常更改，Docker 将检测到它并在这一步中使用缓存，从而为下一步启用缓存。\n\n4. 安装需求文件中的包依赖项。\n\n     `--no-cache-dir` 选项告诉 `pip` 不要在本地保存下载的包，因为只有当 `pip` 再次运行以安装相同的包时才会这样，但在与容器一起工作时情况并非如此。\n\n     /// note | 笔记\n\n     `--no-cache-dir` 仅与 `pip` 相关，与 Docker 或容器无关。\n\n     ///\n\n     `--upgrade` 选项告诉 `pip` 升级软件包（如果已经安装）。\n\n     因为上一步复制文件可以被 Docker 缓存 检测到，所以此步骤也将 使用 Docker 缓存（如果可用）。\n\n     在开发过程中一次又一次构建镜像时，在此步骤中使用缓存将为你节省大量时间，而不是每次都下载和安装所有依赖项。\n\n5. 将“./app”目录复制到“/code”目录中。\n\n     由于其中包含更改最频繁的所有代码，因此 Docker 缓存不会轻易用于此操作或任何后续步骤。\n\n     因此，将其放在`Dockerfile`接近最后的位置非常重要，以优化容器镜像的构建时间。\n\n6. 设置命令来运行 `uvicorn` 服务器。\n\n     `CMD` 接受一个字符串列表，每个字符串都是你在命令行中输入的内容，并用空格分隔。\n\n     该命令将从 当前工作目录 运行，即你上面使用`WORKDIR /code`设置的同一`/code`目录。\n\n     因为程序将从`/code`启动，并且其中包含你的代码的目录`./app`，所以Uvicorn将能够从`app.main`中查看并import`app`。\n\n/// tip\n\n通过单击代码中的每个数字气泡来查看每行的作用。 👆\n\n///\n\n你现在应该具有如下目录结构：\n```\n.\n├── app\n│\xa0\xa0 ├── init.py\n│   └── main.py\n├── Dockerfile\n└── requirements.txt\n```\n\n#### 在 TLS 终止代理后面\n\n如果你在 Nginx 或 Traefik 等 TLS 终止代理（负载均衡器）后面运行容器，请添加选项 `--proxy-headers`，这将告诉 Uvicorn 信任该代理发送的标头，告诉它应用程序正在 HTTPS 后面运行等信息\n\n```Dockerfile\nCMD [""uvicorn"", ""app.main:app"", ""--proxy-headers"", ""--host"", ""0.0.0.0"", ""--port"", ""80""]\n```\n\n#### Docker 缓存\n\n这个`Dockerfile`中有一个重要的技巧，我们首先只单独复制包含依赖项的文件，而不是其余代码。 让我来告诉你这是为什么。\n\n```Dockerfile\nCOPY ./requirements.txt /code/requirements.txt\n```\n\nDocker之类的构建工具是通过增量的方式来构建这些容器镜像的。具体做法是从`Dockerfile`顶部开始，每一条指令生成的文件都是镜像的“一层”，同过把这些“层”一层一层地叠加到基础镜像上，最后我们就得到了最终的镜像。\n\nDocker 和类似工具在构建镜像时也会使用内部缓存，如果自上次构建容器镜像以来文件没有更改，那么它将重新使用上次创建的同一层，而不是再次复制文件并从头开始创建新层。\n\n仅仅避免文件的复制不一定会有太多速度提升，但是如果在这一步使用了缓存，那么才可以在下一步中使用缓存。 例如，可以使用安装依赖项那条指令的缓存：\n\n```Dockerfile\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n```\n\n包含包依赖项的文件不会频繁更改。 只复制该文件（不复制其他的应用代码），Docker 才能在这一步使用缓存。\n\nDocker 进而能使用缓存进行下一步，即下载并安装这些依赖项。 这才是我们节省大量时间的地方。 ✨ ...可以避免无聊的等待。 😪😆\n\n下载和安装依赖项可能需要几分钟，但使用缓存最多只需要几秒钟。\n\n由于你在开发过程中会一次又一次地构建容器镜像以检查代码更改是否有效，因此可以累计节省大量时间。\n\n在`Dockerfile`末尾附近，我们再添加复制代码的指令。 由于代码是更改最频繁的，所以将其放在最后，因为这一步之后的内容基本上都是无法使用缓存的。\n\n```Dockerfile\nCOPY ./app /code/app\n```\n\n### 构建 Docker 镜像\n\n现在所有文件都已就位，让我们构建容器镜像。\n\n* 转到项目目录（在`Dockerfile`所在的位置，包含`app`目录）。\n* 构建你的 FastAPI 镜像：\n\n```console\n$ docker build -t myimage .\n\n&gt; 100%\n```\n\n/// tip\n\n注意最后的 `.`，它相当于`./`，它告诉 Docker 用于构建容器镜像的目录。\n\n在本例中，它是相同的当前目录（`.`）。\n\n///\n\n### 启动 Docker 容器\n\n* 根据你的镜像运行容器：\n\n```console\n$ docker run -d --name mycontainer -p 80:80 myimage\n```\n\n## 检查一下\n\n你应该能在Docker容器的URL中检查它，例如: http://192.168.99.100/items/5?q=somequery 或 http://127.0.0.1/items/5?q=somequery (或其他等价的，使用 Docker 主机).\n\n你会看到类似内容：\n\n```JSON\n{""item_id"": 5, ""q"": ""somequery""}\n```\n\n## 交互式 API 文档\n\n现在你可以转到 http://192.168.99.100/docs 或 http://127.0.0.1/docs （或其他等价的，使用 Docker 主机）。\n\n你将看到自动交互式 API 文档（由 Swagger UI):\n\n![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)\n\n## 备选的 API 文档\n\n你还可以访问 http://192.168.99.100/redoc 或 http://127.0.0.1/redoc （或其他等价的，使用 Docker 主机）。\n\n你将看到备选的自动文档（由 ReDoc 提供）：\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)\n\n## 使用单文件 FastAPI 构建 Docker 镜像\n\n如果你的 FastAPI 是单个文件，例如没有`./app`目录的`main.py`，则你的文件结构可能如下所示：\n\n```\n.\n├── Dockerfile\n├── main.py\n└── requirements.txt\n```\n\n然后你只需更改相应的路径即可将文件复制到`Dockerfile`中：\n\n```{ .dockerfile .annotate hl_lines=""10  13"" }\nFROM python:3.9\n\nWORKDIR /code\n\nCOPY ./requirements.txt /code/requirements.txt\n\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\n# (1)\nCOPY ./main.py /code/\n\n# (2)\nCMD [""uvicorn"", ""main:app"", ""--host"", ""0.0.0.0"", ""--port"", ""80""]\n```\n\n1. 直接将`main.py`文件复制到`/code`目录中（不包含任何`./app`目录）。\n\n2. 运行 Uvicorn 并告诉它从 `main` 导入 `app` 对象（而不是从 `app.main` 导入）。\n\n然后调整Uvicorn命令使用新模块`main`而不是`app.main`来导入FastAPI 实例`app`。\n\n## 部署概念\n\n我们再谈谈容器方面的一些相同的[部署概念](concepts.md){.internal-link target=_blank}。\n\n容器主要是一种简化构建和部署应用程序的过程的工具，但它们并不强制执行特定的方法来处理这些部署概念，并且有几种可能的策略。\n\n好消息是，对于每种不同的策略，都有一种方法可以涵盖所有部署概念。 🎉\n\n让我们从容器的角度回顾一下这些部署概念：\n\n* HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 开始前的先前步骤\n\n## HTTPS\n\n如果我们只关注 FastAPI 应用程序的 容器镜像（以及稍后运行的 容器），HTTPS 通常会由另一个工具在 外部 处理。\n\n它可以是另一个容器，例如使用 Traefik，处理 HTTPS 和 自动获取证书。\n\n/// tip\n\nTraefik可以与 Docker、Kubernetes 等集成，因此使用它为容器设置和配置 HTTPS 非常容易。\n\n///\n\n或者，HTTPS 可以由云服务商作为其服务之一进行处理（同时仍在容器中运行应用程序）。\n\n## 在启动和重新启动时运行\n\n通常还有另一个工具负责启动和运行你的容器。\n\n它可以直接是Docker, 或者Docker Compose、Kubernetes、云服务等。\n\n在大多数（或所有）情况下，有一个简单的选项可以在启动时运行容器并在失败时重新启动。 例如，在 Docker 中，它是命令行选项 `--restart`。\n\n如果不使用容器，让应用程序在启动时运行并重新启动可能会很麻烦且困难。 但在大多数情况下，当使用容器时，默认情况下会包含该功能。 ✨\n\n## 复制 - 进程数\n\n如果你有一个 <abbr title=""一组配置为以某种方式连接并协同工作的计算机。"">集群</abbr>, 比如 Kubernetes、Docker Swarm、Nomad 或其他类似的复杂系统来管理多台机器上的分布式容器，那么你可能希望在集群级别处理复制，而不是在每个容器中使用进程管理器（如带有Worker的 Gunicorn） 。\n\n像 Kubernetes 这样的分布式容器管理系统通常有一些集成的方法来处理容器的复制，同时仍然支持传入请求的负载均衡。 全部都在集群级别。\n\n在这些情况下，你可能希望从头开始构建一个 Docker 镜像，如[上面所解释](#dockerfile)的那样，安装依赖项并运行 单个 Uvicorn 进程，而不是运行 Gunicorn 和 Uvicorn workers这种。\n\n### 负载均衡器\n\n使用容器时，通常会有一些组件监听主端口。 它可能是处理 HTTPS 的 TLS 终止代理 或一些类似的工具的另一个容器。\n\n由于该组件将接受请求的负载并（希望）以平衡的方式在worker之间分配该请求，因此它通常也称为负载均衡器。\n\n/// tip\n\n用于 HTTPS TLS 终止代理 的相同组件也可能是 负载均衡器。\n\n///\n\n当使用容器时，你用来启动和管理容器的同一系统已经具有内部工具来传输来自该负载均衡器（也可以是TLS 终止代理) 的网络通信（例如HTTP请求）到你的应用程序容器。\n\n### 一个负载均衡器 - 多个worker容器\n\n当使用 Kubernetes 或类似的分布式容器管理系统时，使用其内部网络机制将允许单个在主 端口 上侦听的 负载均衡器 将通信（请求）传输到可能的 多个 运行你应用程序的容器。\n\n运行你的应用程序的每个容器通常只有一个进程（例如，运行 FastAPI 应用程序的 Uvicorn 进程）。 它们都是相同的容器，运行相同的东西，但每个容器都有自己的进程、内存等。这样你就可以在 CPU 的不同核心， 甚至在不同的机器充分利用并行化(parallelization)。\n\n具有负载均衡器的分布式容器系统将将请求轮流分配给你的应用程序的每个容器。 因此，每个请求都可以由运行你的应用程序的多个复制容器之一来处理。\n\n通常，这个负载均衡器**能够处理发送到集群中的*其他*应用程序的请求（例如发送到不同的域，或在不同的 URL 路径前缀下），并正确地将该通信传输到在集群中运行的*其他*应用程序的对应容器。\n\n### 每个容器一个进程\n\n在这种类型的场景中，你可能希望每个容器有一个（Uvicorn）进程，因为你已经在集群级别处理复制。\n\n因此，在这种情况下，你不会希望拥有像 Gunicorn 和 Uvicorn worker一样的进程管理器，或者 Uvicorn 使用自己的 Uvicorn worker。 你可能希望每个容器（但可能有多个容器）只有一个单独的 Uvicorn 进程。\n\n在容器内拥有另一个进程管理器（就像使用 Gunicorn 或 Uvicorn 管理 Uvicorn 工作线程一样）只会增加不必要的复杂性，而你很可能已经在集群系统中处理这些复杂性了。\n\n### 具有多个进程的容器\n\n当然，在某些特殊情况，你可能希望拥有 一个容器，其中包含 Gunicorn 进程管理器，并在其中启动多个 Uvicorn worker进程。\n\n在这些情况下，你可以使用 官方 Docker 镜像，其中包含 Gunicorn 作为运行多个 Uvicorn 工作进程 的进程管理器，以及一些默认设置来根据当前情况调整工作进程数量 自动CPU核心。 我将在下面的 [Gunicorn - Uvicorn 官方 Docker 镜像](#official-docker-image-with-gunicorn-uvicorn) 中告诉你更多相关信息。\n\n下面一些什么时候这种做法有意义的示例：\n\n#### 一个简单的应用程序\n\n如果你的应用程序足够简单，你不需要（至少现在不需要）过多地微调进程数量，并且你可以使用自动默认值，那么你可能需要容器中的进程管理器 （使用官方 Docker 镜像），并且你在单个服务器而不是集群上运行它。\n\n#### Docker Compose\n\n你可以使用 Docker Compose 部署到单个服务器（而不是集群），因此你没有一种简单的方法来管理容器的复制（使用 Docker Compose），同时保留共享网络和 负载均衡。\n\n然后，你可能希望拥有一个单个容器，其中有一个进程管理器，在其中启动多个worker进程。\n\n#### Prometheus和其他原因\n\n你还可能有其他原因，这将使你更容易拥有一个带有多个进程的单个容器，而不是拥有每个容器中都有单个进程的多个容器。\n\n例如（取决于你的设置）你可以在同一个容器中拥有一些工具，例如 Prometheus exporter，该工具应该有权访问每个请求。\n\n在这种情况下，如果你有多个容器，默认情况下，当 Prometheus 来读取metrics时，它每次都会获取单个容器的metrics（对于处理该特定请求的容器），而不是获取所有复制容器的累积metrics。\n\n在这种情况， 这种做法会更加简单：让一个容器具有多个进程，并在同一个容器上使用本地工具（例如 Prometheus exporter）收集所有内部进程的 Prometheus 指标并公开单个容器上的这些指标。\n\n要点是，这些都不是你必须盲目遵循的一成不变的规则。 你可以根据这些思路评估你自己的场景并决定什么方法是最适合你的的系统，考虑如何管理以下概念：\n\n* 安全性 - HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 开始前的先前步骤\n\n## 内存\n\n如果你每个容器运行一个进程，那么每个容器所消耗的内存或多或少是定义明确的、稳定的且有限的（如果它们是复制的，则不止一个）。\n\n然后，你可以在容器管理系统的配置中设置相同的内存限制和要求（例如在 Kubernetes 中）。 这样，它将能够在可用机器中复制容器，同时考虑容器所需的内存量以及集群中机器中的可用内存量。\n\n如果你的应用程序很简单，这可能不是问题，并且你可能不需要指定内存限制。 但是，如果你使用大量内存（例如使用机器学习模型），则应该检查你消耗了多少内存并调整每台机器中运行的容器数量（也许可以向集群添加更多机器）。\n\n如果你每个容器运行多个进程（例如使用官方 Docker 镜像），你必须确保启动的进程数量不会消耗比可用内存更多的内存。\n\n## 启动之前的步骤和容器\n\n如果你使用容器（例如 Docker、Kubernetes），那么你可以使用两种主要方法。\n\n### 多个容器\n\n如果你有 多个容器，可能每个容器都运行一个 单个进程（例如，在 Kubernetes 集群中），那么你可能希望有一个 单独的容器 执行以下操作： 在单个容器中运行单个进程执行先前步骤，即运行复制的worker容器之前。\n\n/// info\n\n如果你使用 Kubernetes，这可能是 Init Container。\n\n///\n\n如果在你的用例中，运行前面的步骤并行多次没有问题（例如，如果你没有运行数据库迁移，而只是检查数据库是否已准备好），那么你也可以将它们放在开始主进程之前在每个容器中。\n\n### 单容器\n\n如果你有一个简单的设置，使用一个单个容器，然后启动多个工作进程（或者也只是一个进程），那么你可以在启动进程之前在应用程序同一个容器中运行先前的步骤。 官方 Docker 镜像内部支持这一点。\n\n## 带有 Gunicorn 的官方 Docker 镜像 - Uvicorn\n\n有一个官方 Docker 镜像，其中包含与 Uvicorn worker一起运行的 Gunicorn，如上一章所述：[服务器工作线程 - Gunicorn 与 Uvicorn](server-workers.md){.internal-link target=_blank}。\n\n该镜像主要在上述情况下有用：[具有多个进程和特殊情况的容器](#containers-with-multiple-processes-and-special-cases)。\n\n* tiangolo/uvicorn-gunicorn-fastapi.\n\n/// warning\n\n你很有可能不需要此基础镜像或任何其他类似的镜像，最好从头开始构建镜像，如[上面所述：为 FastAPI 构建 Docker 镜像](#build-a-docker-image-for-fastapi)。\n\n///\n\n该镜像包含一个自动调整机制，用于根据可用的 CPU 核心设置worker进程数。\n\n它具有合理的默认值，但你仍然可以使用环境变量或配置文件更改和更新所有配置。\n\n它还支持通过一个脚本运行开始前的先前步骤。\n\n/// tip\n\n要查看所有配置和选项，请转到 Docker 镜像页面： tiangolo/uvicorn-gunicorn-fastapi。\n\n///\n\n### 官方 Docker 镜像上的进程数\n\n此镜像上的进程数是根据可用的 CPU 核心自动计算的。\n\n这意味着它将尝试尽可能多地榨取CPU 的性能。\n\n你还可以使用 环境变量 等配置来调整它。\n\n但这也意味着，由于进程数量取决于容器运行的 CPU，因此消耗的内存量也将取决于该数量。\n\n因此，如果你的应用程序消耗大量内存（例如机器学习模型），并且你的服务器有很多 CPU 核心但内存很少，那么你的容器最终可能会尝试使用比实际情况更多的内存 可用，并且性能会下降很多（甚至崩溃）。 🚨\n\n### 创建一个`Dockerfile`\n\n以下是如何根据此镜像创建`Dockerfile`：\n\n```Dockerfile\nFROM tiangolo/uvicorn-gunicorn-fastapi:python3.9\n\nCOPY ./requirements.txt /app/requirements.txt\n\nRUN pip install --no-cache-dir --upgrade -r /app/requirements.txt\n\nCOPY ./app /app\n```\n\n### 更大的应用程序\n\n如果你按照有关创建[具有多个文件的更大应用程序](../tutorial/bigger-applications.md){.internal-link target=_blank}的部分进行操作，你的`Dockerfile`可能看起来这样：\n\n```Dockerfile hl_lines=""7""\nFROM tiangolo/uvicorn-gunicorn-fastapi:python3.9\n\nCOPY ./requirements.txt /app/requirements.txt\n\nRUN pip install --no-cache-dir --upgrade -r /app/requirements.txt\n\nCOPY ./app /app/app\n```\n\n### 何时使用\n\n如果你使用 Kubernetes （或其他）并且你已经在集群级别设置 复制，并且具有多个 容器。 在这些情况下，你最好按照上面的描述 从头开始构建镜像：[为 FastAPI 构建 Docker 镜像](#build-a-docker-image-for-fastapi)。\n\n该镜像主要在[具有多个进程的容器和特殊情况](#containers-with-multiple-processes-and-special-cases)中描述的特殊情况下有用。 例如，如果你的应用程序足够简单，基于 CPU 设置默认进程数效果很好，你不想在集群级别手动配置复制，并且不会运行更多进程,  或者你使用 Docker Compose 进行部署，在单个服务器上运行等。\n\n## 部署容器镜像\n\n拥有容器（Docker）镜像后，有多种方法可以部署它。\n\n例如：\n\n* 在单个服务器中使用 Docker Compose\n* 使用 Kubernetes 集群\n* 使用 Docker Swarm 模式集群\n* 使用Nomad等其他工具\n* 使用云服务获取容器镜像并部署它\n\n## Docker 镜像与Poetry\n\n如果你使用 Poetry 来管理项目的依赖项，你可以使用 Docker 多阶段构建：\n\n```{ .dockerfile .annotate }\n# (1)\nFROM python:3.9 as requirements-stage\n\n# (2)\nWORKDIR /tmp\n\n# (3)\nRUN pip install poetry\n\n# (4)\nCOPY ./pyproject.toml ./poetry.lock* /tmp/\n\n# (5)\nRUN poetry export -f requirements.txt --output requirements.txt --without-hashes\n\n# (6)\nFROM python:3.9\n\n# (7)\nWORKDIR /code\n\n# (8)\nCOPY --from=requirements-stage /tmp/requirements.txt /code/requirements.txt\n\n# (9)\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\n# (10)\nCOPY ./app /code/app\n\n# (11)\nCMD [""uvicorn"", ""app.main:app"", ""--host"", ""0.0.0.0"", ""--port"", ""80""]\n```\n\n1. 这是第一阶段，称为`requirements-stage`。\n\n2. 将 `/tmp` 设置为当前工作目录。\n\n     这是我们生成文件`requirements.txt`的地方\n\n3. 在此阶段安装Poetry。\n\n4. 将`pyproject.toml`和`poetry.lock`文件复制到`/tmp`目录。\n\n     因为它使用 `./poetry.lock*` （以 `*` 结尾），所以如果该文件尚不可用，它不会崩溃。\n\n5. 生成`requirements.txt`文件。\n\n6. 这是最后阶段，这里的任何内容都将保留在最终的容器镜像中。\n\n7. 将当前工作目录设置为`/code`。\n\n8. 将 `requirements.txt` 文件复制到 `/code` 目录。\n\n     该文件仅存在于前一个阶段，这就是为什么我们使用 `--from-requirements-stage` 来复制它。\n\n9. 安装生成的`requirements.txt`文件中的依赖项。\n\n10. 将`app`目录复制到`/code`目录。\n\n11. 运行`uvicorn`命令，告诉它使用从`app.main`导入的`app`对象。\n\n/// tip\n\n单击气泡数字可查看每行的作用。\n\n///\n\nDocker stage 是 `Dockerfile` 的一部分，用作 临时容器镜像，仅用于生成一些稍后使用的文件。\n\n第一阶段仅用于 安装 Poetry 并使用 Poetry 的 `pyproject.toml` 文件中的项目依赖项 生成 `requirements.txt`。\n\n此`requirements.txt`文件将在下一阶段与`pip`一起使用。\n\n在最终的容器镜像中仅保留最后阶段。 之前的阶段将被丢弃。\n\n使用 Poetry 时，使用 Docker 多阶段构建 是有意义的，因为你实际上并不需要在最终的容器镜像中安装 Poetry 及其依赖项，你 只需要 生成用于安装项目依赖项的`requirements.txt`文件。\n\n然后，在下一个（也是最后一个）阶段，你将或多或少地以与前面描述的相同的方式构建镜像。\n\n### 在TLS 终止代理后面 - Poetry\n\n同样，如果你在 Nginx 或 Traefik 等 TLS 终止代理（负载均衡器）后面运行容器，请将选项`--proxy-headers`添加到命令中：\n\n```Dockerfile\nCMD [""uvicorn"", ""app.main:app"", ""--proxy-headers"", ""--host"", ""0.0.0.0"", ""--port"", ""80""]\n```\n\n## 回顾\n\n使用容器系统（例如使用Docker和Kubernetes），处理所有部署概念变得相当简单：\n\n* HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 开始前的先前步骤\n\n在大多数情况下，你可能不想使用任何基础镜像，而是基于官方 Python Docker 镜像 从头开始构建容器镜像 。\n\n处理好`Dockerfile`和 Docker 缓存中指令的顺序，你可以最小化构建时间，从而最大限度地提高生产力（并避免无聊）。 😎\n\n在某些特殊情况下，你可能需要使用 FastAPI 的官方 Docker 镜像。 🤓', '# 手动运行服务器\n\n## 使用 `fastapi run` 命令\n\n简而言之，使用 `fastapi run` 来运行您的 FastAPI 应用程序：\n\n```console\n$ fastapi run main.py\n\n   FastAPI   Starting production server 🚀\n\n             Searching for package file structure from directories\n             with init.py files\n             Importing from /home/user/code/awesomeapp\n\n    module   🐍 main.py\n\n      code   Importing the FastAPI app object from the module with\n             the following code:\n\n             from main import app\n\n       app   Using import string: main:app\n\n    server   Server started at http://0.0.0.0:8000\n    server   Documentation at http://0.0.0.0:8000/docs\n\n             Logs:\n\n      INFO   Started server process [2306215]\n      INFO   Waiting for application startup.\n      INFO   Application startup complete.\n      INFO   Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C\n             to quit)\n```\n\n这在大多数情况下都能正常运行。😎\n\n例如，您可以使用该命令在容器、服务器等环境中启动您的 FastAPI 应用。\n\n## ASGI 服务器\n\n让我们深入了解一些细节。\n\nFastAPI 使用了一种用于构建 Python Web 框架和服务器的标准，称为 <abbr title=""Asynchronous Server Gateway Interface，异步服务器网关接口"">ASGI</abbr>。FastAPI 本质上是一个 ASGI Web 框架。\n\n要在远程服务器上运行 FastAPI 应用（或任何其他 ASGI 应用），您需要一个 ASGI 服务器程序，例如 Uvicorn。它是 `fastapi` 命令默认使用的 ASGI 服务器。\n\n除此之外，还有其他一些可选的 ASGI 服务器，例如：\n\n* Uvicorn：高性能 ASGI 服务器。\n* Hypercorn：与 HTTP/2 和 Trio 等兼容的 ASGI 服务器。\n* Daphne：为 Django Channels 构建的 ASGI 服务器。\n* Granian：基于 Rust 的 HTTP 服务器，专为 Python 应用设计。\n* NGINX Unit：NGINX Unit 是一个轻量级且灵活的 Web 应用运行时环境。\n\n## 服务器主机和服务器程序\n\n关于名称，有一个小细节需要记住。 💡\n\n“服务器”一词通常用于指远程/云计算机（物理机或虚拟机）以及在该计算机上运行的程序（例如 Uvicorn）。\n\n请记住，当您一般读到“服务器”这个名词时，它可能指的是这两者之一。\n\n当提到远程主机时，通常将其称为服务器，但也称为机器(machine)、VM（虚拟机）、节点。 这些都是指某种类型的远程计算机，通常运行 Linux，您可以在其中运行程序。\n\n## 安装服务器程序\n\n当您安装 FastAPI 时，它自带一个生产环境服务器——Uvicorn，并且您可以使用 `fastapi run` 命令来启动它。\n\n不过，您也可以手动安装 ASGI 服务器。\n\n请确保您创建并激活一个[虚拟环境](../virtual-environments.md){.internal-link target=_blank}，然后再安装服务器应用程序。\n\n例如，要安装 Uvicorn，可以运行以下命令：\n\n```console\n$ pip install ""uvicorn[standard]""\n\n&gt; 100%\n```\n\n类似的流程也适用于任何其他 ASGI 服务器程序。\n\n/// tip\n\n通过添加 `standard` 选项，Uvicorn 将安装并使用一些推荐的额外依赖项。\n\n其中包括 `uvloop`，这是 `asyncio` 的高性能替代方案，能够显著提升并发性能。\n\n当您使用 `pip install ""fastapi[standard]""` 安装 FastAPI 时，实际上也会安装 `uvicorn[standard]`。\n\n///\n\n## 运行服务器程序\n\n如果您手动安装了 ASGI 服务器，通常需要以特定格式传递一个导入字符串，以便服务器能够正确导入您的 FastAPI 应用：\n\n```console\n$ uvicorn main:app --host 0.0.0.0 --port 80\n\nINFO:     Uvicorn running on http://0.0.0.0:80 (Press CTRL+C to quit)\n```\n\n/// note\n\n命令 `uvicorn main:app` 的含义如下：\n\n* `main`：指的是 `main.py` 文件（即 Python “模块”）。\n* `app`：指的是 `main.py` 文件中通过 `app = FastAPI()` 创建的对象。\n\n它等价于以下导入语句：\n\n```Python\nfrom main import app\n```\n\n///\n\n每种 ASGI 服务器程序通常都会有类似的命令，您可以在它们的官方文档中找到更多信息。\n\n/// warning\n\nUvicorn 和其他服务器支持 `--reload` 选项，该选项在开发过程中非常有用。\n\n但 `--reload` 选项会消耗更多资源，且相对不稳定。\n\n它对于开发阶段非常有帮助，但在生产环境中不应该使用。\n\n///\n\n## 部署概念\n\n这些示例运行服务器程序（例如 Uvicorn），启动单个进程，在所有 IP（`0.0.0.0`）上监听预定义端口（例如`80`）。\n\n这是基本思路。 但您可能需要处理一些其他事情，例如：\n\n* 安全性 - HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 开始前的步骤\n\n在接下来的章节中，我将向您详细介绍每个概念、如何思考它们，以及一些具体示例以及处理它们的策略。 🚀', '# 服务器工作进程（Workers） - 使用 Uvicorn 的多工作进程模式\n\n让我们回顾一下之前的部署概念：\n\n* 安全性 - HTTPS\n* 启动时运行\n* 重新启动\n* 复制（运行的进程数）\n* 内存\n* 启动前的先前步骤\n\n到目前为止，在文档中的所有教程中，您可能一直是在运行一个服务器程序，例如使用 `fastapi` 命令来启动 Uvicorn，而它默认运行的是单进程模式。\n\n部署应用程序时，您可能希望进行一些进程复制，以利用多核 CPU 并能够处理更多请求。\n\n正如您在上一章有关[部署概念](concepts.md){.internal-link target=_blank}中看到的，您可以使用多种策略。\n\n在本章节中，我将向您展示如何使用 `fastapi` 命令或直接使用 `uvicorn` 命令以多工作进程模式运行 Uvicorn。\n\n/// info\n\n如果您正在使用容器，例如 Docker 或 Kubernetes，我将在下一章中告诉您更多相关信息：[容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank}。\n\n比较特别的是，在 Kubernetes 环境中运行时，您通常不需要使用多个工作进程，而是每个容器运行一个 Uvicorn 进程。不过，我会在本章节的后续部分详细介绍这一点。\n\n///\n\n## 多个工作进程\n\n您可以使用 `--workers` 命令行选项来启动多个工作进程：\n\n//// tab | `fastapi`\n\n如果您使用 `fastapi` 命令：\n\n```console\n$ fastapi run --workers 4 main.py\n\n   FastAPI   Starting production server 🚀\n\n             Searching for package file structure from directories with\n             init.py files\n             Importing from /home/user/code/awesomeapp\n\n    module   🐍 main.py\n\n      code   Importing the FastAPI app object from the module with the\n             following code:\n\n             from main import app\n\n       app   Using import string: main:app\n\n    server   Server started at http://0.0.0.0:8000\n    server   Documentation at http://0.0.0.0:8000/docs\n\n             Logs:\n\n      INFO   Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to\n             quit)\n      INFO   Started parent process [27365]\n      INFO   Started server process [27368]\n      INFO   Started server process [27369]\n      INFO   Started server process [27370]\n      INFO   Started server process [27367]\n      INFO   Waiting for application startup.\n      INFO   Waiting for application startup.\n      INFO   Waiting for application startup.\n      INFO   Waiting for application startup.\n      INFO   Application startup complete.\n      INFO   Application startup complete.\n      INFO   Application startup complete.\n      INFO   Application startup complete.\n```\n\n////\n\n//// tab | `uvicorn`\n\n如果您更想要直接使用 `uvicorn` 命令：\n\n```console\n$ uvicorn main:app --host 0.0.0.0 --port 8080 --workers 4\nINFO:     Uvicorn running on http://0.0.0.0:8080 (Press CTRL+C to quit)\nINFO:     Started parent process [27365]\nINFO:     Started server process [27368]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [27369]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [27370]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [27367]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```\n\n////\n\n这里唯一的新选项是 `--workers` 告诉 Uvicorn 启动 4 个工作进程。\n\n您还可以看到它显示了每个进程的 PID，父进程（这是进程管理器）的 PID 为`27365`，每个工作进程的 PID 为：`27368`、`27369`， `27370`和`27367`。\n\n## 部署概念\n\n在这里，您学习了如何使用多个工作进程（workers）来让应用程序的执行并行化，充分利用 CPU 的多核性能，并能够处理更多的请求。\n\n从上面的部署概念列表来看，使用worker主要有助于复制部分，并对重新启动有一点帮助，但您仍然需要照顾其他部分：\n\n* 安全 - HTTPS\n* 启动时运行\n* *重新启动*\n* 复制（运行的进程数）\n* 内存\n* 启动之前的先前步骤\n\n## 容器和 Docker\n\n在关于 [容器中的 FastAPI - Docker](docker.md){.internal-link target=_blank} 的下一章中，我将介绍一些可用于处理其他部署概念的策略。\n\n我将向您展示如何从零开始构建自己的镜像，以运行一个单独的 Uvicorn 进程。这个过程相对简单，并且在使用 Kubernetes 等分布式容器管理系统时，这通常是您需要采取的方法。\n\n## 回顾\n\n您可以在使用 `fastapi` 或 `uvicorn` 命令时，通过 `--workers` CLI 选项启用多个工作进程（workers），以充分利用多核 CPU，以并行运行多个进程。\n\n如果您要设置自己的部署系统，同时自己处理其他部署概念，则可以使用这些工具和想法。\n\n请查看下一章，了解带有容器（例如 Docker 和 Kubernetes）的 FastAPI。 您将看到这些工具也有简单的方法来解决其他部署概念。 ✨']",在生产环境中，通常建议使用Gunicorn配合Uvicorn，因为Gunicorn作为进程管理器能管理多个Uvicorn工作进程，提供负载均衡、进程监控和自动重启崩溃的Worker等生产级特性。而直接运行Uvicorn缺乏这些高级管理功能，尤其在处理高并发时稳定性较低。上下文指出，单进程Uvicorn在分布式系统（如Kubernetes）中可行，但Gunicorn的进程管理在单机部署或简单场景中更易保障可靠性。, Gunicorn 是一个成熟的进程管理器（Process Manager），而 Uvicorn 是一个高性能的 ASGI 服务器（Worker）。在生产环境中，Gunicorn 充当 Master 进程，负责监控、重启崩溃的子进程、处理信号量以及平滑重载代码；而 Uvicorn 负责在 Worker 进程内高效地解析异步网络协议。这种结合可以充分利用多核 CPU，并提供生产环境所需的稳定性、可伸缩性和容错性。,0.9999999999,0.5,0.8802820176159346
为什么我在路由中使用了 async def，但性能却变慢了（常见于阻塞性 IO 误用）？,"['# 并发 async / await\n\n有关路径操作函数的 `async def` 语法以及异步代码、并发和并行的一些背景知识。\n\n## 赶时间吗？\n\n<abbr title=""too long; didn\'t read(长文警告)"">TL;DR:</abbr>\n\n如果你正在使用第三方库，它们会告诉你使用 `await` 关键字来调用它们，就像这样：\n\n```Python\nresults = await some_library()\n```\n\n然后，通过 `async def` 声明你的 *路径操作函数*：\n\n```Python hl_lines=""2""\n@app.get(\'/\')\nasync def read_results():\n    results = await some_library()\n    return results\n```\n\n/// note\n\n你只能在被 `async def` 创建的函数内使用 `await`\n\n///\n\n如果你正在使用一个第三方库和某些组件（比如：数据库、API、文件系统...）进行通信，第三方库又不支持使用 `await` （目前大多数数据库三方库都是这样），这种情况你可以像平常那样使用 `def` 声明一个路径操作函数，就像这样：\n\n```Python hl_lines=""2""\n@app.get(\'/\')\ndef results():\n    results = some_library()\n    return results\n```\n\n如果你的应用程序不需要与其他任何东西通信而等待其响应，请使用 `async def`。\n\n如果你不清楚，使用 `def` 就好.\n\n注意：你可以根据需要在路径操作函数中混合使用 `def` 和 `async def`，并使用最适合你的方式去定义每个函数。FastAPI 将为他们做正确的事情。\n\n无论如何，在上述任何情况下，FastAPI 仍将异步工作，速度也非常快。\n\n但是，通过遵循上述步骤，它将能够进行一些性能优化。\n\n## 技术细节\n\nPython 的现代版本支持通过一种叫""协程""——使用 `async` 和 `await` 语法的东西来写”异步代码“。\n\n让我们在下面的部分中逐一介绍：\n\n* 异步代码\n* `async` 和 `await`\n* 协程\n\n## 异步代码\n\n异步代码仅仅意味着编程语言 💬 有办法告诉计算机/程序 🤖 在代码中的某个点，它 🤖 将不得不等待在某些地方完成一些事情。让我们假设一些事情被称为 ""慢文件""📝.\n\n所以，在等待""慢文件""📝完成的这段时间，计算机可以做一些其他工作。\n\n然后计算机/程序 🤖 每次有机会都会回来，因为它又在等待，或者它 🤖 完成了当前所有的工作。而且它 🤖 将查看它等待的所有任务中是否有已经完成的，做它必须做的任何事情。\n\n接下来，它 🤖 完成第一个任务（比如是我们的""慢文件""📝) 并继续与之相关的一切。\n\n这个""等待其他事情""通常指的是一些相对较慢（与处理器和 RAM 存储器的速度相比）的 <abbr title=""Input and Output"">I/O</abbr> 操作，比如说：\n\n* 通过网络发送来自客户端的数据\n* 客户端接收来自网络中的数据\n* 磁盘中要由系统读取并提供给程序的文件的内容\n* 程序提供给系统的要写入磁盘的内容\n* 一个 API 的远程调用\n* 一个数据库操作，直到完成\n* 一个数据库查询，直到返回结果\n* 等等.\n\n这个执行的时间大多是在等待 <abbr title=""Input and Output"">I/O</abbr> 操作，因此它们被叫做 ""I/O 密集型"" 操作。\n\n它被称为""异步""的原因是因为计算机/程序不必与慢任务""同步""，去等待任务完成的确切时刻，而在此期间不做任何事情直到能够获取任务结果才继续工作。\n\n相反，作为一个""异步""系统，一旦完成，任务就可以排队等待一段时间（几微秒），等待计算机程序完成它要做的任何事情，然后回来获取结果并继续处理它们。\n\n对于""同步""（与""异步""相反），他们通常也使用""顺序""一词，因为计算机程序在切换到另一个任务之前是按顺序执行所有步骤，即使这些步骤涉及到等待。\n\n### 并发与汉堡\n\n上述异步代码的思想有时也被称为“并发”，它不同于“并行”。\n\n并发和并行都与“不同的事情或多或少同时发生”有关。\n\n但是并发和并行之间的细节是完全不同的。\n\n要了解差异，请想象以下关于汉堡的故事：\n\n### 并发汉堡\n\n你和你的恋人一起去快餐店，你排队在后面，收银员从你前面的人接单。😍\n\n然后轮到你了，你为你的恋人和你选了两个非常豪华的汉堡。🍔🍔\n\n收银员对厨房里的厨师说了一些话，让他们知道他们必须为你准备汉堡（尽管他们目前正在为之前的顾客准备汉堡）。\n\n你付钱了。 💸\n\n收银员给你轮到的号码。\n\n当你在等待的时候，你和你的恋人一起去挑选一张桌子，然后你们坐下来聊了很长时间（因为汉堡很豪华，需要一些时间来准备）。\n\n当你和你的恋人坐在桌子旁，等待汉堡的时候，你可以用这段时间来欣赏你的恋人是多么的棒、可爱和聪明✨😍✨。\n\n在等待中和你的恋人交谈时，你会不时地查看柜台上显示的号码，看看是否已经轮到你了。\n\n然后在某个时刻，终于轮到你了。你去柜台拿汉堡然后回到桌子上。\n\n你们享用了汉堡，整个过程都很开心。✨\n\n/// info\n\n漂亮的插画来自 Ketrina Thompson. 🎨\n\n///\n\n在那个故事里，假设你是计算机程序 🤖 。\n\n当你在排队时，你只是闲着😴， 轮到你前不做任何事情（仅排队）。但排队很快，因为收银员只接订单（不准备订单），所以这一切都还好。\n\n然后，当轮到你时，需要你做一些实际性的工作，比如查看菜单，决定你想要什么，让你的恋人选择，支付，检查你是否提供了正确的账单或卡，检查你的收费是否正确，检查订单是否有正确的项目，等等。\n\n此时，即使你仍然没有汉堡，你和收银员的工作也""暂停""了⏸， 因为你必须等待一段时间 🕙 让你的汉堡做好。\n\n但是，当你离开柜台并坐在桌子旁，在轮到你的号码前的这段时间，你可以将焦点切换到 🔀 你的恋人上，并做一些""工作""⏯ 🤓。你可以做一些非常""有成效""的事情，比如和你的恋人调情😍.\n\n之后，收银员 💁 把号码显示在显示屏上，并说到 ""汉堡做好了""，而当显示的号码是你的号码时，你不会立刻疯狂地跳起来。因为你知道没有人会偷你的汉堡，因为你有你的号码，而其他人又有他们自己的号码。\n\n所以你要等待你的恋人完成故事（完成当前的工作⏯ /正在做的事🤓)， 轻轻微笑，说你要吃汉堡⏸.\n\n然后你去柜台🔀， 到现在初始任务已经完成⏯， 拿起汉堡，说声谢谢，然后把它们送到桌上。这就完成了与计数器交互的步骤/任务⏹. 这反过来又产生了一项新任务，即""吃汉堡""🔀 ⏯， 上一个""拿汉堡""的任务已经结束了⏹.\n\n### 并行汉堡\n\n现在让我们假设不是""并发汉堡""，而是""并行汉堡""。\n\n你和你的恋人一起去吃并行快餐。\n\n你站在队伍中，同时是厨师的几个收银员（比方说8个）从前面的人那里接单。\n\n你之前的每个人都在等待他们的汉堡准备好后才离开柜台，因为8名收银员都会在下一份订单前马上准备好汉堡。\n\n然后，终于轮到你了，你为你的恋人和你订购了两个非常精美的汉堡。\n\n你付钱了 💸。\n\n收银员去厨房。\n\n你站在柜台前 🕙等待着，这样就不会有人在你之前抢走你的汉堡，因为没有轮流的号码。\n\n当你和你的恋人忙于不让任何人出现在你面前，并且在他们到来的时候拿走你的汉堡时，你无法关注到你的恋人。😞\n\n这是""同步""的工作，你被迫与服务员/厨师 👨\u200d🍳""同步""。你在此必须等待 🕙 ，在收银员/厨师 👨\u200d🍳 完成汉堡并将它们交给你的确切时间到达之前一直等待，否则其他人可能会拿走它们。\n\n你经过长时间的等待 🕙 ，收银员/厨师 👨\u200d🍳终于带着汉堡回到了柜台。\n\n你拿着汉堡，和你的情人一起上桌。\n\n你们仅仅是吃了它们，就结束了。⏹\n\n没有太多的交谈或调情，因为大部分时间 🕙 都在柜台前等待😞。\n\n/// info\n\n漂亮的插画来自 Ketrina Thompson. 🎨\n\n///\n\n在这个并行汉堡的场景中，你是一个计算机程序 🤖 且有两个处理器（你和你的恋人），都在等待 🕙 ，并投入他们的注意力 ⏯ 在柜台上等待了很长一段时间。\n\n这家快餐店有 8 个处理器（收银员/厨师）。而并发汉堡店可能只有 2 个（一个收银员和一个厨师）。\n\n但最终的体验仍然不是最好的。😞\n\n这将是与汉堡的类似故事。🍔\n\n一种更""贴近生活""的例子，想象一家银行。\n\n直到最近，大多数银行都有多个出纳员 👨\u200d💼👨\u200d💼👨\u200d💼👨\u200d💼 还有一条长长排队队伍🕙🕙🕙🕙🕙🕙🕙🕙。\n\n所有收银员都是一个接一个的在客户面前做完所有的工作👨\u200d💼⏯.\n\n你必须经过 🕙 较长时间排队，否则你就没机会了。\n\n你可不会想带你的恋人 😍 和你一起去银行办事🏦.\n\n### 汉堡结论\n\n在""你与恋人一起吃汉堡""的这个场景中，因为有很多人在等待🕙， 使用并发系统更有意义⏸🔀⏯.\n\n大多数 Web 应用都是这样的。\n\n你的服务器正在等待很多很多用户通过他们不太好的网络发送来的请求。\n\n然后再次等待 🕙 响应回来。\n\n这个""等待"" 🕙 是以微秒为单位测量的，但总的来说，最后还是等待很久。\n\n这就是为什么使用异步对于 Web API 很有意义的原因 ⏸🔀⏯。\n\n这种异步机制正是 NodeJS 受到欢迎的原因（尽管 NodeJS 不是并行的），以及 Go 作为编程语言的优势所在。\n\n这与 FastAPI 的性能水平相同。\n\n你可以同时拥有并行性和异步性，你可以获得比大多数经过测试的 NodeJS 框架更高的性能，并且与 Go 不相上下， Go 是一种更接近于 C 的编译语言（全部归功于 Starlette）。\n\n### 并发比并行好吗？\n\n不！这不是故事的本意。\n\n并发不同于并行。而是在需要大量等待的特定场景下效果更好。因此，在 Web 应用程序开发中，它通常比并行要好得多，但这并不意味着全部。\n\n因此，为了平衡这一点，想象一下下面的短篇故事：\n\n&gt; 你必须打扫一个又大又脏的房子。\n\n*是的，这就是完整的故事。*\n\n在任何地方， 都不需要等待 🕙 ，只需要在房子的多个地方做着很多工作。\n\n你可以像汉堡的例子那样轮流执行，先是客厅，然后是厨房，但因为你不需要等待 🕙 ，对于任何事情都是清洁，清洁，还是清洁，轮流不会影响任何事情。\n\n无论是否轮流执行（并发），都需要相同的时间来完成，而你也会完成相同的工作量。\n\n但在这种情况下，如果你能带上 8 名前收银员/厨师，现在是清洁工一起清扫，他们中的每一个人（加上你）都能占据房子的一个区域来清扫，你就可以在额外的帮助下并行的更快地完成所有工作。\n\n在这个场景中，每个清洁工（包括你）都将是一个处理器，完成这个工作的一部分。\n\n由于大多数执行时间是由实际工作（而不是等待）占用的，并且计算机中的工作是由 <abbr title=""Central Processing Unit"">CPU</abbr> 完成的，所以他们称这些问题为""CPU 密集型""。\n\nCPU 密集型操作的常见示例是需要复杂的数学处理。\n\n例如：\n\n* 音频或图像处理；\n* 计算机视觉: 一幅图像由数百万像素组成，每个像素有3种颜色值，处理通常需要同时对这些像素进行计算；\n* 机器学习: 它通常需要大量的""矩阵""和""向量""乘法。想象一个包含数字的巨大电子表格，并同时将所有数字相乘；\n* 深度学习: 这是机器学习的一个子领域，同样适用。只是没有一个数字的电子表格可以相乘，而是一个庞大的数字集合，在很多情况下，你需要使用一个特殊的处理器来构建和使用这些模型。\n\n### 并发 + 并行: Web + 机器学习\n\n使用 FastAPI，你可以利用 Web 开发中常见的并发机制的优势（NodeJS 的主要吸引力）。\n\n并且，你也可以利用并行和多进程（让多个进程并行运行）的优点来处理与机器学习系统中类似的 CPU 密集型 工作。\n\n这一点，再加上 Python 是数据科学、机器学习（尤其是深度学习）的主要语言这一简单事实，使得 FastAPI 与数据科学/机器学习 Web API 和应用程序（以及其他许多应用程序）非常匹配。\n\n了解如何在生产环境中实现这种并行性，可查看此文 [Deployment](deployment/index.md){.internal-link target=_blank}。\n\n## `async` 和 `await`\n\n现代版本的 Python 有一种非常直观的方式来定义异步代码。这使它看起来就像正常的""顺序""代码，并在适当的时候""等待""。\n\n当有一个操作需要等待才能给出结果，且支持这个新的 Python 特性时，你可以编写如下代码：\n\n```Python\nburgers = await get_burgers(2)\n```\n\n这里的关键是 `await`。它告诉 Python 它必须等待 ⏸ `get_burgers(2)` 完成它的工作 🕙 ，然后将结果存储在 `burgers` 中。这样，Python 就会知道此时它可以去做其他事情 🔀 ⏯ （比如接收另一个请求）。\n\n要使 `await` 工作，它必须位于支持这种异步机制的函数内。因此，只需使用 `async def` 声明它：\n\n```Python hl_lines=""1""\nasync def get_burgers(number: int):\n    # Do some asynchronous stuff to create the burgers\n    return burgers\n```\n\n...而不是 `def`:\n\n```Python hl_lines=""2""\n# This is not asynchronous\ndef get_sequential_burgers(number: int):\n    # Do some sequential stuff to create the burgers\n    return burgers\n```\n\n使用 `async def`，Python 就知道在该函数中，它将遇上 `await`，并且它可以""暂停"" ⏸ 执行该函数，直至执行其他操作 🔀 后回来。\n\n当你想调用一个 `async def` 函数时，你必须""等待""它。因此，这不会起作用：\n\n```Python\n# This won\'t work, because get_burgers was defined with: async def\nburgers = get_burgers(2)\n```\n\n因此，如果你使用的库告诉你可以使用 `await` 调用它，则需要使用 `async def` 创建路径操作函数 ，如：\n\n```Python hl_lines=""2-3""\n@app.get(\'/burgers\')\nasync def read_burgers():\n    burgers = await get_burgers(2)\n    return burgers\n```\n\n### 更多技术细节\n\n你可能已经注意到，`await` 只能在 `async def` 定义的函数内部使用。\n\n但与此同时，必须""等待""通过 `async def` 定义的函数。因此，带 `async def` 的函数也只能在 `async def` 定义的函数内部调用。\n\n那么，这关于先有鸡还是先有蛋的问题，如何调用第一个 `async` 函数？\n\n如果你使用 FastAPI，你不必担心这一点，因为""第一个""函数将是你的路径操作函数，FastAPI 将知道如何做正确的事情。\n\n但如果你想在没有 FastAPI 的情况下使用 `async` / `await`，则可以这样做。\n\n### 编写自己的异步代码\n\nStarlette （和 FastAPI） 是基于 AnyIO 实现的，这使得它们可以兼容 Python 的标准库 asyncio 和 Trio。\n\n特别是，你可以直接使用 AnyIO 来处理高级的并发用例，这些用例需要在自己的代码中使用更高级的模式。\n\n即使你没有使用 FastAPI，你也可以使用 AnyIO 编写自己的异步程序，使其拥有较高的兼容性并获得一些好处（例如， 结构化并发）。\n\n我（指原作者 —— 译者注）基于 AnyIO 新建了一个库，作为一个轻量级的封装层，用来优化类型注解，同时提供了更好的自动补全、内联错误提示等功能。这个库还附带了一个友好的入门指南和教程，能帮助你理解并编写自己的异步代码：Asyncer。如果你有结合使用异步代码和常规（阻塞/同步）代码的需求，这个库会特别有用。\n\n### 其他形式的异步代码\n\n这种使用 `async` 和 `await` 的风格在语言中相对较新。\n\n但它使处理异步代码变得容易很多。\n\n这种相同的语法（或几乎相同）最近也包含在现代版本的 JavaScript 中（在浏览器和 NodeJS 中）。\n\n但在此之前，处理异步代码非常复杂和困难。\n\n在以前版本的 Python，你可以使用多线程或者 Gevent。但代码的理解、调试和思考都要复杂许多。\n\n在以前版本的 NodeJS / 浏览器 JavaScript 中，你会使用""回调""，因此也可能导致“回调地狱”。\n\n## 协程\n\n协程只是 `async def` 函数返回的一个非常奇特的东西的称呼。Python 知道它有点像一个函数，它可以启动，也会在某个时刻结束，而且它可能会在内部暂停 ⏸ ，只要内部有一个 `await`。\n\n通过使用 `async` 和 `await` 的异步代码的所有功能大多数被概括为""协程""。它可以与 Go 的主要关键特性 ""Goroutines"" 相媲美。\n\n## 结论\n\n让我们再来回顾下上文所说的：\n\n&gt; Python 的现代版本可以通过使用 `async` 和 `await` 语法创建协程，并用于支持异步代码。\n\n现在应该能明白其含义了。✨\n\n所有这些使得 FastAPI（通过 Starlette）如此强大，也是它拥有如此令人印象深刻的性能的原因。\n\n## 非常技术性的细节\n\n/// warning\n\n你可以跳过这里。\n\n这些都是 FastAPI 如何在内部工作的技术细节。\n\n如果你有相当多的技术知识（协程、线程、阻塞等），并且对 FastAPI 如何处理 `async def` 与常规 `def` 感到好奇，请继续。\n\n///\n\n### 路径操作函数\n\n当你使用 `def` 而不是 `async def` 来声明一个*路径操作函数*时，它运行在外部的线程池中并等待其结果，而不是直接调用（因为它会阻塞服务器）。\n\n如果你使用过另一个不以上述方式工作的异步框架，并且你习惯于用普通的 `def` 定义普通的仅计算路径操作函数，以获得微小的性能增益（大约100纳秒），请注意，在 FastAPI 中，效果将完全相反。在这些情况下，最好使用 `async def`，除非路径操作函数内使用执行阻塞 <abbr title=""输入/输出：磁盘读写，网络通讯."">I/O</abbr> 的代码。\n\n在这两种情况下，与你之前的框架相比，FastAPI 可能[仍然很快](index.md#_11){.internal-link target=_blank}。\n\n### 依赖\n\n这同样适用于[依赖](tutorial/dependencies/index.md){.internal-link target=_blank}。如果一个依赖是标准的 `def` 函数而不是 `async def`，它将被运行在外部线程池中。\n\n### 子依赖\n\n你可以拥有多个相互依赖的依赖以及[子依赖](tutorial/dependencies/sub-dependencies.md){.internal-link target=_blank} （作为函数的参数），它们中的一些可能是通过 `async def` 声明，也可能是通过 `def` 声明。它们仍然可以正常工作，这些通过 `def` 声明的函数将会在外部线程中调用（来自线程池），而不是""被等待""。\n\n### 其他函数\n\n你可直接调用通过 `def` 或 `async def` 创建的任何其他函数，FastAPI 不会影响你调用它们的方式。\n\n这与 FastAPI 为你调用*路径操作函数*和依赖项的逻辑相反。\n\n如果你的函数是通过 `def` 声明的，它将被直接调用（在代码中编写的地方），而不会在线程池中，如果这个函数通过 `async def` 声明，当在代码中调用时，你就应该使用 `await` 等待函数的结果。\n\n再次提醒，这些是非常技术性的细节，如果你来搜索它可能对你有用。\n\n否则，你最好应该遵守的指导原则赶时间吗？.']","根据上下文，你在路由中使用 `async def` 但性能变慢，通常是因为**在异步函数内误用了阻塞性 I/O 操作**，例如：  
1. 若第三方库（如数据库驱动）**不支持异步调用**（未提供 `await` 接口），在 `async def` 中直接调用会阻塞事件循环，导致性能下降。  
2. 此时应改用 `def` 声明路由函数（框架会将其放入线程池处理），或确保所有 I/O 操作均通过 `await` 调用真正的异步库。  

若不确定库是否支持异步，上下文建议优先使用 `def`。",这是因为在 async def 定义的路由中使用了阻塞性（Blocking）代码。由于 async 路由运行在单线程的事件循环（Event Loop）上，一旦执行了如 time.sleep()、同步数据库驱动查询或同步 HTTP 请求等操作，整个线程会被独占。这意味着在阻塞完成前，服务器无法处理任何其他请求，导致并发性能降为 1。在这种情况下，应将路由改为普通 def，让 FastAPI 将其分发到线程池处理。,0.9999999999,0.8571428571428571,0.8404446879564128
在 FastAPI 中，多个依赖项（Nested Dependencies）的执行顺序是怎样的？,"['# 子依赖项\n\nFastAPI 支持创建含子依赖项的依赖项。\n\n并且，可以按需声明任意深度的子依赖项嵌套层级。\n\nFastAPI 负责处理解析不同深度的子依赖项。\n\n### 第一层依赖项\n\n下列代码创建了第一层依赖项：\n\n\n```py\nfrom typing import Annotated, Union\n\nfrom fastapi import Cookie, Depends, FastAPI\n\napp = FastAPI()\n\n\ndef query_extractor(q: Union[str, None] = None):\n    return q\n\n\ndef query_or_cookie_extractor(\n    q: Annotated[str, Depends(query_extractor)],\n    last_query: Annotated[Union[str, None], Cookie()] = None,\n):\n    if not q:\n        return last_query\n    return q\n\n\n@app.get(""/items/"")\nasync def read_query(\n    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],\n):\n    return {""q_or_cookie"": query_or_default}\n\n```\n\n\n这段代码声明了类型为 `str` 的可选查询参数 `q`，然后返回这个查询参数。\n\n这个函数很简单（不过也没什么用），但却有助于让我们专注于了解子依赖项的工作方式。\n\n### 第二层依赖项\n\n接下来，创建另一个依赖项函数，并同时用该依赖项自身再声明一个依赖项（所以这也是一个「依赖项」）：\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n这里重点说明一下声明的参数：\n\n* 尽管该函数自身是依赖项，但还声明了另一个依赖项（它「依赖」于其他对象）\n    * 该函数依赖 `query_extractor`, 并把 `query_extractor` 的返回值赋给参数 `q`\n* 同时，该函数还声明了类型是 `str` 的可选 cookie（`last_query`）\n    * 用户未提供查询参数 `q` 时，则使用上次使用后保存在 cookie 中的查询\n\n### 使用依赖项\n\n接下来，就可以使用依赖项：\n\n\n> *[Ref: Code file `tutorial005_an_py39.py` is already included above]*\n\n\n/// info | 信息\n\n注意，这里在*路径操作函数*中只声明了一个依赖项，即 `query_or_cookie_extractor` 。\n\n但 FastAPI 必须先处理 `query_extractor`，以便在调用 `query_or_cookie_extractor` 时使用 `query_extractor` 返回的结果。\n\n///\n\n```mermaid\ngraph TB\n\nquery_extractor([""query_extractor""])\nquery_or_cookie_extractor([""query_or_cookie_extractor""])\n\nread_query[""/items/""]\n\nquery_extractor --&gt; query_or_cookie_extractor --&gt; read_query\n```\n\n## 多次使用同一个依赖项\n\n如果在同一个*路径操作* 多次声明了同一个依赖项，例如，多个依赖项共用一个子依赖项，FastAPI 在处理同一请求时，只调用一次该子依赖项。\n\nFastAPI 不会为同一个请求多次调用同一个依赖项，而是把依赖项的返回值进行<abbr title=""一个实用程序/系统来存储计算/生成的值，以便重用它们，而不是再次计算它们。"">「缓存」</abbr>，并把它传递给同一请求中所有需要使用该返回值的「依赖项」。\n\n在高级使用场景中，如果不想使用「缓存」值，而是为需要在同一请求的每一步操作（多次）中都实际调用依赖项，可以把 `Depends` 的参数 `use_cache` 的值设置为 `False` :\n\n```Python hl_lines=""1""\nasync def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):\n    return {""fresh_value"": fresh_value}\n```\n\n## 小结\n\n千万别被本章里这些花里胡哨的词藻吓倒了，其实依赖注入系统非常简单。\n\n依赖注入无非是与*路径操作函数*一样的函数罢了。\n\n但它依然非常强大，能够声明任意嵌套深度的「图」或树状的依赖结构。\n\n/// tip | 提示\n\n这些简单的例子现在看上去虽然没有什么实用价值，\n\n但在安全一章中，您会了解到这些例子的用途，\n\n以及这些例子所能节省的代码量。\n\n///', '# 使用yield的依赖项\n\nFastAPI支持在完成后执行一些<abbr title=\'有时也被称为""退出""(""exit"")，""清理""(""cleanup"")，""拆卸""(""teardown"")，""关闭""(""close"")，""上下文管理器""(""context managers"")。 ...\'>额外步骤</abbr>的依赖项.\n\n为此，你需要使用 `yield` 而不是 `return`，然后再编写这些额外的步骤（代码）。\n\n/// tip | 提示\n\n确保在每个依赖中只使用一次 `yield`。\n\n///\n\n/// note | 技术细节\n\n任何一个可以与以下内容一起使用的函数：\n\n* `@contextlib.contextmanager` 或者\n* `@contextlib.asynccontextmanager`\n\n都可以作为 FastAPI 的依赖项。\n\n实际上，FastAPI内部就使用了这两个装饰器。\n\n///\n\n## 使用 `yield` 的数据库依赖项\n\n例如，你可以使用这种方式创建一个数据库会话，并在完成后关闭它。\n\n在发送响应之前，只会执行 `yield` 语句及之前的代码：\n\n\n```py\nasync def get_db():\n    db = DBSession()\n    try:\n        yield db\n    finally:\n        db.close()\n\n```\n\n\n生成的值会注入到 *路由函数* 和其他依赖项中：\n\n\n> *[Ref: Code file `tutorial007_py39.py` is already included above]*\n\n\n`yield` 语句后面的代码会在创建响应后，发送响应前执行：\n\n\n> *[Ref: Code file `tutorial007_py39.py` is already included above]*\n\n\n/// tip | 提示\n\n你可以使用 `async` 或普通函数。\n\nFastAPI 会像处理普通依赖一样，对每个依赖做正确的处理。\n\n///\n\n## 包含 `yield` 和 `try` 的依赖项\n\n如果在包含 `yield` 的依赖中使用 `try` 代码块，你会捕获到使用依赖时抛出的任何异常。\n\n例如，如果某段代码在另一个依赖中或在 *路由函数* 中使数据库事务""回滚""或产生任何其他错误，你将会在依赖中捕获到异常。\n\n因此，你可以使用 `except SomeException` 在依赖中捕获特定的异常。\n\n同样，你也可以使用 `finally` 来确保退出步骤得到执行，无论是否存在异常。\n\n\n> *[Ref: Code file `tutorial007_py39.py` is already included above]*\n\n## 使用 `yield` 的子依赖项\n\n你可以声明任意数量和层级的树状依赖，而且它们中的任何一个或所有的都可以使用 `yield`。\n\nFastAPI 会确保每个带有 `yield` 的依赖中的""退出代码""按正确顺序运行。\n\n例如，`dependency_c` 可以依赖于 `dependency_b`，而 `dependency_b` 则依赖于 `dependency_a`。\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import Depends\n\n\nasync def dependency_a():\n    dep_a = generate_dep_a()\n    try:\n        yield dep_a\n    finally:\n        dep_a.close()\n\n\nasync def dependency_b(dep_a: Annotated[DepA, Depends(dependency_a)]):\n    dep_b = generate_dep_b()\n    try:\n        yield dep_b\n    finally:\n        dep_b.close(dep_a)\n\n\nasync def dependency_c(dep_b: Annotated[DepB, Depends(dependency_b)]):\n    dep_c = generate_dep_c()\n    try:\n        yield dep_c\n    finally:\n        dep_c.close(dep_b)\n\n```\n\n\n所有这些依赖都可以使用 `yield`。\n\n在这种情况下，`dependency_c` 在执行其退出代码时需要 `dependency_b`（此处称为 `dep_b`）的值仍然可用。\n\n而 `dependency_b` 反过来则需要 `dependency_a`（此处称为 `dep_a` ）的值在其退出代码中可用。\n\n\n> *[Ref: Code file `tutorial008_an_py39.py` is already included above]*\n\n\n同样，你可以混合使用带有 `yield` 或 `return` 的依赖。\n\n你也可以声明一个依赖于多个带有 `yield` 的依赖，等等。\n\n你可以拥有任何你想要的依赖组合。\n\nFastAPI 将确保按正确的顺序运行所有内容。\n\n/// note | 技术细节\n\n这是由 Python 的上下文管理器完成的。\n\nFastAPI 在内部使用它们来实现这一点。\n\n///\n\n## 包含 `yield` 和 `HTTPException` 的依赖项\n\n你可以使用带有 `yield` 的依赖项，并且可以包含 `try` 代码块用于捕获异常。\n\n同样，你可以在 `yield` 之后的退出代码中抛出一个 `HTTPException` 或类似的异常。\n\n/// tip | 提示\n\n这是一种相对高级的技巧，在大多数情况下你并不需要使用它，因为你可以在其他代码中抛出异常（包括 `HTTPException` ），例如在 *路由函数* 中。\n\n但是如果你需要，你也可以在依赖项中做到这一点。🤓\n\n///\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException\n\napp = FastAPI()\n\n\ndata = {\n    ""plumbus"": {""description"": ""Freshly pickled plumbus"", ""owner"": ""Morty""},\n    ""portal-gun"": {""description"": ""Gun to create portals"", ""owner"": ""Rick""},\n}\n\n\nclass OwnerError(Exception):\n    pass\n\n\ndef get_username():\n    try:\n        yield ""Rick""\n    except OwnerError as e:\n        raise HTTPException(status_code=400, detail=f""Owner error: {e}"")\n\n\n@app.get(""/items/{item_id}"")\ndef get_item(item_id: str, username: Annotated[str, Depends(get_username)]):\n    if item_id not in data:\n        raise HTTPException(status_code=404, detail=""Item not found"")\n    item = data[item_id]\n    if item[""owner""] != username:\n        raise OwnerError(username)\n    return item\n\n```\n\n\n你还可以创建一个 [自定义异常处理器](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank} 用于捕获异常（同时也可以抛出另一个 `HTTPException`）。\n\n## 包含 `yield` 和 `except` 的依赖项\n\n如果你在包含 `yield` 的依赖项中使用 `except` 捕获了一个异常，然后你没有重新抛出该异常（或抛出一个新异常），与在普通的Python代码中相同，FastAPI不会注意到发生了异常。\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException\n\napp = FastAPI()\n\n\nclass InternalError(Exception):\n    pass\n\n\ndef get_username():\n    try:\n        yield ""Rick""\n    except InternalError:\n        print(""Oops, we didn\'t raise again, Britney 😱"")\n\n\n@app.get(""/items/{item_id}"")\ndef get_item(item_id: str, username: Annotated[str, Depends(get_username)]):\n    if item_id == ""portal-gun"":\n        raise InternalError(\n            f""The portal gun is too dangerous to be owned by {username}""\n        )\n    if item_id != ""plumbus"":\n        raise HTTPException(\n            status_code=404, detail=""Item not found, there\'s only a plumbus here""\n        )\n    return item_id\n\n```\n\n\n在示例代码的情况下，客户端将会收到 *HTTP 500 Internal Server Error* 的响应，因为我们没有抛出 `HTTPException` 或者类似的异常，并且服务器也 不会有任何日志 或者其他提示来告诉我们错误是什么。😱\n\n### 在包含 `yield` 和 `except` 的依赖项中一定要 `raise`\n\n如果你在使用 `yield` 的依赖项中捕获到了一个异常，你应该再次抛出捕获到的异常，除非你抛出 `HTTPException` 或类似的其他异常，\n\n你可以使用 `raise` 再次抛出捕获到的异常。\n\n\n```py\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, HTTPException\n\napp = FastAPI()\n\n\nclass InternalError(Exception):\n    pass\n\n\ndef get_username():\n    try:\n        yield ""Rick""\n    except InternalError:\n        print(""We don\'t swallow the internal error here, we raise again 😎"")\n        raise\n\n\n@app.get(""/items/{item_id}"")\ndef get_item(item_id: str, username: Annotated[str, Depends(get_username)]):\n    if item_id == ""portal-gun"":\n        raise InternalError(\n            f""The portal gun is too dangerous to be owned by {username}""\n        )\n    if item_id != ""plumbus"":\n        raise HTTPException(\n            status_code=404, detail=""Item not found, there\'s only a plumbus here""\n        )\n    return item_id\n\n```\n\n\n现在客户端同样会得到 *HTTP 500 Internal Server Error* 响应，但是服务器日志会记录下我们自定义的 `InternalError`。\n\n##  使用 `yield` 的依赖项的执行\n\n执行顺序大致如下时序图所示。时间轴从上到下，每一列都代表交互或者代码执行的一部分。\n\n```mermaid\nsequenceDiagram\n\nparticipant client as Client\nparticipant handler as Exception handler\nparticipant dep as Dep with yield\nparticipant operation as Path Operation\nparticipant tasks as Background tasks\n\n    Note over client,operation: Can raise exceptions, including HTTPException\n    client -&gt;&gt; dep: Start request\n    Note over dep: Run code up to yield\n    opt raise Exception\n        dep --&gt;&gt; handler: Raise Exception\n        handler --&gt;&gt; client: HTTP error response\n    end\n    dep -&gt;&gt; operation: Run dependency, e.g. DB session\n    opt raise\n        operation --&gt;&gt; dep: Raise Exception (e.g. HTTPException)\n        opt handle\n            dep --&gt;&gt; dep: Can catch exception, raise a new HTTPException, raise other exception\n        end\n        handler --&gt;&gt; client: HTTP error response\n    end\n\n    operation -&gt;&gt; client: Return response to client\n    Note over client,operation: Response is already sent, can\'t change it anymore\n    opt Tasks\n        operation --&gt;&gt; tasks: Send background tasks\n    end\n    opt Raise other exception\n        tasks --&gt;&gt; tasks: Handle exceptions in the background task code\n    end\n```\n\n/// info | 说明\n\n只会向客户端发送 一次响应 ，可能是一个错误响应，也可能是来自 *路由函数* 的响应。\n\n在发送了其中一个响应之后，就无法再发送其他响应了。\n\n///\n\n/// tip | 提示\n\n这个时序图展示了 `HTTPException`，除此之外你也可以抛出任何你在使用 `yield` 的依赖项中或者[自定义异常处理器](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}中捕获的异常。\n\n如果你引发任何异常，它将传递给使用 `yield` 的依赖项，包括 `HTTPException`。在大多数情况下你应当从使用 `yield` 的依赖项中重新抛出捕获的异常或者一个新的异常来确保它会被正确的处理。\n\n///\n\n## 包含 `yield`, `HTTPException`, `except` 的依赖项和后台任务\n\n/// warning | 注意\n\n你大概率不需要了解这些技术细节，可以跳过这一章节继续阅读后续的内容。\n\n如果你使用的FastAPI的版本早于0.106.0，并且在使用后台任务中使用了包含 `yield` 的依赖项中的资源，那么这些细节会对你有一些用处。\n\n///\n\n### 包含 `yield` 和 `except` 的依赖项的技术细节\n\n在FastAPI 0.110.0版本之前，如果使用了一个包含 `yield` 的依赖项，你在依赖项中使用 `except` 捕获了一个异常，但是你没有再次抛出该异常，这个异常会被自动抛出/转发到异常处理器或者内部服务错误处理器。\n\n### 后台任务和使用 `yield` 的依赖项的技术细节\n\n在FastAPI 0.106.0版本之前，在 `yield` 后面抛出异常是不可行的，因为 `yield` 之后的退出代码是在响应被发送之后再执行，这个时候异常处理器已经执行过了。\n\n这样设计的目的主要是为了允许在后台任务中使用被依赖项`yield`的对象，因为退出代码会在后台任务结束后再执行。\n\n然而这也意味着在等待响应通过网络传输的同时，非必要的持有一个 `yield` 依赖项中的资源（例如数据库连接），这一行为在FastAPI 0.106.0被改变了。\n\n/// tip | 提示\n\n除此之外，后台任务通常是一组独立的逻辑，应该被单独处理，并且使用它自己的资源（例如它自己的数据库连接）。\n\n这样也会让你的代码更加简洁。\n\n///\n\n如果你之前依赖于这一行为，那么现在你应该在后台任务中创建并使用它自己的资源，不要在内部使用属于 `yield` 依赖项的资源。\n\n例如，你应该在后台任务中创建一个新的数据库会话用于查询数据，而不是使用相同的会话。你应该将对象的ID作为参数传递给后台任务函数，然后在该函数中重新获取该对象，而不是直接将数据库对象作为参数。\n\n## 上下文管理器\n\n### 什么是""上下文管理器""\n\n""上下文管理器""是你可以在 `with` 语句中使用的任何Python对象。\n\n例如，你可以使用`with`读取文件：\n\n```Python\nwith open(""./somefile.txt"") as f:\n    contents = f.read()\n    print(contents)\n```\n\n在底层，`open(""./somefile.txt"")`创建了一个被称为""上下文管理器""的对象。\n\n当 `with` 代码块结束时，它会确保关闭文件，即使发生了异常也是如此。\n\n当你使用 `yield` 创建一个依赖项时，FastAPI 会在内部将其转换为上下文管理器，并与其他相关工具结合使用。\n\n### 在使用 `yield` 的依赖项中使用上下文管理器\n\n/// warning | 注意\n\n这是一个更为""高级""的想法。\n\n如果你刚开始使用 FastAPI ，你可以暂时可以跳过它。\n\n///\n\n在Python中，你可以通过创建一个带有`enter()`和`exit()`方法的类来创建上下文管理器。\n\n你也可以在 FastAPI 的 `yield` 依赖项中通过 `with` 或者 `async with` 语句来使用它们：\n\n\n```py\nclass MySuperContextManager:\n    def __init__(self):\n        self.db = DBSession()\n\n    def __enter__(self):\n        return self.db\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.db.close()\n\n\nasync def get_db():\n    with MySuperContextManager() as db:\n        yield db\n\n```\n\n\n/// tip | 提示\n\n另一种创建上下文管理器的方法是：\n\n* `@contextlib.contextmanager`或者\n* `@contextlib.asynccontextmanager`\n\n使用它们装饰一个只有单个 `yield` 的函数。这就是 FastAPI 内部对于 `yield` 依赖项的处理方式。\n\n但是你不需要为FastAPI的依赖项使用这些装饰器（而且也不应该）。FastAPI会在内部为你处理这些。\n\n///', '# 依赖项\n\nFastAPI 提供了简单易用，但功能强大的<abbr title=""也称为组件、资源、提供者、服务、可注入项"">依赖注入</abbr>系统。\n\n这个依赖系统设计的简单易用，可以让开发人员轻松地把组件集成至 FastAPI。\n\n## 什么是「依赖注入」\n\n编程中的「依赖注入」是声明代码（本文中为*路径操作函数* ）运行所需的，或要使用的「依赖」的一种方式。\n\n然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n\n依赖注入常用于以下场景：\n\n* 共享业务逻辑（复用相同的代码逻辑）\n* 共享数据库连接\n* 实现安全、验证、角色权限\n* 等……\n\n上述场景均可以使用依赖注入，将代码重复最小化。\n\n## 第一步\n\n接下来，我们学习一个非常简单的例子，尽管它过于简单，不是很实用。\n\n但通过这个例子，您可以初步了解「依赖注入」的工作机制。\n\n### 创建依赖项\n\n首先，要关注的是依赖项。\n\n依赖项就是一个函数，且可以使用与*路径操作函数*相同的参数：\n\n\n```py\nfrom typing import Annotated, Union\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(\n    q: Union[str, None] = None, skip: int = 0, limit: int = 100\n):\n    return {""q"": q, ""skip"": skip, ""limit"": limit}\n\n\n@app.get(""/items/"")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n\n@app.get(""/users/"")\nasync def read_users(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n\n```\n\n\n大功告成。\n\n只用了2 行代码。\n\n依赖项函数的形式和结构与*路径操作函数*一样。\n\n因此，可以把依赖项当作没有「装饰器」（即，没有 `@app.get(""/some-path"")` ）的路径操作函数。\n\n依赖项可以返回各种内容。\n\n本例中的依赖项预期接收如下参数：\n\n* 类型为 `str` 的可选查询参数 `q`\n* 类型为 `int` 的可选查询参数 `skip`，默认值是 `0`\n* 类型为 `int` 的可选查询参数 `limit`，默认值是 `100`\n\n然后，依赖项函数返回包含这些值的 `dict`。\n\n### 导入 `Depends`\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n### 声明依赖项\n\n与在*路径操作函数*参数中使用 `Body`、`Query` 的方式相同，声明依赖项需要使用 `Depends` 和一个新的参数：\n\n\n> *[Ref: Code file `tutorial001_an_py39.py` is already included above]*\n\n\n虽然，在路径操作函数的参数中使用 `Depends` 的方式与 `Body`、`Query` 相同，但 `Depends` 的工作方式略有不同。\n\n这里只能传给 Depends 一个参数。\n\n且该参数必须是可调用对象，比如函数。\n\n该函数接收的参数和*路径操作函数*的参数一样。\n\n/// tip | 提示\n\n下一章介绍，除了函数还有哪些「对象」可以用作依赖项。\n\n///\n\n接收到新的请求时，FastAPI 执行如下操作：\n\n* 用正确的参数调用依赖项函数（「可依赖项」）\n* 获取函数返回的结果\n* 把函数返回的结果赋值给*路径操作函数*的参数\n\n```mermaid\ngraph TB\n\ncommon_parameters([""common_parameters""])\nread_items[""/items/""]\nread_users[""/users/""]\n\ncommon_parameters --&gt; read_items\ncommon_parameters --&gt; read_users\n```\n\n这样，只编写一次代码，FastAPI 就可以为多个*路径操作*共享这段代码 。\n\n/// check | 检查\n\n注意，无需创建专门的类，并将之传递给 FastAPI 以进行「注册」或执行类似的操作。\n\n只要把它传递给 `Depends`，FastAPI 就知道该如何执行后续操作。\n\n///\n\n## 要不要使用 `async`？\n\nFastAPI 调用依赖项的方式与*路径操作函数*一样，因此，定义依赖项函数，也要应用与路径操作函数相同的规则。\n\n即，既可以使用异步的 `async def`，也可以使用普通的 `def` 定义依赖项。\n\n在普通的 `def` *路径操作函数*中，可以声明异步的 `async def` 依赖项；也可以在异步的 `async def` *路径操作函数*中声明普通的 `def` 依赖项。\n\n上述这些操作都是可行的，FastAPI 知道该怎么处理。\n\n/// note | 笔记\n\n如里不了解异步，请参阅[异步：*“着急了？”*](../../async.md){.internal-link target=_blank} 一章中 `async` 和 `await` 的内容。\n\n///\n\n## 与 OpenAPI 集成\n\n依赖项及子依赖项的所有请求声明、验证和需求都可以集成至同一个 OpenAPI 概图。\n\n所以，交互文档里也会显示依赖项的所有信息：\n\n## 简单用法\n\n观察一下就会发现，只要*路径* 和*操作*匹配，就可以使用声明的路径操作函数。然后，FastAPI 会用正确的参数调用函数，并提取请求中的数据。\n\n实际上，所有（或大多数）网络框架的工作方式都是这样的。\n\n开发人员永远都不需要直接调用这些函数，这些函数是由框架（在此为 FastAPI ）调用的。\n\n通过依赖注入系统，只要告诉 FastAPI *路径操作函数* 还要「依赖」其他在*路径操作函数*之前执行的内容，FastAPI 就会执行函数代码，并「注入」函数返回的结果。\n\n其他与「依赖注入」概念相同的术语为：\n\n* 资源（Resource）\n* 提供方（Provider）\n* 服务（Service）\n* 可注入（Injectable）\n* 组件（Component）\n\n## FastAPI 插件\n\n依赖注入系统支持构建集成和「插件」。但实际上，FastAPI 根本不需要创建「插件」，因为使用依赖项可以声明不限数量的、可用于*路径操作函数*的集成与交互。\n\n创建依赖项非常简单、直观，并且还支持导入 Python 包。毫不夸张地说，只要几行代码就可以把需要的 Python 包与 API 函数集成在一起。\n\n下一章将详细介绍在关系型数据库、NoSQL 数据库、安全等方面使用依赖项的例子。\n\n## FastAPI 兼容性\n\n依赖注入系统如此简洁的特性，让 FastAPI 可以与下列系统兼容：\n\n* 关系型数据库\n* NoSQL 数据库\n* 外部支持库\n* 外部 API\n* 认证和鉴权系统\n* API 使用监控系统\n* 响应数据注入系统\n* 等等……\n\n## 简单而强大\n\n虽然，层级式依赖注入系统的定义与使用十分简单，但它却非常强大。\n\n比如，可以定义依赖其他依赖项的依赖项。\n\n最后，依赖项层级树构建后，依赖注入系统会处理所有依赖项及其子依赖项，并为每一步操作提供（注入）结果。\n\n比如，下面有 4 个 API 路径操作（*端点*）：\n\n* `/items/public/`\n* `/items/private/`\n* `/users/{user_id}/activate`\n* `/items/pro/`\n\n开发人员可以使用依赖项及其子依赖项为这些路径操作添加不同的权限：\n\n```mermaid\ngraph TB\n\ncurrent_user([""current_user""])\nactive_user([""active_user""])\nadmin_user([""admin_user""])\npaying_user([""paying_user""])\n\npublic[""/items/public/""]\nprivate[""/items/private/""]\nactivate_user[""/users/{user_id}/activate""]\npro_items[""/items/pro/""]\n\ncurrent_user --&gt; active_user\nactive_user --&gt; admin_user\nactive_user --&gt; paying_user\n\ncurrent_user --&gt; public\nactive_user --&gt; private\nadmin_user --&gt; activate_user\npaying_user --&gt; pro_items\n```\n\n## 与 OpenAPI 集成\n\n在声明需求时，所有这些依赖项还会把参数、验证等功能添加至路径操作。\n\nFastAPI 负责把上述内容全部添加到 OpenAPI 概图，并显示在交互文档中。']","在 FastAPI 中，多个嵌套依赖项的执行顺序遵循 **由内向外的层级顺序**：  
1. 子依赖项（最内层）优先执行，父依赖项按依赖层级依次向外执行。  
2. 同一请求中重复的依赖项仅执行一次，返回值会被缓存复用（可通过 `use_cache=False` 禁用）。  
3. 若依赖项含 `yield`，`yield` 前代码按正向顺序执行，`yield` 后清理代码按反向顺序执行。  

（参考上下文中的流程图与代码示例）", FastAPI 采用深度优先（Depth-First）的顺序解析依赖树。1. 如果依赖 A 依赖于依赖 B，则 B 会先于 A 执行；2. 在同一个请求中，FastAPI 默认会缓存依赖项的结果。例如，如果路由函数同时依赖了 A 和 B，而 A 和 B 都依赖了 C，那么 C 只会被执行一次，其结果会被缓存并复用给 A 和 B。如果需要每次都重新执行，可以设置 use_cache=False。,0.99999999995,1.0,0.9297005631826354
