user_input,retrieved_contexts,response,reference,context_recall,faithfulness,factual_correctness(mode=f1)
什么是 FastAPI？它的核心特性有哪些？,"['其他形式的异步代码\n\n这种使用 async 和 await 的风格在语言中相对较新。\n\n但它使处理异步代码变得容易很多。\n\n这种相同的语法（或几乎相同）最近也包含在现代版本的 JavaScript 中（在浏览器和 NodeJS 中）。\n\n但在此之前，处理异步代码非常复杂和困难。\n\n在以前版本的 Python，你可以使用多线程或者 Gevent。但代码的理解、调试和思考都要复杂许多。\n\n在以前版本的 NodeJS / 浏览器 JavaScript 中，你会使用""回调""，因此也可能导致“回调地狱”。\n\n协程\n\n协程只是 async def 函数返回的一个非常奇特的东西的称呼。Python 知道它有点像一个函数，它可以启动，也会在某个时刻结束，而且它可能会在内部暂停 ⏸ ，只要内部有一个 await。\n\n通过使用 async 和 await 的异步代码的所有功能大多数被概括为""协程""。它可以与 Go 的主要关键特性 ""Goroutines"" 相媲美。\n\n结论\n\n让我们再来回顾下上文所说的：\n\nPython 的现代版本可以通过使用 async 和 await 语法创建协程，并用于支持异步代码。\n\n现在应该能明白其含义了。✨\n\n所有这些使得 FastAPI（通过 Starlette）如此强大，也是它拥有如此令人印象深刻的性能的原因。\n\n非常技术性的细节\n\n/// warning\n\n你可以跳过这里。\n\n这些都是 FastAPI 如何在内部工作的技术细节。\n\n如果你有相当多的技术知识（协程、线程、阻塞等），并且对 FastAPI 如何处理 async def 与常规 def 感到好奇，请继续。\n\n///\n\n路径操作函数\n\n当你使用 def 而不是 async def 来声明一个路径操作函数时，它运行在外部的线程池中并等待其结果，而不是直接调用（因为它会阻塞服务器）。\n\n如果你使用过另一个不以上述方式工作的异步框架，并且你习惯于用普通的 def 定义普通的仅计算路径操作函数，以获得微小的性能增益（大约100纳秒），请注意，在 FastAPI 中，效果将完全相反。在这些情况下，最好使用 async def，除非路径操作函数内使用执行阻塞 I/O 的代码。\n\n在这两种情况下，与你之前的框架相比，FastAPI 可能仍然很快{.internal-link target=_blank}。\n\n依赖\n\n这同样适用于依赖{.internal-link target=_blank}。如果一个依赖是标准的 def 函数而不是 async def，它将被运行在外部线程池中。\n\n子依赖\n\n你可以拥有多个相互依赖的依赖以及子依赖{.internal-link target=_blank} （作为函数的参数），它们中的一些可能是通过 async def 声明，也可能是通过 def 声明。它们仍然可以正常工作，这些通过 def 声明的函数将会在外部线程中调用（来自线程池），而不是""被等待""。\n\n其他函数\n\n你可直接调用通过 def 或 async def 创建的任何其他函数，FastAPI 不会影响你调用它们的方式。\n\n这与 FastAPI 为你调用路径操作函数和依赖项的逻辑相反。\n\n如果你的函数是通过 def 声明的，它将被直接调用（在代码中编写的地方），而不会在线程池中，如果这个函数通过 async def 声明，当在代码中调用时，你就应该使用 await 等待函数的结果。\n\n再次提醒，这些是非常技术性的细节，如果你来搜索它可能对你有用。\n\n否则，你最好应该遵守的指导原则赶时间吗？.', '然后，在下一个（也是最后一个）阶段，你将或多或少地以与前面描述的相同的方式构建镜像。\n\n在TLS 终止代理后面 - Poetry\n\n同样，如果你在 Nginx 或 Traefik 等 TLS 终止代理（负载均衡器）后面运行容器，请将选项--proxy-headers添加到命令中：\n\nCMD [""uvicorn"", ""app.main:app"", ""--proxy-headers"", ""--host"", ""0.0.0.0"", ""--port"", ""80""]\n\n回顾\n\n使用容器系统（例如使用Docker和Kubernetes），处理所有部署概念变得相当简单：\n\nHTTPS\n\n启动时运行\n\n重新启动\n\n复制（运行的进程数）\n\n内存\n\n开始前的先前步骤\n\n在大多数情况下，你可能不想使用任何基础镜像，而是基于官方 Python Docker 镜像 从头开始构建容器镜像 。\n\n处理好Dockerfile和 Docker 缓存中指令的顺序，你可以最小化构建时间，从而最大限度地提高生产力（并避免无聊）。 😎\n\n在某些特殊情况下，你可能需要使用 FastAPI 的官方 Docker 镜像。 🤓', '学习\n\n以下是学习 FastAPI 的介绍部分和教程。\n\n您可以认为这是一本 书，一门 课程，是 官方 且推荐的学习FastAPI的方法。😎', '然后我们会使用 hero_db.sqlmodel_update(hero_data) ，来利用 hero_data 的数据更新 hero_db 。\n\n{ ../../docs_src/sql_databases/tutorial002_an_py310.py ln[83:93] hl[83:84,88:89] }\n\n（又一次）删除单个 Hero\n\n删除一个 hero 基本保持不变。\n\n我们不会满足在这一部分中重构一切的愿望。😅\n\n{ ../../docs_src/sql_databases/tutorial002_an_py310.py ln[96:103] hl[101] }\n\n（又一次）运行应用程序\n\n您可以再运行一次应用程序：\n\n$ fastapi dev main.py\n\n<span style=""color: green;"">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n\n您会在 /docs API UI 看到它现在已经更新，并且在进行创建 hero 等操作时，它不会再期望从客户端接收 id 数据。\n\n\n\n总结\n\n您可以使用 SQLModel 与 SQL 数据库进行交互，并通过数据模型和表模型简化代码。\n\n您可以在 SQLModel 的文档中学习到更多内容，其中有一个更详细的关于如何将 SQLModel 与 FastAPI 一起使用的教程。🚀']","Based on the provided context, I cannot answer the question as it doesn't define FastAPI or explicitly list its core features. The context focuses on asynchronous programming concepts in Python (async/await, coroutines) and technical implementation details of FastAPI's handling of async vs. synchronous functions, dependencies, and deployment. It does not provide a description of FastAPI itself or enumerate its key characteristics.",FastAPI 是一个用于构建 API 的现代、高性能的 Python Web 框架，基于标准 Python 类型提示。核心特性包括：1. 高性能：可与 NodeJS 和 Go 并肩（归功于 Starlette 和 Pydantic）；2. 开发速度快：提高功能开发速度约 200% 至 300%；3. 减少 Bug：减少约 40% 的人为错误；4. 直观：强大的编辑器支持和自动补全；5. 简单：易于学习和使用；6. 代码短：最小化代码重复；7. 健壮：生产级代码，自动交互式文档；8. 标准：完全兼容 OpenAPI 和 JSON Schema。,0.3333333333333333,1.0,0.0
FastAPI 与 Pydantic 是什么关系？为什么它依赖 Pydantic？,"['第一个函数用于校验接收的密码是否匹配存储的哈希值。\n\n第三个函数用于身份验证，并返回用户。\n\n{ ../../docs_src/security/tutorial004_an_py310.py hl[8,49,56:57,60:61,70:76] }\n\n/// note | 笔记\n\n查看新的（伪）数据库 fake_users_db，就能看到哈希后的密码：""$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW""。\n\n///\n\n处理 JWT 令牌\n\n导入已安装的模块。\n\n创建用于 JWT 令牌签名的随机密钥。\n\n使用以下命令，生成安全的随机密钥：\n\n$ openssl rand -hex 32\n\n09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\n\n然后，把生成的密钥复制到变量SECRET_KEY，注意，不要使用本例所示的密钥。\n\n创建指定 JWT 令牌签名算法的变量 ALGORITHM，本例中的值为 ""HS256""。\n\n创建设置令牌过期时间的变量。\n\n定义令牌端点响应的 Pydantic 模型。\n\n创建生成新的访问令牌的工具函数。\n\n{ ../../docs_src/security/tutorial004.py hl[6,12:14,28:30,78:86] }\n\n更新依赖项\n\n更新 get_current_user 以接收与之前相同的令牌，但这里用的是 JWT 令牌。\n\n解码并校验接收到的令牌，然后，返回当前用户。\n\n如果令牌无效，则直接返回 HTTP 错误。\n\n{ ../../docs_src/security/tutorial004_an_py310.py hl[4,7,13:15,29:31,79:87] }\n\n更新 /token 路径操作\n\n用令牌过期时间创建 timedelta 对象。\n\n创建并返回真正的 JWT 访问令牌。\n\n{ ../../docs_src/security/tutorial004_an_py310.py hl[118:133] }\n\nJWT sub 的技术细节\n\nJWT 规范还包括 sub 键，值是令牌的主题。\n\n该键是可选的，但要把用户标识放在这个键里，所以本例使用了该键。\n\n除了识别用户与许可用户在 API 上直接执行操作之外，JWT 还可能用于其它事情。\n\n例如，识别汽车或博客。\n\n接着，为实体添加权限，比如驾驶（汽车）或编辑（博客）。\n\n然后，把 JWT 令牌交给用户（或机器人），他们就可以执行驾驶汽车，或编辑博客等操作。无需注册账户，只要有 API 生成的 JWT 令牌就可以。\n\n同理，JWT 可以用于更复杂的场景。\n\n在这些情况下，多个实体的 ID 可能是相同的，以 ID foo 为例，用户的 ID 是 foo，车的 ID 是 foo，博客的 ID 也是 foo。\n\n为了避免 ID 冲突，在给用户创建 JWT 令牌时，可以为 sub 键的值加上前缀，例如 username:。因此，在本例中，sub 的值可以是：username:johndoe。\n\n注意，划重点，sub 键在整个应用中应该只有一个唯一的标识符，而且应该是字符串。\n\n检查\n\n运行服务器并访问文档： http://127.0.0.1:8000/docs。\n\n可以看到如下用户界面：\n\n\n\n用与上一章同样的方式实现应用授权。\n\n使用如下凭证：\n\n用户名: johndoe 密码: secret\n\n/// check | 检查\n\n注意，代码中没有明文密码secret，只保存了它的哈希值。\n\n///\n\n\n\n调用 /users/me/ 端点，收到下面的响应：\n\n{\n  ""username"": ""johndoe"",\n  ""email"": ""johndoe@example.com"",\n  ""full_name"": ""John Doe"",\n  ""disabled"": false\n}\n\n\n\n打开浏览器的开发者工具，查看数据是怎么发送的，而且数据里只包含了令牌，只有验证用户的第一个请求才发送密码，并获取访问令牌，但之后不会再发送密码：\n\n\n\n/// note | 笔记\n\n注意，请求中 Authorization 响应头的值以 Bearer 开头。\n\n///\n\nscopes 高级用法\n\nOAuth2 支持scopes（作用域）。\n\nscopes为 JWT 令牌添加指定权限。\n\n让持有令牌的用户或第三方在指定限制条件下与 API 交互。\n\n高级用户指南中将介绍如何使用 scopes，及如何把 scopes 集成至 FastAPI。\n\n小结', '使用数据类\n\nFastAPI 基于 Pydantic 构建，前文已经介绍过如何使用 Pydantic 模型声明请求与响应。\n\n但 FastAPI 还可以使用数据类（dataclasses）：\n\n{ ../../docs_src/dataclasses_/tutorial001.py hl[1,7:12,19:20] }\n\n这还是借助于 Pydantic 及其内置的 dataclasses。\n\n因此，即便上述代码没有显式使用 Pydantic，FastAPI 仍会使用 Pydantic 把标准数据类转换为 Pydantic 数据类（dataclasses）。\n\n并且，它仍然支持以下功能：\n\n数据验证\n\n数据序列化\n\n数据存档等\n\n数据类的和运作方式与 Pydantic 模型相同。实际上，它的底层使用的也是 Pydantic。\n\n/// info | 说明\n\n注意，数据类不支持 Pydantic 模型的所有功能。\n\n因此，开发时仍需要使用 Pydantic 模型。\n\n但如果数据类很多，这一技巧能给 FastAPI 开发 Web API 增添不少助力。🤓\n\n///\n\nresponse_model 使用数据类\n\n在 response_model 参数中使用 dataclasses：\n\n{ ../../docs_src/dataclasses_/tutorial002.py hl[1,7:13,19] }\n\n本例把数据类自动转换为 Pydantic 数据类。\n\nAPI 文档中也会显示相关概图：\n\n\n\n在嵌套数据结构中使用数据类\n\n您还可以把 dataclasses 与其它类型注解组合在一起，创建嵌套数据结构。\n\n还有一些情况也可以使用 Pydantic 的 dataclasses。例如，在 API 文档中显示错误。\n\n本例把标准的 dataclasses 直接替换为 pydantic.dataclasses：\n\n{!../../docs_src/dataclasses_/tutorial003.py!}\n\n本例依然要从标准的 dataclasses 中导入 field；\n\n使用 pydantic.dataclasses 直接替换 dataclasses；\n\nAuthor 数据类包含 Item 数据类列表；\n\nAuthor 数据类用于 response_model 参数；\n\n其它带有数据类的标准类型注解也可以作为请求体；\n\n本例使用的是 Item 数据类列表；\n\n这行代码返回的是包含 items 的字典，items 是数据类列表；\n\nFastAPI 仍能把数据序列化为 JSON；\n\n这行代码中，response_model 的类型注解是 Author 数据类列表；\n\n再一次，可以把 dataclasses 与标准类型注解一起使用；\n\n注意，路径操作函数使用的是普通函数，不是异步函数；\n\n与往常一样，在 FastAPI 中，可以按需组合普通函数与异步函数；\n\n如果不清楚何时使用异步函数或普通函数，请参阅急不可待？一节中对 async 与 await 的说明；\n\n路径操作函数返回的不是数据类（虽然它可以返回数据类），而是返回内含数据的字典列表；\n\nFastAPI 使用（包含数据类的） response_model 参数转换响应。\n\n把 dataclasses 与其它类型注解组合在一起，可以组成不同形式的复杂数据结构。\n\n更多内容详见上述代码内的注释。\n\n深入学习\n\n您还可以把 dataclasses 与其它 Pydantic 模型组合在一起，继承合并的模型，把它们包含在您自己的模型里。\n\n详见 Pydantic 官档 - 数据类。\n\n版本\n\n本章内容自 FastAPI 0.67.0 版起生效。🔖', '数据转换\n\n数据校验\n\n自动生成文档\n\n特殊的类型和校验\n\n除了普通的单一值类型（如 str、int、float 等）外，你还可以使用从 str 继承的更复杂的单一值类型。\n\n要了解所有的可用选项，请查看关于 来自 Pydantic 的外部类型 的文档。你将在下一章节中看到一些示例。\n\n例如，在 Image 模型中我们有一个 url 字段，我们可以把它声明为 Pydantic 的 HttpUrl，而不是 str：\n\n{ ../../docs_src/body_nested_models/tutorial005_py310.py hl[2,8] }\n\n该字符串将被检查是否为有效的 URL，并在 JSON Schema / OpenAPI 文档中进行记录。\n\n带有一组子模型的属性\n\n你还可以将 Pydantic 模型用作 list、set 等的子类型：\n\n{ ../../docs_src/body_nested_models/tutorial006_py310.py hl[18] }\n\n这将期望（转换，校验，记录文档等）下面这样的 JSON 请求体：\n\n{\n    ""name"": ""Foo"",\n    ""description"": ""The pretender"",\n    ""price"": 42.0,\n    ""tax"": 3.2,\n    ""tags"": [\n        ""rock"",\n        ""metal"",\n        ""bar""\n    ],\n    ""images"": [\n        {\n            ""url"": ""http://example.com/baz.jpg"",\n            ""name"": ""The Foo live""\n        },\n        {\n            ""url"": ""http://example.com/dave.jpg"",\n            ""name"": ""The Baz""\n        }\n    ]\n}\n\n/// info\n\n请注意 images 键现在具有一组 image 对象是如何发生的。\n\n///\n\n深度嵌套模型\n\n你可以定义任意深度的嵌套模型：\n\n{ ../../docs_src/body_nested_models/tutorial007_py310.py hl[7,12,18,21,25] }\n\n/// info\n\n请注意 Offer 拥有一组 Item 而反过来 Item 又是一个可选的 Image 列表是如何发生的。\n\n///\n\n纯列表请求体\n\n如果你期望的 JSON 请求体的最外层是一个 JSON array（即 Python list），则可以在路径操作函数的参数中声明此类型，就像声明 Pydantic 模型一样：\n\nimages: List[Image]\n\n例如：\n\n{ ../../docs_src/body_nested_models/tutorial008_py39.py hl[13] }\n\n无处不在的编辑器支持\n\n你可以随处获得编辑器支持。\n\n即使是列表中的元素：\n\n\n\n如果你直接使用 dict 而不是 Pydantic 模型，那你将无法获得这种编辑器支持。\n\n但是你根本不必担心这两者，传入的字典会自动被转换，你的输出也会自动被转换为 JSON。\n\n任意 dict 构成的请求体\n\n你也可以将请求体声明为使用某类型的键和其他类型值的 dict。\n\n无需事先知道有效的字段/属性（在使用 Pydantic 模型的场景）名称是什么。\n\n如果你想接收一些尚且未知的键，这将很有用。\n\n其他有用的场景是当你想要接收其他类型的键时，例如 int。\n\n这也是我们在接下来将看到的。\n\n在下面的例子中，你将接受任意键为 int 类型并且值为 float 类型的 dict：\n\n{ ../../docs_src/body_nested_models/tutorial009_py39.py hl[7] }\n\n/// tip\n\n请记住 JSON 仅支持将 str 作为键。\n\n但是 Pydantic 具有自动转换数据的功能。\n\n这意味着，即使你的 API 客户端只能将字符串作为键发送，只要这些字符串内容仅包含整数，Pydantic 就会对其进行转换并校验。\n\n然后你接收的名为 weights 的 dict 实际上将具有 int 类型的键和 float 类型的值。\n\n///\n\n总结\n\n使用 FastAPI 你可以拥有 Pydantic 模型提供的极高灵活性，同时保持代码的简单、简短和优雅。\n\n而且还具有下列好处：\n\n编辑器支持（处处皆可自动补全！）\n\n数据转换（也被称为解析/序列化）\n\n数据校验\n\n模式文档', '然后，在下一个（也是最后一个）阶段，你将或多或少地以与前面描述的相同的方式构建镜像。\n\n在TLS 终止代理后面 - Poetry\n\n同样，如果你在 Nginx 或 Traefik 等 TLS 终止代理（负载均衡器）后面运行容器，请将选项--proxy-headers添加到命令中：\n\nCMD [""uvicorn"", ""app.main:app"", ""--proxy-headers"", ""--host"", ""0.0.0.0"", ""--port"", ""80""]\n\n回顾\n\n使用容器系统（例如使用Docker和Kubernetes），处理所有部署概念变得相当简单：\n\nHTTPS\n\n启动时运行\n\n重新启动\n\n复制（运行的进程数）\n\n内存\n\n开始前的先前步骤\n\n在大多数情况下，你可能不想使用任何基础镜像，而是基于官方 Python Docker 镜像 从头开始构建容器镜像 。\n\n处理好Dockerfile和 Docker 缓存中指令的顺序，你可以最小化构建时间，从而最大限度地提高生产力（并避免无聊）。 😎\n\n在某些特殊情况下，你可能需要使用 FastAPI 的官方 Docker 镜像。 🤓']","Based on the context:

1. FastAPI is built on Pydantic, leveraging its capabilities for data validation, serialization, and documentation.
2. It depends on Pydantic because Pydantic provides automatic:
   - Data validation for requests/responses
   - Data conversion (serialization/deserialization)
   - Integration with OpenAPI documentation
3. Even when using standard Python dataclasses, FastAPI internally converts them to Pydantic models to maintain these features.",FastAPI 与 Pydantic 是深度集成的关系。FastAPI 使用 Pydantic 来进行数据的定义、校验、序列化（数据转换）和自动生成 OpenAPI Schema。它依赖 Pydantic 的原因在于：Pydantic 提供了强大的类型声明能力，使得 FastAPI 能够自动验证传入的请求数据是否符合预期格式，并将复杂的数据库对象或 Python 模型自动转换为 JSON 格式。此外，这种基于类型提示的定义方式直接驱动了 Swagger UI 的自动生成。,1.0,1.0,0.82
FastAPI 的依赖注入系统（Dependency Injection）是如何工作的？请举例说明 Depends 的用法。,"['后台任务\n\n你可以定义在返回响应后运行的后台任务。\n\n这对需要在请求之后执行的操作很有用，但客户端不必在接收响应之前等待操作完成。\n\n包括这些例子：\n\n执行操作后发送的电子邮件通知：\n\n由于连接到电子邮件服务器并发送电子邮件往往很“慢”（几秒钟），您可以立即返回响应并在后台发送电子邮件通知。\n\n处理数据：\n\n例如，假设您收到的文件必须经过一个缓慢的过程，您可以返回一个""Accepted""(HTTP 202)响应并在后台处理它。\n\n使用 BackgroundTasks\n\n首先导入 BackgroundTasks 并在 路径操作函数 中使用类型声明 BackgroundTasks 定义一个参数：\n\n{ ../../docs_src/background_tasks/tutorial001.py hl[1, 13] }\n\nFastAPI 会创建一个 BackgroundTasks 类型的对象并作为该参数传入。\n\n创建一个任务函数\n\n创建要作为后台任务运行的函数。\n\n它只是一个可以接收参数的标准函数。\n\n它可以是 async def 或普通的 def 函数，FastAPI 知道如何正确处理。\n\n在这种情况下，任务函数将写入一个文件（模拟发送电子邮件）。\n\n由于写操作不使用 async 和 await，我们用普通的 def 定义函数：\n\n{ ../../docs_src/background_tasks/tutorial001.py hl[6:9] }\n\n添加后台任务\n\n在你的 路径操作函数 里，用 .add_task() 方法将任务函数传到 后台任务 对象中：\n\n{ ../../docs_src/background_tasks/tutorial001.py hl[14] }\n\n.add_task() 接收以下参数：\n\n在后台运行的任务函数(write_notification)。\n\n应按顺序传递给任务函数的任意参数序列(email)。\n\n应传递给任务函数的任意关键字参数(message=""some notification"")。\n\n依赖注入\n\n使用 BackgroundTasks 也适用于依赖注入系统，你可以在多个级别声明 BackgroundTasks 类型的参数：在 路径操作函数 里，在依赖中(可依赖)，在子依赖中，等等。\n\nFastAPI 知道在每种情况下该做什么以及如何复用同一对象，因此所有后台任务被合并在一起并且随后在后台运行：\n\n//// tab | Python 3.10+\n\n{ ../../docs_src/background_tasks/tutorial002_an_py310.py hl[13, 15, 22, 25] }\n\n////\n\n//// tab | Python 3.9+\n\n{ ../../docs_src/background_tasks/tutorial002_an_py39.py hl[13, 15, 22, 25] }\n\n////\n\n//// tab | Python 3.8+\n\n{ ../../docs_src/background_tasks/tutorial002_an.py hl[14, 16, 23, 26] }\n\n////\n\n//// tab | Python 3.10+ 没Annotated\n\n/// tip\n\n尽可能选择使用 Annotated 的版本。\n\n///\n\n{ ../../docs_src/background_tasks/tutorial002_py310.py hl[11, 13, 20, 23] }\n\n////\n\n//// tab | Python 3.8+ 没Annotated\n\n/// tip\n\n尽可能选择使用 Annotated 的版本。\n\n///\n\n{ ../../docs_src/background_tasks/tutorial002.py hl[13, 15, 22, 25] }\n\n////\n\n该示例中，信息会在响应发出 之后 被写到 log.txt 文件。\n\n如果请求中有查询，它将在后台任务中写入日志。\n\n然后另一个在 路径操作函数 生成的后台任务会使用路径参数 email 写入一条信息。\n\n技术细节\n\nBackgroundTasks 类直接来自 starlette.background。\n\n它被直接导入/包含到FastAPI以便你可以从 fastapi 导入，并避免意外从 starlette.background 导入备用的 BackgroundTask (后面没有 s)。', '子应用 - 挂载\n\n如果需要两个独立的 FastAPI 应用，拥有各自独立的 OpenAPI 与文档，则需设置一个主应用，并挂载一个（或多个）子应用。\n\n挂载 FastAPI 应用\n\n挂载是指在特定路径中添加完全独立的应用，然后在该路径下使用路径操作声明的子应用处理所有事务。\n\n顶层应用\n\n首先，创建主（顶层）FastAPI 应用及其路径操作：\n\n{ ../../docs_src/sub_applications/tutorial001.py hl[3,6:8] }\n\n子应用\n\n接下来，创建子应用及其路径操作。\n\n子应用只是另一个标准 FastAPI 应用，但这个应用是被挂载的应用：\n\n{ ../../docs_src/sub_applications/tutorial001.py hl[11,14:16] }\n\n挂载子应用\n\n在顶层应用 app 中，挂载子应用 subapi。\n\n本例的子应用挂载在 /subapi 路径下：\n\n{ ../../docs_src/sub_applications/tutorial001.py hl[11,19] }\n\n查看文档\n\n如果主文件是 main.py，则用以下 uvicorn 命令运行主应用：\n\n$ uvicorn main:app --reload\n\n<span style=""color: green;"">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n\n查看文档 http://127.0.0.1:8000/docs。\n\n下图显示的是主应用 API 文档，只包括其自有的路径操作。\n\n\n\n然后查看子应用文档 http://127.0.0.1:8000/subapi/docs。\n\n下图显示的是子应用的 API 文档，也是只包括其自有的路径操作，所有这些路径操作都在 /subapi 子路径前缀下。\n\n\n\n两个用户界面都可以正常运行，因为浏览器能够与每个指定的应用或子应用会话。\n\n技术细节：root_path\n\n以上述方式挂载子应用时，FastAPI 使用 ASGI 规范中的 root_path 机制处理挂载子应用路径之间的通信。\n\n这样，子应用就可以为自动文档使用路径前缀。\n\n并且子应用还可以再挂载子应用，一切都会正常运行，FastAPI 可以自动处理所有 root_path。\n\n关于 root_path 及如何显式使用 root_path 的内容，详见使用代理{.internal-link target=_blank}一章。', '<span style=""color: green;"">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n\n在浏览器中打开 http://127.0.0.1:8000。\n\n在页面中，您可以设置：\n\n""Item ID""，用于路径。\n\n""Token""，作为查询参数。\n\n/// tip\n\n注意，查询参数 token 将由依赖项处理。\n\n///\n\n通过这样，您可以连接 WebSocket，然后发送和接收消息：\n\n\n\n处理断开连接和多个客户端\n\n当 WebSocket 连接关闭时，await websocket.receive_text() 将引发 WebSocketDisconnect 异常，您可以捕获并处理该异常，就像本示例中的示例一样。\n\n{ ../../docs_src/websockets/tutorial003_py39.py hl[79:81] }\n\n尝试以下操作：\n\n使用多个浏览器选项卡打开应用程序。\n\n从这些选项卡中发送消息。\n\n然后关闭其中一个选项卡。\n\n这将引发 WebSocketDisconnect 异常，并且所有其他客户端都会收到类似以下的消息：\n\nClient #1596980209979 left the chat\n\n/// tip\n\n上面的应用程序是一个最小和简单的示例，用于演示如何处理和向多个 WebSocket 连接广播消息。\n\n但请记住，由于所有内容都在内存中以单个列表的形式处理，因此它只能在进程运行时工作，并且只能使用单个进程。\n\n如果您需要与 FastAPI 集成更简单但更强大的功能，支持 Redis、PostgreSQL 或其他功能，请查看 encode/broadcaster。\n\n///\n\n更多信息\n\n要了解更多选项，请查看 Starlette 的文档：\n\nWebSocket 类\n\n基于类的 WebSocket 处理。', '{ ../../docs_src/query_params_str_validations/tutorial007.py hl[10] }\n\n以及 description：\n\n{ ../../docs_src/query_params_str_validations/tutorial008.py hl[13] }\n\n别名参数\n\n假设你想要查询参数为 item-query。\n\n像下面这样：\n\nhttp://127.0.0.1:8000/items/?item-query=foobaritems\n\n但是 item-query 不是一个有效的 Python 变量名称。\n\n最接近的有效名称是 item_query。\n\n但是你仍然要求它在 URL 中必须是 item-query...\n\n这时你可以用 alias 参数声明一个别名，该别名将用于在 URL 中查找查询参数值：\n\n{ ../../docs_src/query_params_str_validations/tutorial009.py hl[9] }\n\n弃用参数\n\n现在假设你不再喜欢此参数。\n\n你不得不将其保留一段时间，因为有些客户端正在使用它，但你希望文档清楚地将其展示为已弃用。\n\n那么将参数 deprecated=True 传入 Query：\n\n{ ../../docs_src/query_params_str_validations/tutorial010.py hl[18] }\n\n文档将会像下面这样展示它：\n\n\n\n总结\n\n你可以为查询参数声明额外的校验和元数据。\n\n通用的校验和元数据：\n\nalias\n\ntitle\n\ndescription\n\ndeprecated\n\n特定于字符串的校验：\n\nmin_length\n\nmax_length\n\nregex\n\n在这些示例中，你了解了如何声明对 str 值的校验。\n\n请参阅下一章节，以了解如何声明对其他类型例如数值的校验。']","Based on the context provided, I don't have information about FastAPI's dependency injection system or specific examples of using `Depends`. The context focuses on background tasks and sub-applications mounting.","FastAPI 的依赖注入（DI）系统允许你声明路由函数运行前需要执行的逻辑。FastAPI 负责在运行路由前解析这些依赖，并将其结果注入给函数。用法举例：定义一个函数 `common_params(q: str = None, skip: int = 0)`，然后在路由中使用 `params: dict = Depends(common_params)`。当请求到达时，FastAPI 会先调用 `common_params`，处理 URL 参数，再将返回的字典传递给路由。这有助于代码复用、共享数据库连接和实现安全验证。",0.0,0.75,0.0
